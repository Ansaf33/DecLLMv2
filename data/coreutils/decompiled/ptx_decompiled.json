{
    "file": "ptx",
    "decompiled_code": {
        "ptx.c": [
            {
                "func_name": "matcher_error",
                "func_c_signature": "void matcher_error(void)",
                "decompiled_code": "void matcher_error(void) {\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  char *pcVar6;\n  char *pcStack_48;\n  int iStack_3c;\n  char *pcStack_38;\n  \n  uVar4 = gettext(\"error in regular expression matcher\");\n  piVar5 = __errno_location();\n  pcVar6 = (char *)0x1;\n  error(1,*piVar5,uVar4);\n  pcStack_38 = pcVar6;\n  do {\n    while( true ) {\n      do {\n        while( true ) {\n          pcStack_48 = pcVar6;\n          if (*pcStack_48 == '\\0') {\n            *pcStack_38 = '\\0';\n            return;\n          }\n          if (*pcStack_48 == '\\\\') break;\n          *pcStack_38 = *pcStack_48;\n          pcVar6 = pcStack_48 + 1;\n          pcStack_38 = pcStack_38 + 1;\n        }\n        pcVar6 = pcStack_48 + 1;\n        cVar2 = *pcVar6;\n        iVar3 = (int)cVar2;\n      } while (cVar2 == '\\0');\n      if (((-1 < cVar2) && (iVar3 < 0x79)) && (0x2f < iVar3)) break;\nswitchD_001003b3_caseD_31:\n      *pcStack_38 = '\\\\';\n      pcStack_38[1] = *pcVar6;\n      pcVar6 = pcStack_48 + 2;\n      pcStack_38 = pcStack_38 + 2;\n    }\n    switch(iVar3) {\n    case 0x30:\n      cVar2 = '\\0';\n      iStack_3c = 0;\n      for (pcStack_48 = pcStack_48 + 2;\n          ((iStack_3c < 3 && ('/' < *pcStack_48)) && (*pcStack_48 < '8'));\n          pcStack_48 = pcStack_48 + 1) {\n        cVar2 = *pcStack_48 + -0x30 + cVar2 * '\\b';\n        iStack_3c = iStack_3c + 1;\n      }\n      *pcStack_38 = cVar2;\n      pcVar6 = pcStack_48;\n      pcStack_38 = pcStack_38 + 1;\n      break;\n    default:\n      goto switchD_001003b3_caseD_31;\n    case 0x61:\n      *pcStack_38 = '\\a';\n      pcVar6 = pcStack_48 + 2;\n      pcStack_38 = pcStack_38 + 1;\n      break;\n    case 0x62:\n      *pcStack_38 = '\\b';\n      pcVar6 = pcStack_48 + 2;\n      pcStack_38 = pcStack_38 + 1;\n      break;\n    case 99:\n      while (pcStack_48 = pcVar6, pcVar6 = pcStack_48, *pcStack_48 != '\\0') {\n        pcVar6 = pcStack_48 + 1;\n      }\n      break;\n    case 0x66:\n      *pcStack_38 = '\\f';\n      pcVar6 = pcStack_48 + 2;\n      pcStack_38 = pcStack_38 + 1;\n      break;\n    case 0x6e:\n      *pcStack_38 = '\\n';\n      pcVar6 = pcStack_48 + 2;\n      pcStack_38 = pcStack_38 + 1;\n      break;\n    case 0x72:\n      *pcStack_38 = '\\r';\n      pcVar6 = pcStack_48 + 2;\n      pcStack_38 = pcStack_38 + 1;\n      break;\n    case 0x74:\n      *pcStack_38 = '\\t';\n      pcVar6 = pcStack_48 + 2;\n      pcStack_38 = pcStack_38 + 1;\n      break;\n    case 0x76:\n      *pcStack_38 = '\\v';\n      pcVar6 = pcStack_48 + 2;\n      pcStack_38 = pcStack_38 + 1;\n      break;\n    case 0x78:\n      cVar2 = '\\0';\n      iStack_3c = 0;\n      pcStack_48 = pcStack_48 + 2;\n      while ((iStack_3c < 3 && (cVar1 = c_isxdigit((int)*pcStack_48), cVar1 != '\\0'))) {\n        if ((*pcStack_48 < 'a') || ('f' < *pcStack_48)) {\n          if ((*pcStack_48 < 'A') || ('F' < *pcStack_48)) {\n            cVar1 = *pcStack_48 + -0x30;\n          }\n          else {\n            cVar1 = *pcStack_48 + -0x37;\n          }\n        }\n        else {\n          cVar1 = *pcStack_48 + -0x57;\n        }\n        cVar2 = cVar1 + cVar2 * '\\x10';\n        iStack_3c = iStack_3c + 1;\n        pcStack_48 = pcStack_48 + 1;\n      }\n      pcVar6 = pcStack_48;\n      if (iStack_3c == 0) {\n        *pcStack_38 = '\\\\';\n        pcStack_38[1] = 'x';\n        pcStack_38 = pcStack_38 + 2;\n      }\n      else {\n        *pcStack_38 = cVar2;\n        pcStack_38 = pcStack_38 + 1;\n      }\n    }\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "matcher_error",
                        "gettext",
                        "__errno_location",
                        "error",
                        "c_isxdigit"
                    ],
                    "calling_functions": [
                        "matcher_error",
                        "find_occurs_in_text",
                        "define_all_fields",
                        "output_one_tex_line"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "unescape_string",
                "func_c_signature": "void unescape_string(char *param_1)",
                "decompiled_code": "void unescape_string(char *param_1) {\n  char *pcVar1;\n  char cVar2;\n  char cVar3;\n  int iVar4;\n  char *local_20;\n  int local_14;\n  char *local_10;\n  \n  pcVar1 = param_1;\n  local_10 = param_1;\n  do {\n    while( true ) {\n      do {\n        while( true ) {\n          local_20 = pcVar1;\n          if (*local_20 == '\\0') {\n            *local_10 = '\\0';\n            return;\n          }\n          if (*local_20 == '\\\\') break;\n          *local_10 = *local_20;\n          pcVar1 = local_20 + 1;\n          local_10 = local_10 + 1;\n        }\n        pcVar1 = local_20 + 1;\n        cVar3 = *pcVar1;\n        iVar4 = (int)cVar3;\n      } while (cVar3 == '\\0');\n      if (((-1 < cVar3) && (iVar4 < 0x79)) && (0x2f < iVar4)) break;\nswitchD_001003b3_caseD_31:\n      *local_10 = '\\\\';\n      local_10[1] = *pcVar1;\n      pcVar1 = local_20 + 2;\n      local_10 = local_10 + 2;\n    }\n    switch(iVar4) {\n    case 0x30:\n      cVar3 = '\\0';\n      local_14 = 0;\n      for (local_20 = local_20 + 2; ((local_14 < 3 && ('/' < *local_20)) && (*local_20 < '8'));\n          local_20 = local_20 + 1) {\n        cVar3 = *local_20 + -0x30 + cVar3 * '\\b';\n        local_14 = local_14 + 1;\n      }\n      *local_10 = cVar3;\n      pcVar1 = local_20;\n      local_10 = local_10 + 1;\n      break;\n    default:\n      goto switchD_001003b3_caseD_31;\n    case 0x61:\n      *local_10 = '\\a';\n      pcVar1 = local_20 + 2;\n      local_10 = local_10 + 1;\n      break;\n    case 0x62:\n      *local_10 = '\\b';\n      pcVar1 = local_20 + 2;\n      local_10 = local_10 + 1;\n      break;\n    case 99:\n      while (local_20 = pcVar1, pcVar1 = local_20, *local_20 != '\\0') {\n        pcVar1 = local_20 + 1;\n      }\n      break;\n    case 0x66:\n      *local_10 = '\\f';\n      pcVar1 = local_20 + 2;\n      local_10 = local_10 + 1;\n      break;\n    case 0x6e:\n      *local_10 = '\\n';\n      pcVar1 = local_20 + 2;\n      local_10 = local_10 + 1;\n      break;\n    case 0x72:\n      *local_10 = '\\r';\n      pcVar1 = local_20 + 2;\n      local_10 = local_10 + 1;\n      break;\n    case 0x74:\n      *local_10 = '\\t';\n      pcVar1 = local_20 + 2;\n      local_10 = local_10 + 1;\n      break;\n    case 0x76:\n      *local_10 = '\\v';\n      pcVar1 = local_20 + 2;\n      local_10 = local_10 + 1;\n      break;\n    case 0x78:\n      cVar3 = '\\0';\n      local_14 = 0;\n      local_20 = local_20 + 2;\n      while ((local_14 < 3 && (cVar2 = c_isxdigit((int)*local_20), cVar2 != '\\0'))) {\n        if ((*local_20 < 'a') || ('f' < *local_20)) {\n          if ((*local_20 < 'A') || ('F' < *local_20)) {\n            cVar2 = *local_20 + -0x30;\n          }\n          else {\n            cVar2 = *local_20 + -0x37;\n          }\n        }\n        else {\n          cVar2 = *local_20 + -0x57;\n        }\n        cVar3 = cVar2 + cVar3 * '\\x10';\n        local_14 = local_14 + 1;\n        local_20 = local_20 + 1;\n      }\n      pcVar1 = local_20;\n      if (local_14 == 0) {\n        *local_10 = '\\\\';\n        local_10[1] = 'x';\n        local_10 = local_10 + 2;\n      }\n      else {\n        *local_10 = cVar3;\n        local_10 = local_10 + 1;\n      }\n    }\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "unescape_string",
                        "c_isxdigit"
                    ],
                    "calling_functions": [
                        "unescape_string",
                        "main"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "compile_regex",
                "func_c_signature": "void compile_regex(char **param_1)",
                "decompiled_code": "void compile_regex(char **param_1) {\n  char *__s;\n  re_pattern_buffer *__buffer;\n  size_t __length;\n  char *pcVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined1 *puVar4;\n  \n  __buffer = (re_pattern_buffer *)(param_1 + 1);\n  __s = *param_1;\n  __buffer->buffer = (uchar *)0x0;\n  param_1[2] = (char *)0x0;\n  param_1[5] = (char *)(param_1 + 9);\n  if (ignore_case == '\\0') {\n    puVar4 = (char *)0x0;\n  }\n  else {\n    puVar4 = folded_chars;\n  }\n  param_1[6] = puVar4;\n  __length = strlen(__s);\n  pcVar1 = re_compile_pattern(__s,__length,__buffer);\n  if (pcVar1 != (char *)0x0) {\n    uVar2 = quote(__s);\n    uVar3 = gettext(\"%s (for regexp %s)\");\n    error(1,0,uVar3,pcVar1,uVar2);\n  }\n  re_compile_fastmap(__buffer);\n  return;\n}",
                "globals": [],
                "externs": [
                    "s"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "compile_regex",
                        "strlen",
                        "re_compile_pattern",
                        "quote",
                        "gettext",
                        "s",
                        "error",
                        "re_compile_fastmap"
                    ],
                    "calling_functions": [
                        "compile_regex"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "initialize_regex",
                "func_c_signature": "void initialize_regex(void)",
                "decompiled_code": "void initialize_regex(void) {\n  int iVar1;\n  ushort **ppuVar2;\n  int local_c;\n  \n  if (ignore_case != '\\0') {\n    for (local_c = 0; local_c < 0x100; local_c = local_c + 1) {\n      iVar1 = toupper(local_c);\n      folded_chars[local_c] = (char)iVar1;\n    }\n  }\n  if (context_regex == (char *)0x0) {\n    if ((gnu_extensions == '\\0') || (input_reference == '\\x01')) {\n      context_regex = \"\\n\";\n    }\n    else {\n      context_regex = \"[.?!][]\\\"\\')}]*\\\\($\\\\|\\t\\\\|  \\\\)[ \\t\\n]*\";\n    }\n  }",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "initialize_regex",
                        "toupper"
                    ],
                    "calling_functions": [
                        "initialize_regex",
                        "main"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "swallow_file_in_memory",
                "func_c_signature": "void swallow_file_in_memory(char *param_1,long *param_2)",
                "decompiled_code": "void swallow_file_in_memory(char *param_1,long *param_2) {\n  char cVar1;\n  bool bVar2;\n  long lVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  long local_30;\n  undefined *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (((param_1 == (char *)0x0) || (*param_1 == '\\0')) ||\n     (cVar1 = streq(param_1,&DAT_001047ba), cVar1 != '\\0')) {\n    bVar2 = true;\n  }\n  else {\n    bVar2 = false;\n  }\n  if (bVar2) {\n    lVar3 = fread_file(_stdin,0,&local_30);\n    *param_2 = lVar3;\n  }\n  else {\n    lVar3 = read_file(param_1,0,&local_30);\n    *param_2 = lVar3;\n  }\n  if (*param_2 == 0) {\n    if (bVar2) {\n      param_1 = \"-\";\n    }\n    uVar4 = quotearg_n_style_colon(0,3,param_1);\n    piVar5 = __errno_location();\n    local_28 = &DAT_001047bc;\n    error(1,*piVar5,&DAT_001047bc,uVar4);\n  }\n  if (bVar2) {\n    clearerr_unlocked(_stdin);\n  }\n  param_2[1] = *param_2 + local_30;\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "swallow_file_in_memory",
                        "streq",
                        "fread_file",
                        "read_file",
                        "quotearg_n_style_colon",
                        "__errno_location",
                        "error",
                        "clearerr_unlocked",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "swallow_file_in_memory",
                        "digest_break_file",
                        "digest_word_file",
                        "main"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "compare_words",
                "func_c_signature": "int compare_words(long *param_1,long *param_2)",
                "decompiled_code": "int compare_words(long *param_1,long *param_2) {\n  byte bVar1;\n  byte bVar2;\n  long lVar3;\n  long local_38;\n  long local_30;\n  \n  lVar3 = param_1[1];\n  if (param_2[1] <= param_1[1]) {\n    lVar3 = param_2[1];\n  }\n  if (ignore_case == '\\0') {\n    for (local_30 = 0; local_30 < lVar3; local_30 = local_30 + 1) {\n      bVar1 = to_uchar((int)*(char *)(local_30 + *param_1));\n      bVar2 = to_uchar((int)*(char *)(local_30 + *param_2));\n      if ((uint)bVar1 - (uint)bVar2 != 0) {\n        return (uint)bVar1 - (uint)bVar2;\n      }\n    }\n  }\n  else {\n    for (local_38 = 0; local_38 < lVar3; local_38 = local_38 + 1) {\n      bVar1 = to_uchar((int)*(char *)(local_38 + *param_1));\n      bVar1 = folded_chars[(int)(uint)bVar1];\n      bVar2 = to_uchar((int)*(char *)(local_38 + *param_2));\n      if ((uint)bVar1 - (uint)(byte)folded_chars[(int)(uint)bVar2] != 0) {\n        return (uint)bVar1 - (uint)(byte)folded_chars[(int)(uint)bVar2];\n      }\n    }\n  }\n  return (uint)(param_2[1] < param_1[1]) - (uint)(param_1[1] < param_2[1]);\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "compare_words",
                        "to_uchar"
                    ],
                    "calling_functions": [
                        "compare_words",
                        "compare_occurs",
                        "search_table"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "compare_occurs",
                "func_c_signature": "int compare_occurs(ulong *param_1,ulong *param_2)",
                "decompiled_code": "int compare_occurs(ulong *param_1,ulong *param_2) {\n  int iVar1;\n  \n  iVar1 = compare_words(param_1,param_2);\n  if (iVar1 == 0) {\n    iVar1 = (uint)(*param_2 < *param_1) - (uint)(*param_1 < *param_2);\n  }\n  return iVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "compare_occurs",
                        "compare_words"
                    ],
                    "calling_functions": [
                        "compare_occurs"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "search_table",
                "func_c_signature": "undefined8 search_table(undefined8 param_1,long *param_2)",
                "decompiled_code": "undefined8 search_table(undefined8 param_1,long *param_2) {\n  int iVar1;\n  long lVar2;\n  long local_20;\n  long local_18;\n  \n  local_20 = 0;\n  lVar2 = param_2[2];\n  while( true ) {\n    do {\n      local_18 = lVar2;\n      if (local_18 <= local_20) {\n        return 0;\n      }\n      lVar2 = (ulong)((uint)local_20 & (uint)local_18 & 1) + (local_20 >> 1) + (local_18 >> 1);\n      iVar1 = compare_words(param_1,lVar2 * 0x10 + *param_2);\n    } while (iVar1 < 0);\n    if (iVar1 < 1) break;\n    local_20 = lVar2 + 1;\n    lVar2 = local_18;\n  }\n  return 1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "search_table",
                        "compare_words"
                    ],
                    "calling_functions": [
                        "search_table",
                        "find_occurs_in_text"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "sort_found_occurs",
                "func_c_signature": "void sort_found_occurs(void)",
                "decompiled_code": "void sort_found_occurs(void) {\n  if (number_of_occurs != 0) {\n    qsort(occurs_table,number_of_occurs,0x30,compare_occurs);\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "sort_found_occurs",
                        "qsort"
                    ],
                    "calling_functions": [
                        "sort_found_occurs",
                        "main"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "digest_break_file",
                "func_c_signature": "void digest_break_file(undefined8 param_1)",
                "decompiled_code": "void digest_break_file(undefined8 param_1) {\n  byte bVar1;\n  long in_FS_OFFSET;\n  char *local_30;\n  char *local_28;\n  char *local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  swallow_file_in_memory(param_1,&local_28);\n  memset(word_fastmap,1,0x100);\n  for (local_30 = local_28; local_30 < local_20; local_30 = local_30 + 1) {\n    bVar1 = to_uchar((int)*local_30);\n    word_fastmap[(int)(uint)bVar1] = 0;\n  }\n  if (gnu_extensions != '\\x01') {\n    word_fastmap[32] = 0;\n    word_fastmap[9] = 0;\n    word_fastmap[10] = 0;\n  }\n  free(local_28);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "digest_break_file",
                        "swallow_file_in_memory",
                        "memset",
                        "to_uchar",
                        "free",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "digest_break_file",
                        "main"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "digest_word_file",
                "func_c_signature": "void digest_word_file(undefined8 param_1,void **param_2)",
                "decompiled_code": "void digest_word_file(undefined8 param_1,void **param_2) {\n  char *pcVar1;\n  void *pvVar2;\n  long in_FS_OFFSET;\n  char *local_38;\n  char *local_28;\n  char *local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  swallow_file_in_memory(param_1,&local_28);\n  *param_2 = (void *)0x0;\n  param_2[1] = (void *)0x0;\n  param_2[2] = (void *)0x0;\n  local_38 = local_28;\n  while (pcVar1 = local_38, local_38 < local_20) {\n    for (; (local_38 < local_20 && (*local_38 != '\\n')); local_38 = local_38 + 1) {\n    }\n    if (pcVar1 < local_38) {\n      if (param_2[2] == param_2[1]) {\n        pvVar2 = (void *)xpalloc(*param_2,param_2 + 1,1,0xffffffffffffffff,0x10);\n        *param_2 = pvVar2;\n      }\n      *(char **)((long)*param_2 + (long)param_2[2] * 0x10) = pcVar1;\n      *(long *)((long)*param_2 + (long)param_2[2] * 0x10 + 8) = (long)local_38 - (long)pcVar1;\n      param_2[2] = (void *)((long)param_2[2] + 1);\n    }\n    if (local_38 < local_20) {\n      local_38 = local_38 + 1;\n    }\n  }\n  qsort(*param_2,(size_t)param_2[2],0x10,compare_words);\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "digest_word_file",
                        "swallow_file_in_memory",
                        "xpalloc",
                        "qsort",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "digest_word_file",
                        "main"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "find_occurs_in_text",
                "func_c_signature": "void find_occurs_in_text(int param_1)",
                "decompiled_code": "void find_occurs_in_text(int param_1) {\n  ushort *puVar1;\n  byte bVar2;\n  char cVar3;\n  int iVar4;\n  char **ppcVar5;\n  ushort **ppuVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  char **ppcVar9;\n  long in_FS_OFFSET;\n  char *local_a0;\n  char *local_98;\n  char *local_90;\n  char *local_88;\n  long local_80;\n  char *local_78;\n  char *local_70;\n  char *local_68;\n  char *local_60;\n  char *local_58;\n  char *local_38;\n  char *local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  ppcVar5 = (char **)(text_buffers + (long)param_1 * 0x10);\n  local_80 = 0;\n  local_90 = *ppcVar5;\n  local_88 = local_90;\n  if (input_reference != '\\0') {\n    for (; local_88 < ppcVar5[1]; local_88 = local_88 + 1) {\n      ppuVar6 = __ctype_b_loc();\n      puVar1 = *ppuVar6;\n      bVar2 = to_uchar((int)*local_88);\n      if ((puVar1[bVar2] & 0x2000) != 0) break;\n    }\n    local_80 = (long)local_88 - (long)local_90;\n    for (; local_88 < ppcVar5[1]; local_88 = local_88 + 1) {\n      ppuVar6 = __ctype_b_loc();\n      puVar1 = *ppuVar6;\n      bVar2 = to_uchar((int)*local_88);\n      if ((puVar1[bVar2] & 0x2000) == 0) break;\n    }\n  }\n  local_a0 = *ppcVar5;\nLAB_001016d0:\n  if (ppcVar5[1] <= local_a0) {\n    if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n      return;\n    }\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  local_78 = local_a0;\n  local_58 = ppcVar5[1];\n  if (context_regex == 0) goto LAB_00101146;\n  iVar4 = re_search((re_pattern_buffer *)&DAT_00103d28,local_a0,(int)ppcVar5[1] - (int)local_a0,0,\n                    (int)ppcVar5[1] - (int)local_a0,(re_registers *)context_regs);\n  if (iVar4 == 0) {\n    uVar7 = quote(context_regex);\n    uVar8 = gettext(\"error: regular expression has a match of length zero: %s\");\n    error(1,0,uVar8,uVar7);\n  }\n  else if (iVar4 < 1) {\n    if (iVar4 == -2) {\n      matcher_error();\n      goto LAB_00101146;\n    }\n    if (iVar4 == -1) goto LAB_00101146;\n  }\n  local_58 = local_a0 + *(int *)context_regs._16_8_;\nLAB_00101146:\n  for (local_70 = local_58; local_a0 < local_70; local_70 = local_70 + -1) {\n    ppuVar6 = __ctype_b_loc();\n    puVar1 = *ppuVar6;\n    bVar2 = to_uchar((int)local_70[-1]);\n    if ((puVar1[bVar2] & 0x2000) == 0) break;\n  }\nLAB_00101196:\n  do {\n    if (word_regex == 0) {\n      local_98 = local_a0;\n      while ((local_98 < local_70 &&\n             (bVar2 = to_uchar((int)*local_98), word_fastmap[(int)(uint)bVar2] == '\\0'))) {\n        local_98 = local_98 + 1;\n      }\n      if (local_98 == local_70) break;\n      local_68 = local_98;\n      while ((local_98 < local_70 &&\n             (bVar2 = to_uchar((int)*local_98), word_fastmap[(int)(uint)bVar2] != '\\0'))) {\n        local_98 = local_98 + 1;\n      }\n      local_60 = local_98;\n    }\n    else {\n      iVar4 = re_search((re_pattern_buffer *)&DAT_00103e88,local_a0,(int)local_70 - (int)local_a0,0,\n                        (int)local_70 - (int)local_a0,(re_registers *)word_regs);\n      if (iVar4 == -2) {\n        matcher_error();\n      }\n      if (iVar4 == -1) break;\n      local_68 = local_a0 + *(int *)word_regs._8_8_;\n      local_60 = local_a0 + *(int *)word_regs._16_8_;\n    }\n    if (local_60 != local_68) {\n      local_38 = local_68;\n      local_30 = local_60 + -(long)local_68;\n      local_a0 = local_68 + (long)local_30;\n      if ((long)maximum_word_length < (long)local_30) {\n        maximum_word_length = local_30;\n      }\n      if (input_reference != '\\0') {\n        while (local_88 < local_38) {\n          if (*local_88 == '\\n') {\n            total_line_count = total_line_count + 1;\n            local_90 = local_88 + 1;\n            for (local_88 = local_90; local_88 < ppcVar5[1]; local_88 = local_88 + 1) {\n              ppuVar6 = __ctype_b_loc();\n              puVar1 = *ppuVar6;\n              bVar2 = to_uchar((int)*local_88);\n              if ((puVar1[bVar2] & 0x2000) != 0) break;\n            }\n            local_80 = (long)local_88 - (long)local_90;\n          }\n          else {\n            local_88 = local_88 + 1;\n          }\n        }\n        if (local_38 < local_88) goto LAB_00101196;\n      }\n      if (((ignore_file == 0) || (cVar3 = search_table(&local_38,ignore_table), cVar3 == '\\0')) &&\n         ((only_file == 0 || (cVar3 = search_table(&local_38,only_table), cVar3 == '\\x01')))) {\n        if (number_of_occurs == occurs_alloc) {\n          occurs_table = xpalloc(occurs_table,&occurs_alloc,1,0xffffffffffffffff,0x30);\n        }\n        ppcVar9 = (char **)(number_of_occurs * 0x30 + occurs_table);\n        if (auto_reference == '\\0') {\n          if ((input_reference != '\\0') &&\n             (ppcVar9[4] = local_90 + -(long)local_38, reference_max_width < local_80)) {\n            reference_max_width = local_80;\n          }\n        }\n        else {\nLAB_00101556:\n          if (local_88 < local_38) {\n            if (*local_88 == '\\n') {\n              total_line_count = total_line_count + 1;\n              local_90 = local_88 + 1;\n              for (local_88 = local_90; local_88 < ppcVar5[1]; local_88 = local_88 + 1) {\n                ppuVar6 = __ctype_b_loc();\n                puVar1 = *ppuVar6;\n                bVar2 = to_uchar((int)*local_88);\n                if ((puVar1[bVar2] & 0x2000) != 0) break;\n              }\n            }\n            else {\n              local_88 = local_88 + 1;\n            }\n            goto LAB_00101556;\n          }\n          ppcVar9[4] = total_line_count;\n        }\n        if ((input_reference != '\\0') && (local_90 == local_78)) {\n          for (; local_78 < local_70; local_78 = local_78 + 1) {\n            ppuVar6 = __ctype_b_loc();\n            puVar1 = *ppuVar6;\n            bVar2 = to_uchar((int)*local_78);\n            if ((puVar1[bVar2] & 0x2000) != 0) break;\n          }\n          do {\n            if (local_70 <= local_78) break;\n            ppuVar6 = __ctype_b_loc();\n            puVar1 = *ppuVar6;\n            bVar2 = to_uchar((int)*local_78);\n            if ((puVar1[bVar2] & 0x2000) == 0) break;\n            local_78 = local_78 + 1;\n          } while( true );\n        }\n        *ppcVar9 = local_38;\n        ppcVar9[1] = local_30;\n        ppcVar9[2] = local_78 + -(long)local_38;\n        ppcVar9[3] = local_70 + -(long)local_38;\n        *(int *)(ppcVar9 + 5) = param_1;\n        number_of_occurs = number_of_occurs + 1;\n      }\n      goto LAB_00101196;\n    }\n    local_a0 = local_68 + 1;\n  } while( true );\n  local_a0 = local_58;\n  goto LAB_001016d0;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "find_occurs_in_text",
                        "__ctype_b_loc",
                        "to_uchar",
                        "__stack_chk_fail",
                        "re_search",
                        "quote",
                        "gettext",
                        "error",
                        "matcher_error",
                        "search_table",
                        "xpalloc"
                    ],
                    "calling_functions": [
                        "find_occurs_in_text",
                        "main"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "print_spaces",
                "func_c_signature": "void print_spaces(long param_1)",
                "decompiled_code": "void print_spaces(long param_1) {\n  long local_10;\n  \n  for (local_10 = param_1; 0 < local_10; local_10 = local_10 + -1) {\n    putchar_unlocked(0x20);\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "print_spaces",
                        "putchar_unlocked"
                    ],
                    "calling_functions": [
                        "print_spaces",
                        "output_one_dumb_line"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "print_field",
                "func_c_signature": "void print_field(byte *param_1,byte *param_2)",
                "decompiled_code": "void print_field(byte *param_1,byte *param_2) {\n  byte bVar1;\n  uint uVar2;\n  byte *local_10;\n  \n  local_10 = param_1;\n  do {\n    if (param_2 <= local_10) {\n      return;\n    }\n    bVar1 = *local_10;\n    if (edited_flag[(int)(uint)bVar1] == '\\0') {\n      putchar_unlocked((int)(char)*local_10);\n      goto LAB_0010185c;\n    }\n    if (bVar1 == 0x7d) {\nLAB_001017fe:\n      printf(\"$\\\\%c$\",(ulong)bVar1);\n    }\n    else {\n      if (bVar1 < 0x7e) {\n        if (bVar1 == 0x7b) goto LAB_001017fe;\n        if (bVar1 < 0x7c) {\n          if (bVar1 == 0x5f) {\nLAB_001017e7:\n            putchar_unlocked(0x5c);\n            putchar_unlocked((uint)bVar1);\n            goto LAB_0010185c;\n          }\n          if (bVar1 < 0x60) {\n            uVar2 = (uint)bVar1;\n            if (uVar2 == 0x5c) {\n              fwrite_unlocked(\"\\\\backslash{}\",1,0xc,_stdout);\n              goto LAB_0010185c;\n            }\n            if (uVar2 < 0x5d) {\n              if (uVar2 == 0x22) {\n                putchar_unlocked(0x22);\n                putchar_unlocked(0x22);\n                goto LAB_0010185c;\n              }\n              if ((0x21 < uVar2) && (uVar2 - 0x23 < 4)) goto LAB_001017e7;\n            }\n          }\n        }\n      }\n      putchar_unlocked(0x20);\n    }\nLAB_0010185c:\n    local_10 = local_10 + 1;\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "print_field",
                        "putchar_unlocked",
                        "printf",
                        "fwrite_unlocked"
                    ],
                    "calling_functions": [
                        "print_field",
                        "output_one_roff_line",
                        "output_one_tex_line",
                        "output_one_dumb_line"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "fix_output_parameters",
                "func_c_signature": "void fix_output_parameters(void)",
                "decompiled_code": "void fix_output_parameters(void) {\n  byte bVar1;\n  int iVar2;\n  size_t sVar3;\n  long lVar4;\n  ushort **ppuVar5;\n  long in_FS_OFFSET;\n  int local_48;\n  int local_44;\n  long local_40;\n  long local_38;\n  char *local_30;\n  char local_28 [24];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if (auto_reference != '\\0') {\n    reference_max_width = 0;\n    for (local_48 = 0; local_48 < number_input_files; local_48 = local_48 + 1) {\n      local_40 = *(long *)(file_line_count + (long)local_48 * 8) + 1;\n      if (0 < local_48) {\n        local_40 = local_40 - *(long *)(file_line_count + (long)local_48 * 8 + -8);\n      }\n      iVar2 = sprintf(local_28,\"%jd\",local_40);\n      local_38 = (long)iVar2;\n      if (*(long *)(input_file_name + (long)local_48 * 8) != 0) {\n        sVar3 = strlen(*(char **)(input_file_name + (long)local_48 * 8));\n        local_38 = sVar3 + local_38;\n      }\n      if (reference_max_width < local_38) {\n        reference_max_width = local_38;\n      }\n    }\n    lVar4 = reference_max_width + 2;\n    reference_max_width = reference_max_width + 1;\n    reference = xmalloc(lVar4);\n  }\n  if ((((auto_reference != '\\0') || (input_reference != '\\0')) && (right_reference != '\\x01')) &&\n     (line_width = line_width - (gap_size + reference_max_width), line_width < 0)) {\n    line_width = 0;\n  }\n  half_line_width = line_width >> 1;\n  before_max_width = half_line_width - gap_size;\n  keyafter_max_width = half_line_width;\n  if ((truncation_string == (undefined *)0x0) || (*truncation_string == '\\0')) {\n    truncation_string = (undefined *)0x0;\n  }\n  else {\n    truncation_string_length = strlen(truncation_string);\n  }\n  if (gnu_extensions == '\\0') {\n    lVar4 = -(truncation_string_length * 2 + 1);\n  }\n  else {\n    before_max_width = before_max_width + truncation_string_length * -2;\n    if (before_max_width < 0) {\n      before_max_width = 0;\n    }\n    lVar4 = truncation_string_length * -2;\n  }\n  keyafter_max_width = keyafter_max_width + lVar4;\n  for (local_44 = 0; local_44 < 0x100; local_44 = local_44 + 1) {\n    ppuVar5 = __ctype_b_loc();\n    edited_flag[local_44] = ((*ppuVar5)[local_44] & 0x2000) != 0;\n  }\n  edited_flag[12] = 1;\n  if (output_format == 3) {\n    for (local_30 = \"$%&#_{}\\\\\"; *local_30 != '\\0'; local_30 = local_30 + 1) {\n      bVar1 = to_uchar((int)*local_30);\n      edited_flag[(int)(uint)bVar1] = 1;\n    }\n  }\n  else if (((output_format < 4) && (1 < output_format)) && (output_format == 2)) {\n    edited_flag[34] = 1;\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "fix_output_parameters",
                        "sprintf",
                        "strlen",
                        "xmalloc",
                        "__ctype_b_loc",
                        "to_uchar",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "fix_output_parameters",
                        "main"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "define_all_fields",
                "func_c_signature": "void define_all_fields(char **param_1)",
                "decompiled_code": "void define_all_fields(char **param_1) {\n  char *pcVar1;\n  ushort *puVar2;\n  byte bVar3;\n  int iVar4;\n  char *pcVar5;\n  char *pcVar6;\n  ushort **ppuVar7;\n  long lVar8;\n  long lVar9;\n  char *pcVar10;\n  char *local_70;\n  char *local_68;\n  char *local_60;\n  char *local_58;\n  \n  keyafter = *param_1;\n  DAT_00104428 = param_1[1] + (long)keyafter;\n  pcVar5 = param_1[2] + (long)keyafter;\n  pcVar6 = param_1[3] + (long)keyafter;\n  pcVar10 = *(char **)((long)*(int *)(param_1 + 5) * 0x10 + text_buffers);\n  pcVar1 = *(char **)((long)*(int *)(param_1 + 5) * 0x10 + text_buffers + 8);\n  local_70 = DAT_00104428;\n  while ((local_70 < pcVar6 && (local_70 <= keyafter + keyafter_max_width))) {\n    DAT_00104428 = local_70;\n    if (word_regex == 0) {\n      bVar3 = to_uchar((int)*local_70);\n      if (word_fastmap[(int)(uint)bVar3] == '\\0') {\n        local_70 = local_70 + 1;\n      }\n      else {\n        while ((local_70 < pcVar6 &&\n               (bVar3 = to_uchar((int)*local_70), word_fastmap[(int)(uint)bVar3] != '\\0'))) {\n          local_70 = local_70 + 1;\n        }\n      }\n    }\n    else {\n      iVar4 = re_match((re_pattern_buffer *)&DAT_00103e88,local_70,(int)pcVar6 - (int)local_70,0,\n                       (re_registers *)0x0);\n      if (iVar4 == -2) {\n        matcher_error();\n      }\n      if (iVar4 == -1) {\n        lVar8 = 1;\n      }\n      else {\n        lVar8 = (long)iVar4;\n      }\n      local_70 = local_70 + lVar8;\n    }\n  }\n  if (local_70 <= keyafter + keyafter_max_width) {\n    DAT_00104428 = local_70;\n  }\n  if ((truncation_string == (undefined *)0x0) || (pcVar6 <= DAT_00104428)) {\n    keyafter_truncation = 0;\n  }\n  else {\n    keyafter_truncation = 1;\n  }\n  for (; keyafter < DAT_00104428; DAT_00104428 = DAT_00104428 + -1) {\n    ppuVar7 = __ctype_b_loc();\n    puVar2 = *ppuVar7;\n    bVar3 = to_uchar((int)DAT_00104428[-1]);\n    if ((puVar2[bVar3] & 0x2000) == 0) break;\n  }\n  if ((char *)-(maximum_word_length + half_line_width) == param_1[2] ||\n      -(long)param_1[2] < maximum_word_length + half_line_width) {\n    local_68 = param_1[2] + (long)keyafter;\n  }\n  else {\n    local_68 = keyafter + -(maximum_word_length + half_line_width);\n    if (word_regex == 0) {\n      bVar3 = to_uchar((int)*local_68);\n      if (word_fastmap[(int)(uint)bVar3] == '\\0') {\n        local_68 = local_68 + 1;\n      }\n      else {\n        while ((local_68 < keyafter &&\n               (bVar3 = to_uchar((int)*local_68), word_fastmap[(int)(uint)bVar3] != '\\0'))) {\n          local_68 = local_68 + 1;\n        }\n      }\n    }\n    else {\n      iVar4 = re_match((re_pattern_buffer *)&DAT_00103e88,local_68,(int)keyafter - (int)local_68,0,\n                       (re_registers *)0x0);\n      if (iVar4 == -2) {\n        matcher_error();\n      }\n      if (iVar4 == -1) {\n        lVar8 = 1;\n      }\n      else {\n        lVar8 = (long)iVar4;\n      }\n      local_68 = local_68 + lVar8;\n    }\n  }\n  before = local_68;\n  for (DAT_00104408 = keyafter; before < DAT_00104408; DAT_00104408 = DAT_00104408 + -1) {\n    ppuVar7 = __ctype_b_loc();\n    puVar2 = *ppuVar7;\n    bVar3 = to_uchar((int)DAT_00104408[-1]);\n    if ((puVar2[bVar3] & 0x2000) == 0) break;\n  }\n  while (before + before_max_width < DAT_00104408) {\n    if (word_regex == 0) {\n      bVar3 = to_uchar((int)*before);\n      if (word_fastmap[(int)(uint)bVar3] == '\\0') {\n        before = before + 1;\n      }\n      else {\n        while ((before < DAT_00104408 &&\n               (bVar3 = to_uchar((int)*before), word_fastmap[(int)(uint)bVar3] != '\\0'))) {\n          before = before + 1;\n        }\n      }\n    }\n    else {\n      iVar4 = re_match((re_pattern_buffer *)&DAT_00103e88,before,(int)DAT_00104408 - (int)before,0,\n                       (re_registers *)0x0);\n      if (iVar4 == -2) {\n        matcher_error();\n      }\n      if (iVar4 == -1) {\n        lVar8 = 1;\n      }\n      else {\n        lVar8 = (long)iVar4;\n      }\n      before = before + lVar8;\n    }\n  }\n  if (truncation_string == (undefined *)0x0) {\n    before_truncation = 0;\n  }\n  else {\n    for (local_70 = before; pcVar10 < local_70; local_70 = local_70 + -1) {\n      ppuVar7 = __ctype_b_loc();\n      puVar2 = *ppuVar7;\n      bVar3 = to_uchar((int)local_70[-1]);\n      if ((puVar2[bVar3] & 0x2000) == 0) break;\n    }\n    before_truncation = pcVar5 < local_70;\n  }\n  for (; before < pcVar1; before = before + 1) {\n    ppuVar7 = __ctype_b_loc();\n    puVar2 = *ppuVar7;\n    bVar3 = to_uchar((int)*before);\n    if ((puVar2[bVar3] & 0x2000) == 0) break;\n  }\n  lVar8 = (before_max_width - ((long)DAT_00104408 - (long)before)) - gap_size;\n  if (lVar8 < 1) {\n    tail = (char *)0x0;\n    DAT_001043e8 = (char *)0x0;\n    tail_truncation = 0;\n  }\n  else {\n    for (tail = DAT_00104428; tail < pcVar1; tail = tail + 1) {\n      ppuVar7 = __ctype_b_loc();\n      puVar2 = *ppuVar7;\n      bVar3 = to_uchar((int)*tail);\n      if ((puVar2[bVar3] & 0x2000) == 0) break;\n    }\n    DAT_001043e8 = tail;\n    local_70 = tail;\n    while ((local_70 < pcVar6 && (local_70 < tail + lVar8))) {\n      DAT_001043e8 = local_70;\n      if (word_regex == 0) {\n        bVar3 = to_uchar((int)*local_70);\n        if (word_fastmap[(int)(uint)bVar3] == '\\0') {\n          local_70 = local_70 + 1;\n        }\n        else {\n          while ((local_70 < pcVar6 &&\n                 (bVar3 = to_uchar((int)*local_70), word_fastmap[(int)(uint)bVar3] != '\\0'))) {\n            local_70 = local_70 + 1;\n          }\n        }\n      }\n      else {\n        iVar4 = re_match((re_pattern_buffer *)&DAT_00103e88,local_70,(int)pcVar6 - (int)local_70,0,\n                         (re_registers *)0x0);\n        if (iVar4 == -2) {\n          matcher_error();\n        }\n        if (iVar4 == -1) {\n          lVar9 = 1;\n        }\n        else {\n          lVar9 = (long)iVar4;\n        }\n        local_70 = local_70 + lVar9;\n      }\n    }\n    if (local_70 < tail + lVar8) {\n      DAT_001043e8 = local_70;\n    }\n    if (tail < DAT_001043e8) {\n      keyafter_truncation = 0;\n      if ((truncation_string == (undefined *)0x0) || (pcVar6 <= DAT_001043e8)) {\n        tail_truncation = 0;\n      }\n      else {\n        tail_truncation = 1;\n      }\n    }\n    else {\n      tail_truncation = 0;\n    }\n    for (; tail < DAT_001043e8; DAT_001043e8 = DAT_001043e8 + -1) {\n      ppuVar7 = __ctype_b_loc();\n      puVar2 = *ppuVar7;\n      bVar3 = to_uchar((int)DAT_001043e8[-1]);\n      if ((puVar2[bVar3] & 0x2000) == 0) break;\n    }\n  }\n  lVar8 = (keyafter_max_width - ((long)DAT_00104428 - (long)keyafter)) - gap_size;\n  if (lVar8 < 1) {\n    head = (char *)0x0;\n    DAT_00104448 = (char *)0x0;\n    head_truncation = 0;\n  }\n  else {\n    for (DAT_00104448 = before; pcVar10 < DAT_00104448; DAT_00104448 = DAT_00104448 + -1) {\n      ppuVar7 = __ctype_b_loc();\n      puVar2 = *ppuVar7;\n      bVar3 = to_uchar((int)DAT_00104448[-1]);\n      if ((puVar2[bVar3] & 0x2000) == 0) break;\n    }\n    head = local_68;\n    while (head + lVar8 < DAT_00104448) {\n      if (word_regex == 0) {\n        bVar3 = to_uchar((int)*head);\n        if (word_fastmap[(int)(uint)bVar3] == '\\0') {\n          head = head + 1;\n        }\n        else {\n          while ((head < DAT_00104448 &&\n                 (bVar3 = to_uchar((int)*head), word_fastmap[(int)(uint)bVar3] != '\\0'))) {\n            head = head + 1;\n          }\n        }\n      }\n      else {\n        iVar4 = re_match((re_pattern_buffer *)&DAT_00103e88,head,(int)DAT_00104448 - (int)head,0,\n                         (re_registers *)0x0);\n        if (iVar4 == -2) {\n          matcher_error();\n        }\n        if (iVar4 == -1) {\n          lVar9 = 1;\n        }\n        else {\n          lVar9 = (long)iVar4;\n        }\n        head = head + lVar9;\n      }\n    }\n    if (head < DAT_00104448) {\n      before_truncation = 0;\n      if ((truncation_string == (undefined *)0x0) || (head <= pcVar5)) {\n        head_truncation = 0;\n      }\n      else {\n        head_truncation = 1;\n      }\n    }\n    else {\n      head_truncation = 0;\n    }\n    for (; head < DAT_00104448; head = head + 1) {\n      ppuVar7 = __ctype_b_loc();\n      puVar2 = *ppuVar7;\n      bVar3 = to_uchar((int)*head);\n      if ((puVar2[bVar3] & 0x2000) == 0) break;\n    }\n  }\n  if (auto_reference == '\\0') {\n    if (input_reference != '\\0') {\n      reference = param_1[4] + (long)keyafter;\n      for (DAT_00104468 = reference; DAT_00104468 < pcVar6; DAT_00104468 = DAT_00104468 + 1) {\n        ppuVar7 = __ctype_b_loc();\n        puVar2 = *ppuVar7;\n        bVar3 = to_uchar((int)*DAT_00104468);\n        if ((puVar2[bVar3] & 0x2000) != 0) {\n          return;\n        }\n      }\n    }\n  }\n  else {\n    local_60 = *(char **)((long)*(int *)(param_1 + 5) * 8 + input_file_name);\n    if (local_60 == (char *)0x0) {\n      local_60 = \"\";\n    }\n    local_58 = param_1[4] + 1;\n    if (0 < *(int *)(param_1 + 5)) {\n      local_58 = local_58 + -*(long *)((long)*(int *)(param_1 + 5) * 8 + -8 + file_line_count);\n    }\n    pcVar10 = stpcpy(reference,local_60);\n    iVar4 = sprintf(pcVar10,\":%jd\",local_58);\n    DAT_00104468 = pcVar10 + iVar4;\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "define_all_fields",
                        "to_uchar",
                        "re_match",
                        "matcher_error",
                        "__ctype_b_loc",
                        "stpcpy",
                        "sprintf"
                    ],
                    "calling_functions": [
                        "define_all_fields",
                        "generate_all_output"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "output_one_roff_line",
                "func_c_signature": "void output_one_roff_line(void)",
                "decompiled_code": "void output_one_roff_line(void) {\n  printf(\".%s \\\"\",macro_name);\n  print_field(tail,DAT_001043e8);\n  if (tail_truncation != '\\0') {\n    fputs_unlocked(truncation_string,_stdout);\n  }\n  putchar_unlocked(0x22);\n  fwrite_unlocked(&DAT_00104824,1,2,_stdout);\n  if (before_truncation != '\\0') {\n    fputs_unlocked(truncation_string,_stdout);\n  }\n  print_field(before,DAT_00104408);\n  putchar_unlocked(0x22);\n  fwrite_unlocked(&DAT_00104824,1,2,_stdout);\n  print_field(keyafter,DAT_00104428);\n  if (keyafter_truncation != '\\0') {\n    fputs_unlocked(truncation_string,_stdout);\n  }\n  putchar_unlocked(0x22);\n  fwrite_unlocked(&DAT_00104824,1,2,_stdout);\n  if (head_truncation != '\\0') {\n    fputs_unlocked(truncation_string,_stdout);\n  }\n  print_field(head,DAT_00104448);\n  putchar_unlocked(0x22);\n  if ((auto_reference != '\\0') || (input_reference != '\\0')) {\n    fwrite_unlocked(&DAT_00104824,1,2,_stdout);\n    print_field(reference,DAT_00104468);\n    putchar_unlocked(0x22);\n  }\n  putchar_unlocked(10);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "output_one_roff_line",
                        "printf",
                        "print_field",
                        "fputs_unlocked",
                        "putchar_unlocked",
                        "fwrite_unlocked"
                    ],
                    "calling_functions": [
                        "output_one_roff_line",
                        "generate_all_output"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "output_one_tex_line",
                "func_c_signature": "void output_one_tex_line(void)",
                "decompiled_code": "void output_one_tex_line(void) {\n  char *pcVar1;\n  char *pcVar2;\n  byte bVar3;\n  int iVar4;\n  long lVar5;\n  char *local_30;\n  \n  printf(\"\\\\%s \",macro_name);\n  putchar_unlocked(0x7b);\n  print_field(tail,DAT_001043e8);\n  fwrite_unlocked(&DAT_0010482c,1,2,_stdout);\n  print_field(before,DAT_00104408);\n  fwrite_unlocked(&DAT_0010482c,1,2,_stdout);\n  pcVar2 = DAT_00104428;\n  pcVar1 = keyafter;\n  local_30 = keyafter;\n  if (word_regex == 0) {\n    bVar3 = to_uchar((int)*keyafter);\n    if (word_fastmap[(int)(uint)bVar3] == '\\0') {\n      local_30 = pcVar1 + 1;\n    }\n    else {\n      while ((local_30 < DAT_00104428 &&\n             (bVar3 = to_uchar((int)*local_30), word_fastmap[(int)(uint)bVar3] != '\\0'))) {\n        local_30 = local_30 + 1;\n      }\n    }\n  }\n  else {\n    iVar4 = re_match((re_pattern_buffer *)&DAT_00103e88,keyafter,(int)DAT_00104428 - (int)keyafter,0\n                     ,(re_registers *)0x0);\n    if (iVar4 == -2) {\n      matcher_error();\n    }\n    if (iVar4 == -1) {\n      lVar5 = 1;\n    }\n    else {\n      lVar5 = (long)iVar4;\n    }\n    local_30 = pcVar1 + lVar5;\n  }\n  print_field(pcVar1,local_30);\n  fwrite_unlocked(&DAT_0010482c,1,2,_stdout);\n  print_field(local_30,pcVar2);\n  fwrite_unlocked(&DAT_0010482c,1,2,_stdout);\n  print_field(head,DAT_00104448);\n  putchar_unlocked(0x7d);\n  if ((auto_reference != '\\0') || (input_reference != '\\0')) {\n    putchar_unlocked(0x7b);\n    print_field(reference,DAT_00104468);\n    putchar_unlocked(0x7d);\n  }\n  putchar_unlocked(10);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "output_one_tex_line",
                        "printf",
                        "putchar_unlocked",
                        "print_field",
                        "fwrite_unlocked",
                        "to_uchar",
                        "re_match",
                        "matcher_error"
                    ],
                    "calling_functions": [
                        "output_one_tex_line",
                        "generate_all_output"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "output_one_dumb_line",
                "func_c_signature": "void output_one_dumb_line(void)",
                "decompiled_code": "void output_one_dumb_line(void) {\n  long lVar1;\n  long lVar2;\n  \n  if (right_reference != '\\x01') {\n    if (auto_reference == '\\0') {\n      print_field(reference,DAT_00104468);\n      print_spaces((reference_max_width + gap_size) - (DAT_00104468 - reference));\n    }\n    else {\n      print_field(reference,DAT_00104468);\n      putchar_unlocked(0x3a);\n      print_spaces(((reference_max_width + gap_size) - (DAT_00104468 - reference)) + -1);\n    }\n  }\n  if (tail < DAT_001043e8) {\n    print_field(tail,DAT_001043e8);\n    if (tail_truncation != '\\0') {\n      fputs_unlocked(truncation_string,_stdout);\n    }\n    lVar2 = truncation_string_length;\n    if (before_truncation == '\\0') {\n      lVar2 = 0;\n    }\n    lVar1 = truncation_string_length;\n    if (tail_truncation == '\\0') {\n      lVar1 = 0;\n    }\n    print_spaces(((((half_line_width - gap_size) - (DAT_00104408 - before)) - lVar2) -\n                 (DAT_001043e8 - tail)) - lVar1);\n  }\n  else {\n    lVar2 = truncation_string_length;\n    if (before_truncation == '\\0') {\n      lVar2 = 0;\n    }\n    print_spaces(((half_line_width - gap_size) - (DAT_00104408 - before)) - lVar2);\n  }\n  if (before_truncation != '\\0') {\n    fputs_unlocked(truncation_string,_stdout);\n  }\n  print_field(before,DAT_00104408);\n  print_spaces(gap_size);\n  print_field(keyafter,DAT_00104428);\n  if (keyafter_truncation != '\\0') {\n    fputs_unlocked(truncation_string,_stdout);\n  }\n  if (head < DAT_00104448) {\n    lVar2 = truncation_string_length;\n    if (keyafter_truncation == '\\0') {\n      lVar2 = 0;\n    }\n    lVar1 = truncation_string_length;\n    if (head_truncation == '\\0') {\n      lVar1 = 0;\n    }\n    print_spaces((((half_line_width - (DAT_00104428 - keyafter)) - lVar2) - (DAT_00104448 - head)) -\n                 lVar1);\n    if (head_truncation != '\\0') {\n      fputs_unlocked(truncation_string,_stdout);\n    }\n    print_field(head,DAT_00104448);\n  }\n  else if (((auto_reference != '\\0') || (input_reference != '\\0')) && (right_reference != '\\0')) {\n    lVar2 = truncation_string_length;\n    if (keyafter_truncation == '\\0') {\n      lVar2 = 0;\n    }\n    print_spaces((half_line_width - (DAT_00104428 - keyafter)) - lVar2);\n  }\n  if (((auto_reference != '\\0') || (input_reference != '\\0')) && (right_reference != '\\0')) {\n    print_spaces(gap_size);\n    print_field(reference,DAT_00104468);\n  }\n  putchar_unlocked(10);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "output_one_dumb_line",
                        "print_field",
                        "print_spaces",
                        "putchar_unlocked",
                        "fputs_unlocked"
                    ],
                    "calling_functions": [
                        "output_one_dumb_line",
                        "generate_all_output"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "generate_all_output",
                "func_c_signature": "void generate_all_output(void)",
                "decompiled_code": "void generate_all_output(void) {\n  long local_18;\n  long local_10;\n  \n  tail = 0;\n  DAT_001043e8 = 0;\n  tail_truncation = 0;\n  head = 0;\n  DAT_00104448 = 0;\n  head_truncation = 0;\n  local_18 = occurs_table;\n  for (local_10 = 0; local_10 < number_of_occurs; local_10 = local_10 + 1) {\n    define_all_fields(local_18);\n    if (output_format == 3) {\n      output_one_tex_line();\n    }\n    else if (output_format < 4) {\n      if (output_format < 2) {\n        output_one_dumb_line();\n      }\n      else if (output_format == 2) {\n        output_one_roff_line();\n      }\n    }\n    local_18 = local_18 + 0x30;\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "generate_all_output",
                        "define_all_fields",
                        "output_one_tex_line",
                        "output_one_dumb_line",
                        "output_one_roff_line"
                    ],
                    "calling_functions": [
                        "generate_all_output",
                        "main"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\n                            \"Usage: %s [OPTION]... [INPUT]...   (without -G)\\n  or:  %s -G [OPTION]... [INPUT [OUTPUT]]\\n\"\n                            );\n    printf(pcVar3,uVar2,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"Output a permuted index, including context, of the words in the input files.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_stdin_note();\n    emit_mandatory_arg_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -A, --auto-reference           output automatically generated references\\n  -G, --traditional              behave more like System V \\'ptx\\'\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -F, --flag-truncation=STRING   use STRING for flagging line truncations.\\n                                 The default is \\'/\\'\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -M, --macro-name=STRING        macro name to use instead of \\'xx\\'\\n  -O, --format=roff              generate output as roff directives\\n  -R, --right-side-refs          put references at right, not counted in -w\\n  -S, --sentence-regexp=REGEXP   for end of lines or end of sentences\\n  -T, --format=tex               generate output as TeX directives\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -W, --word-regexp=REGEXP       use REGEXP to match each keyword\\n  -b, --break-file=FILE          word break characters in this FILE\\n  -f, --ignore-case              fold lower case to upper case for sorting\\n  -g, --gap-size=NUMBER          gap size in columns between output fields\\n  -i, --ignore-file=FILE         read ignore word list from FILE\\n  -o, --only-file=FILE           read only word list from this FILE\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -r, --references               first field of each line is a reference\\n  -t, --typeset-mode               - not implemented -\\n  -w, --width=NUMBER             output width in columns, reference excluded\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_ancillary_info(&DAT_00104e59);\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "fputs_unlocked",
                        "emit_stdin_note",
                        "emit_mandatory_arg_note",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "undefined8 main(int param_1,undefined8 *param_2)",
                "decompiled_code": "undefined8 main(int param_1,undefined8 *param_2) {\n  char cVar1;\n  int iVar2;\n  long lVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  int local_78;\n  long local_50;\n  long local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined *local_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit((__func *)&close_stdout);\n  do {\n    while( true ) {\n      iVar2 = getopt_long(param_1,param_2,\"AF:GM:ORS:TW:b:i:fg:o:trw:\",long_options,0);\n      if (iVar2 == -1) {\n        if (param_1 == _optind) {\n          input_file_name = (undefined8 *)xmalloc(8);\n          file_line_count = xmalloc(8);\n          text_buffers = xmalloc(0x10);\n          number_input_files = 1;\n          *input_file_name = 0;\n        }\n        else if (gnu_extensions == '\\0') {\n          number_input_files = 1;\n          input_file_name = (undefined8 *)xmalloc(8);\n          file_line_count = xmalloc(8);\n          text_buffers = xmalloc(0x10);\n          if ((*(char *)param_2[_optind] == '\\0') ||\n             (cVar1 = streq(param_2[_optind],&DAT_001047ba), cVar1 != '\\0')) {\n            *input_file_name = 0;\n          }\n          else {\n            *input_file_name = param_2[_optind];\n          }\n          _optind = _optind + 1;\n          if (_optind < param_1) {\n            lVar3 = freopen_safer(param_2[_optind],&DAT_00104fca,_stdout);\n            if (lVar3 == 0) {\n              uVar4 = quotearg_n_style_colon(0,3,param_2[_optind]);\n              piVar5 = __errno_location();\n              local_30 = &DAT_001047bc;\n              error(1,*piVar5,&DAT_001047bc,uVar4);\n            }\n            _optind = _optind + 1;\n          }\n          if (_optind < param_1) {\n            uVar4 = quote(param_2[_optind]);\n            local_28 = gettext(\"extra operand %s\");\n            error(0,0,local_28,uVar4);\n            usage(1);\n          }\n        }\n        else {\n          number_input_files = param_1 - _optind;\n          input_file_name = (undefined8 *)xnmalloc((long)number_input_files,8);\n          file_line_count = xnmalloc((long)number_input_files,8);\n          text_buffers = xnmalloc((long)number_input_files,0x10);\n          for (local_78 = 0; local_78 < number_input_files; local_78 = local_78 + 1) {\n            if ((*(char *)param_2[_optind] == '\\0') ||\n               (cVar1 = streq(param_2[_optind],&DAT_001047ba), cVar1 != '\\0')) {\n              input_file_name[local_78] = 0;\n            }\n            else {\n              input_file_name[local_78] = param_2[_optind];\n            }\n            _optind = _optind + 1;\n          }\n        }\n        if (output_format == 0) {\n          if (gnu_extensions == '\\0') {\n            output_format = 2;\n          }\n          else {\n            output_format = 1;\n          }\n        }\n        initialize_regex();\n        if (break_file != (char *)0x0) {\n          digest_break_file(break_file);\n        }\n        if ((ignore_file != (char *)0x0) &&\n           (digest_word_file(ignore_file,ignore_table), ignore_table._16_8_ == 0)) {\n          ignore_file = (char *)0x0;\n        }\n        if ((only_file != (char *)0x0) &&\n           (digest_word_file(only_file,only_table), only_table._16_8_ == 0)) {\n          only_file = (char *)0x0;\n        }\n        number_of_occurs = 0;\n        total_line_count = 0;\n        maximum_word_length = 0;\n        reference_max_width = 0;\n        for (local_78 = 0; local_78 < number_input_files; local_78 = local_78 + 1) {\n          local_48 = text_buffers + (long)local_78 * 0x10;\n          swallow_file_in_memory(input_file_name[local_78],local_48);\n          find_occurs_in_text(local_78);\n          total_line_count = total_line_count + 1;\n          *(long *)((long)local_78 * 8 + file_line_count) = total_line_count;\n        }\n        sort_found_occurs();\n        fix_output_parameters();\n        generate_all_output();\n        if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n          __stack_chk_fail();\n        }\n        return 0;\n      }\n      if (iVar2 < 0x78) break;\nswitchD_00103420_caseD_b:\n      usage(1);\nswitchD_00103420_caseD_47:\n      gnu_extensions = '\\0';\n    }\n    if (iVar2 < 10) {\n      if (iVar2 == -0x83) {\nLAB_001036e0:\n        uVar4 = proper_name_lite(\"F. Pinard\",&DAT_00104f86);\n        version_etc(_stdout,&DAT_00104e59,\"GNU coreutils\",_Version,uVar4,0);\n                    /* WARNING: Subroutine does not return */\n        exit(0);\n      }\n      if (iVar2 == -0x82) {\n        usage(0);\n        goto LAB_001036e0;\n      }\n      goto switchD_00103420_caseD_b;\n    }\n    switch(iVar2) {\n    case 10:\n      lVar3 = __xargmatch_internal(\"--format\",_optarg,format_args,&format_vals,4,_argmatch_die,1);\n      output_format = *(int *)((long)&format_vals + lVar3 * 4);\n      break;\n    default:\n      goto switchD_00103420_caseD_b;\n    case 0x41:\n      auto_reference = 1;\n      break;\n    case 0x46:\n      truncation_string = _optarg;\n      unescape_string(_optarg);\n      break;\n    case 0x47:\n      goto switchD_00103420_caseD_47;\n    case 0x4d:\n      macro_name = _optarg;\n      break;\n    case 0x4f:\n      output_format = 2;\n      break;\n    case 0x52:\n      right_reference = 1;\n      break;\n    case 0x53:\n      context_regex = _optarg;\n      unescape_string(_optarg);\n      break;\n    case 0x54:\n      output_format = 3;\n      break;\n    case 0x57:\n      word_regex = _optarg;\n      unescape_string(_optarg);\n      if (*word_regex == '\\0') {\n        word_regex = (char *)0x0;\n      }\n      break;\n    case 0x62:\n      break_file = _optarg;\n      break;\n    case 0x66:\n      ignore_case = 1;\n      break;\n    case 0x67:\n      iVar2 = xstrtoimax(_optarg,0,0,&local_50,&DAT_001045fc);\n      if ((iVar2 != 0) || (local_50 < 1)) {\n        uVar4 = quote(_optarg);\n        local_40 = gettext(\"invalid gap width: %s\");\n        error(1,0,local_40,uVar4);\n      }\n      gap_size = local_50;\n      break;\n    case 0x69:\n      ignore_file = _optarg;\n      break;\n    case 0x6f:\n      only_file = _optarg;\n      break;\n    case 0x72:\n      input_reference = 1;\n      break;\n    case 0x74:\n      break;\n    case 0x77:\n      iVar2 = xstrtoimax(_optarg,0,0,&local_50,&DAT_001045fc);\n      if ((iVar2 != 0) || (local_50 < 1)) {\n        uVar4 = quote(_optarg);\n        local_38 = gettext(\"invalid line width: %s\");\n        error(1,0,local_38,uVar4);\n      }\n      line_width = local_50;\n    }\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "getopt_long",
                        "xmalloc",
                        "streq",
                        "freopen_safer",
                        "quotearg_n_style_colon",
                        "__errno_location",
                        "error",
                        "quote",
                        "gettext",
                        "usage",
                        "xnmalloc",
                        "initialize_regex",
                        "digest_break_file",
                        "digest_word_file",
                        "swallow_file_in_memory",
                        "find_occurs_in_text",
                        "sort_found_occurs",
                        "fix_output_parameters",
                        "generate_all_output",
                        "__stack_chk_fail",
                        "proper_name_lite",
                        "version_etc",
                        "exit",
                        "__xargmatch_internal",
                        "unescape_string",
                        "xstrtoimax"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "ptx_decompiled.c"
                }
            }
        ]
    }
}