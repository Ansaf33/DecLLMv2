{
    "file": "join",
    "decompiled_code": {
        "join.c": [
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\"Usage: %s [OPTION]... FILE1 FILE2\\n\");\n    printf(pcVar3,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"For each pair of input lines with identical join fields, write a line to\\nstandard output.  The default join field is the first, delimited by blanks.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"\\nWhen FILE1 or FILE2 (not both) is -, read standard input.\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\n  -a FILENUM             also print unpairable lines from file FILENUM, where\\n                           FILENUM is 1 or 2, corresponding to FILE1 or FILE2\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -e STRING              replace missing (empty) input fields with STRING;\\n                           I.e., missing fields specified with \\'-12jo\\' options\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -i, --ignore-case      ignore differences in case when comparing fields\\n  -j FIELD               equivalent to \\'-1 FIELD -2 FIELD\\'\\n  -o FORMAT              obey FORMAT while constructing output line\\n  -t CHAR                use CHAR as input and output field separator\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -v FILENUM             like -a FILENUM, but suppress joined output lines\\n  -1 FIELD               join on this FIELD of file 1\\n  -2 FIELD               join on this FIELD of file 2\\n      --check-order      check that the input is correctly sorted, even\\n                           if all input lines are pairable\\n      --nocheck-order    do not check that the input is correctly sorted\\n      --header           treat the first line in each file as field headers,\\n                           print them without trying to pair them\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"  -z, --zero-terminated  line delimiter is NUL, not newline\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nUnless -t CHAR is given, leading blanks separate fields and are ignored,\\nelse fields are separated by CHAR.  Any FIELD is a field number counted\\nfrom 1.  FORMAT is one or more comma or blank separated specifications,\\neach being \\'FILENUM.FIELD\\' or \\'0\\'.  Default FORMAT outputs the join field,\\nthe remaining fields from FILE1, the remaining fields from FILE2, all\\nseparated by CHAR.  If FORMAT is the keyword \\'auto\\', then the first\\nline of each file determines the number of fields output for each line.\\n\\nImportant: FILE1 and FILE2 must be sorted on the join fields.\\nE.g., use \\\"sort -k 1b,1\\\" if \\'join\\' has no options,\\nor use \\\"join -t \\'\\'\\\" if \\'sort\\' has no options.\\nComparisons honor the rules specified by \\'LC_COLLATE\\'.\\nIf the input is not sorted and some lines cannot be joined, a\\nwarning message will be given.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_ancillary_info(&DAT_00103884);\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "FILE2",
                    "missing"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "fputs_unlocked",
                        "FILE2",
                        "missing",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "add_file_name",
                        "main"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "extract_field",
                "func_c_signature": "void extract_field(long param_1,undefined8 param_2,undefined8 param_3)",
                "decompiled_code": "void extract_field(long param_1,undefined8 param_2,undefined8 param_3) {\n  undefined8 uVar1;\n  \n  if (*(long *)(param_1 + 0x20) <= *(long *)(param_1 + 0x18)) {\n    uVar1 = xpalloc(*(undefined8 *)(param_1 + 0x28),param_1 + 0x20,1,0xffffffffffffffff,0x10);\n    *(undefined8 *)(param_1 + 0x28) = uVar1;\n  }\n  *(undefined8 *)(*(long *)(param_1 + 0x28) + *(long *)(param_1 + 0x18) * 0x10) = param_2;\n  *(undefined8 *)(*(long *)(param_1 + 0x28) + *(long *)(param_1 + 0x18) * 0x10 + 8) = param_3;\n  *(long *)(param_1 + 0x18) = *(long *)(param_1 + 0x18) + 1;\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "extract_field",
                        "xpalloc"
                    ],
                    "calling_functions": [
                        "extract_field",
                        "xfields"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "eq_tab",
                "func_c_signature": "bool eq_tab(undefined8 param_1)",
                "decompiled_code": "bool eq_tab(undefined8 param_1) {\n  int iVar1;\n  \n  iVar1 = mcel_cmp(param_1,tab);\n  return iVar1 == 0;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "eq_tab",
                        "mcel_cmp"
                    ],
                    "calling_functions": [
                        "eq_tab"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "newline_or_blank",
                "func_c_signature": "undefined4 newline_or_blank(int param_1)",
                "decompiled_code": "undefined4 newline_or_blank(int param_1) {\n  int iVar1;\n  \n  if ((param_1 != 10) && (iVar1 = c32isblank(param_1), iVar1 == 0)) {\n    return 0;\n  }\n  return 1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "newline_or_blank",
                        "c32isblank"
                    ],
                    "calling_functions": [
                        "newline_or_blank"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "xfields",
                "func_c_signature": "void xfields(long param_1)",
                "decompiled_code": "void xfields(long param_1) {\n  ulong uVar1;\n  ulong uVar2;\n  ulong uVar3;\n  ulong local_28;\n  \n  local_28 = *(ulong *)(param_1 + 0x10);\n  uVar1 = local_28 + *(long *)(param_1 + 8) + -1;\n  if (local_28 != uVar1) {\n    if (tab._5_1_ == '\\0') {\n      while (uVar2 = skip_buf_matching(local_28,uVar1,newline_or_blank,1), uVar2 < uVar1) {\n        local_28 = skip_buf_matching(uVar2,uVar1,newline_or_blank,0);\n        extract_field(param_1,uVar2,local_28 - uVar2);\n      }\n    }\n    else {\n      if ((int)tab != 10) {\n        while (uVar2 = skip_buf_matching(local_28,uVar1,eq_tab,0), uVar2 < uVar1) {\n          extract_field(param_1,local_28,uVar2 - local_28);\n          uVar3 = mcel_scan(uVar2,uVar1);\n          local_28 = uVar2 + (uVar3 >> 0x28 & 0xff);\n        }\n      }\n      extract_field(param_1,local_28,uVar1 - local_28);\n    }\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "xfields",
                        "skip_buf_matching",
                        "extract_field",
                        "mcel_scan"
                    ],
                    "calling_functions": [
                        "xfields",
                        "get_line"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "freeline",
                "func_c_signature": "void freeline(long param_1)",
                "decompiled_code": "void freeline(long param_1) {\n  if (param_1 != 0) {\n    free(*(void **)(param_1 + 0x28));\n    *(undefined8 *)(param_1 + 0x28) = 0;\n    free(*(void **)(param_1 + 0x10));\n    *(undefined8 *)(param_1 + 0x10) = 0;\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "freeline",
                        "free"
                    ],
                    "calling_functions": [
                        "freeline",
                        "get_line",
                        "free_spareline",
                        "delseq",
                        "system_join"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "keycmp",
                "func_c_signature": "ulong keycmp(long param_1,long param_2,long param_3,long param_4)",
                "decompiled_code": "ulong keycmp(long param_1,long param_2,long param_3,long param_4) {\n  ulong uVar1;\n  size_t sVar2;\n  uint local_2c;\n  void *local_28;\n  void *local_20;\n  size_t local_18;\n  size_t local_10;\n  \n  if (param_3 < *(long *)(param_1 + 0x18)) {\n    local_28 = *(void **)(*(long *)(param_1 + 0x28) + param_3 * 0x10);\n    local_18 = *(size_t *)(*(long *)(param_1 + 0x28) + param_3 * 0x10 + 8);\n  }\n  else {\n    local_28 = (void *)0x0;\n    local_18 = 0;\n  }\n  if (param_4 < *(long *)(param_2 + 0x18)) {\n    local_20 = *(void **)(*(long *)(param_2 + 0x28) + param_4 * 0x10);\n    local_10 = *(size_t *)(*(long *)(param_2 + 0x28) + param_4 * 0x10 + 8);\n  }\n  else {\n    local_20 = (void *)0x0;\n    local_10 = 0;\n  }\n  if (local_18 == 0) {\n    if (local_10 == 0) {\n      uVar1 = 0;\n    }\n    else {\n      uVar1 = 0xffffffff;\n    }\n  }\n  else if (local_10 == 0) {\n    uVar1 = 1;\n  }\n  else {\n    if (ignore_case == '\\0') {\n      if (hard_LC_COLLATE != '\\0') {\n        uVar1 = xmemcoll(local_28,local_18,local_20,local_10);\n        return uVar1;\n      }\n      sVar2 = local_18;\n      if ((long)local_10 <= (long)local_18) {\n        sVar2 = local_10;\n      }\n      local_2c = memcmp(local_28,local_20,sVar2);\n    }\n    else {\n      sVar2 = local_18;\n      if ((long)local_10 <= (long)local_18) {\n        sVar2 = local_10;\n      }\n      local_2c = memcasecmp(local_28,local_20,sVar2);\n    }\n    if (local_2c == 0) {\n      uVar1 = (ulong)((uint)((long)local_10 < (long)local_18) -\n                     (uint)((long)local_18 < (long)local_10));\n    }\n    else {\n      uVar1 = (ulong)local_2c;\n    }\n  }\n  return uVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "keycmp",
                        "xmemcoll",
                        "memcmp",
                        "memcasecmp"
                    ],
                    "calling_functions": [
                        "keycmp",
                        "check_order",
                        "system_join"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "check_order",
                "func_c_signature": "void check_order(undefined8 param_1,long param_2,int param_3)",
                "decompiled_code": "void check_order(undefined8 param_1,long param_2,int param_3) {\n  undefined8 uVar1;\n  undefined8 uVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  bool bVar6;\n  ulong local_40;\n  \n  if ((check_input_order != 2) &&\n     (((check_input_order == 1 || (seen_unpairable != '\\0')) &&\n      ((&issued_disorder_warning)[param_3 + -1] != '\\x01')))) {\n    uVar4 = join_field_2;\n    if (param_3 == 1) {\n      uVar4 = join_field_1;\n    }\n    iVar3 = keycmp(param_1,param_2,uVar4,uVar4);\n    if (0 < iVar3) {\n      local_40 = *(ulong *)(param_2 + 8);\n      if ((0 < (long)local_40) && (*(char *)(*(long *)(param_2 + 0x10) + (local_40 - 1)) == '\\n')) {\n        local_40 = local_40 - 1;\n      }\n      if (0x7fffffff < (long)local_40) {\n        local_40 = 0x7fffffff;\n      }\n      bVar6 = check_input_order == 1;\n      uVar4 = *(undefined8 *)(param_2 + 0x10);\n      uVar1 = *(undefined8 *)(line_no + (long)(param_3 + -1) * 8);\n      uVar2 = (&g_names)[param_3 + -1];\n      uVar5 = gettext(\"%s:%ju: is not sorted: %.*s\");\n      error(bVar6,0,uVar5,uVar2,uVar1,local_40 & 0xffffffff,uVar4);\n      (&issued_disorder_warning)[param_3 + -1] = 1;\n    }\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "check_order",
                        "keycmp",
                        "gettext",
                        "error"
                    ],
                    "calling_functions": [
                        "check_order",
                        "get_line"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "reset_line",
                "func_c_signature": "void reset_line(long param_1)",
                "decompiled_code": "void reset_line(long param_1) {\n  *(undefined8 *)(param_1 + 0x18) = 0;\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "reset_line"
                    ],
                    "calling_functions": [
                        "reset_line",
                        "get_line"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "init_linep",
                "func_c_signature": "undefined8 init_linep(undefined8 *param_1)",
                "decompiled_code": "undefined8 init_linep(undefined8 *param_1) {\n  undefined8 uVar1;\n  \n  uVar1 = xzalloc(0x30);\n  *param_1 = uVar1;\n  return uVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "init_linep",
                        "xzalloc"
                    ],
                    "calling_functions": [
                        "init_linep",
                        "get_line"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "get_line",
                "func_c_signature": "undefined8 get_line(FILE *param_1,long *param_2,int param_3)",
                "decompiled_code": "undefined8 get_line(FILE *param_1,long *param_2,int param_3) {\n  int iVar1;\n  long lVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  long local_30;\n  \n  lVar2 = *param_2;\n  local_30 = lVar2;\n  if (lVar2 == *(long *)(prevline + (long)(param_3 + -1) * 8)) {\n    local_30 = *(long *)(spareline + (long)(param_3 + -1) * 8);\n    *(long *)(spareline + (long)(param_3 + -1) * 8) = lVar2;\n    *param_2 = local_30;\n  }\n  if (local_30 == 0) {\n    local_30 = init_linep(param_2);\n  }\n  else {\n    reset_line(local_30);\n  }\n  lVar2 = readlinebuffer_delim(local_30,param_1,(int)eolchar);\n  if (lVar2 == 0) {\n    iVar1 = ferror_unlocked(param_1);\n    if (iVar1 != 0) {\n      uVar3 = gettext(\"read error\");\n      piVar4 = __errno_location();\n      error(1,*piVar4,uVar3);\n    }\n    freeline(local_30);\n    uVar3 = 0;\n  }\n  else {\n    *(long *)(line_no + (long)(param_3 + -1) * 8) =\n         *(long *)(line_no + (long)(param_3 + -1) * 8) + 1;\n    xfields(local_30);\n    if (*(long *)(prevline + (long)(param_3 + -1) * 8) != 0) {\n      check_order(*(undefined8 *)(prevline + (long)(param_3 + -1) * 8),local_30,param_3);\n    }\n    *(long *)(prevline + (long)(param_3 + -1) * 8) = local_30;\n    uVar3 = 1;\n  }\n  return uVar3;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "get_line",
                        "init_linep",
                        "reset_line",
                        "readlinebuffer_delim",
                        "ferror_unlocked",
                        "gettext",
                        "__errno_location",
                        "error",
                        "freeline",
                        "xfields",
                        "check_order"
                    ],
                    "calling_functions": [
                        "get_line",
                        "getseq",
                        "system_join"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "free_spareline",
                "func_c_signature": "void free_spareline(void)",
                "decompiled_code": "void free_spareline(void) {\n  ulong local_10;\n  \n  for (local_10 = 0; local_10 < 2; local_10 = local_10 + 1) {\n    if (*(long *)(spareline + local_10 * 8) != 0) {\n      freeline(*(undefined8 *)(spareline + local_10 * 8));\n      free(*(void **)(spareline + local_10 * 8));\n    }\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "free_spareline",
                        "freeline",
                        "free"
                    ],
                    "calling_functions": [
                        "free_spareline"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "initseq",
                "func_c_signature": "void initseq(undefined8 *param_1)",
                "decompiled_code": "void initseq(undefined8 *param_1) {\n  *param_1 = 0;\n  param_1[1] = 0;\n  param_1[2] = 0;\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "initseq"
                    ],
                    "calling_functions": [
                        "initseq",
                        "system_join"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "getseq",
                "func_c_signature": "bool getseq(undefined8 param_1,long *param_2,undefined4 param_3)",
                "decompiled_code": "bool getseq(undefined8 param_1,long *param_2,undefined4 param_3) {\n  char cVar1;\n  long lVar2;\n  long local_10;\n  \n  if (*param_2 == param_2[1]) {\n    lVar2 = xpalloc(param_2[2],param_2 + 1,1,0xffffffffffffffff,8);\n    param_2[2] = lVar2;\n    for (local_10 = *param_2; local_10 < param_2[1]; local_10 = local_10 + 1) {\n      *(undefined8 *)(param_2[2] + local_10 * 8) = 0;\n    }\n  }\n  cVar1 = get_line(param_1,param_2[2] + *param_2 * 8,param_3);\n  if (cVar1 != '\\0') {\n    *param_2 = *param_2 + 1;\n  }\n  return cVar1 != '\\0';\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "getseq",
                        "xpalloc",
                        "get_line"
                    ],
                    "calling_functions": [
                        "getseq",
                        "advance_seq",
                        "system_join"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "advance_seq",
                "func_c_signature": "void advance_seq(undefined8 param_1,undefined8 *param_2,char param_3,undefined4 param_4)",
                "decompiled_code": "void advance_seq(undefined8 param_1,undefined8 *param_2,char param_3,undefined4 param_4) {\n  if (param_3 != '\\0') {\n    *param_2 = 0;\n  }\n  getseq(param_1,param_2,param_4);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "advance_seq",
                        "getseq"
                    ],
                    "calling_functions": [
                        "advance_seq",
                        "system_join"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "delseq",
                "func_c_signature": "void delseq(long param_1)",
                "decompiled_code": "void delseq(long param_1) {\n  long local_10;\n  \n  for (local_10 = 0; local_10 < *(long *)(param_1 + 8); local_10 = local_10 + 1) {\n    freeline(*(undefined8 *)(*(long *)(param_1 + 0x10) + local_10 * 8));\n    free(*(void **)(*(long *)(param_1 + 0x10) + local_10 * 8));\n  }\n  free(*(void **)(param_1 + 0x10));\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "delseq",
                        "freeline",
                        "free"
                    ],
                    "calling_functions": [
                        "delseq",
                        "system_join"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "prfield",
                "func_c_signature": "void prfield(long param_1,long param_2)",
                "decompiled_code": "void prfield(long param_1,long param_2) {\n  size_t __n;\n  \n  if (param_1 < *(long *)(param_2 + 0x18)) {\n    __n = *(size_t *)(*(long *)(param_2 + 0x28) + param_1 * 0x10 + 8);\n    if (__n == 0) {\n      if (empty_filler != (char *)0x0) {\n        fputs_unlocked(empty_filler,_stdout);\n      }\n    }\n    else {\n      fwrite_unlocked(*(void **)(*(long *)(param_2 + 0x28) + param_1 * 0x10),1,__n,_stdout);\n    }\n  }\n  else if (empty_filler != (char *)0x0) {\n    fputs_unlocked(empty_filler,_stdout);\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "prfield",
                        "fputs_unlocked",
                        "fwrite_unlocked"
                    ],
                    "calling_functions": [
                        "prfield",
                        "prfields",
                        "prjoin"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "prfields",
                "func_c_signature": "void prfields(long param_1,long param_2,long param_3)",
                "decompiled_code": "void prfields(long param_1,long param_2,long param_3) {\n  long local_18;\n  \n  if (autoformat == '\\0') {\n    param_3 = *(long *)(param_1 + 0x18);\n  }\n  for (local_18 = 0; (local_18 < param_2 && (local_18 < param_3)); local_18 = local_18 + 1) {\n    fwrite_unlocked(output_separator,1,output_seplen,_stdout);\n    prfield(local_18,param_1);\n  }\n  for (local_18 = param_2 + 1; local_18 < param_3; local_18 = local_18 + 1) {\n    fwrite_unlocked(output_separator,1,output_seplen,_stdout);\n    prfield(local_18,param_1);\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "prfields",
                        "fwrite_unlocked",
                        "prfield"
                    ],
                    "calling_functions": [
                        "prfields",
                        "prjoin"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "prjoin",
                "func_c_signature": "void prjoin(undefined1 *param_1,undefined1 *param_2)",
                "decompiled_code": "void prjoin(undefined1 *param_1,undefined1 *param_2) {\n  int iVar1;\n  undefined8 local_28;\n  undefined1 *local_20;\n  int *local_18;\n  \n  if (outlist_head._16_8_ == 0) {\n    if (param_1 == uni_blank) {\n      local_28 = join_field_2;\n      local_20 = param_2;\n    }\n    else {\n      local_28 = join_field_1;\n      local_20 = param_1;\n    }\n    prfield(local_28,local_20);\n    prfields(param_1,join_field_1,autocount_1);\n    prfields(param_2,join_field_2,autocount_2);\n    putchar_unlocked((int)eolchar);\n  }\n  else {\n    local_18 = (int *)outlist_head._16_8_;\n    while( true ) {\n      if (*local_18 == 0) {\n        if (param_1 == uni_blank) {\n          local_28 = join_field_2;\n          local_20 = param_2;\n        }\n        else {\n          local_28 = join_field_1;\n          local_20 = param_1;\n        }\n      }\n      else {\n        local_20 = param_2;\n        if (*local_18 == 1) {\n          local_20 = param_1;\n        }\n        local_28 = *(undefined8 *)(local_18 + 2);\n      }\n      prfield(local_28,local_20);\n      local_18 = *(int **)(local_18 + 4);\n      if (local_18 == (int *)0x0) break;\n      fwrite_unlocked(output_separator,1,output_seplen,_stdout);\n    }\n    putchar_unlocked((int)eolchar);\n  }\n  iVar1 = ferror_unlocked(_stdout);\n  if (iVar1 != 0) {\n    write_error();\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "prjoin",
                        "prfield",
                        "prfields",
                        "putchar_unlocked",
                        "fwrite_unlocked",
                        "ferror_unlocked",
                        "write_error"
                    ],
                    "calling_functions": [
                        "prjoin",
                        "system_join"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "add_field",
                "func_c_signature": "void add_field(int param_1,long param_2)",
                "decompiled_code": "void add_field(int param_1,long param_2) {\n  int *piVar1;\n  \n  if (((param_1 != 0) && (param_1 != 1)) && (param_1 != 2)) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"file == 0 || file == 1 || file == 2\",\n                  \"/workspace/home/aiclub1/B220032CS_Jaefar/fyp/repos/ansaf/coreutils/src/join.c\",\n                  0x339,\"add_field\");\n  }\n  if ((param_1 == 0) && (param_2 != 0)) {\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"file != 0 || field == 0\",\n                  \"/workspace/home/aiclub1/B220032CS_Jaefar/fyp/repos/ansaf/coreutils/src/join.c\",\n                  0x33a,\"add_field\");\n  }\n  piVar1 = (int *)xmalloc(0x18);\n  *piVar1 = param_1;\n  *(long *)(piVar1 + 2) = param_2;\n  *(undefined8 *)(piVar1 + 4) = 0;\n  *(int **)(outlist_end + 0x10) = piVar1;\n  outlist_end = (undefined *)piVar1;\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "add_field",
                        "__assert_fail",
                        "xmalloc"
                    ],
                    "calling_functions": [
                        "add_field",
                        "add_field_list"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "string_to_join_field",
                "func_c_signature": "long string_to_join_field(undefined8 param_1)",
                "decompiled_code": "long string_to_join_field(undefined8 param_1) {\n  int iVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  long local_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = xstrtoimax(param_1,0,10,&local_30,&DAT_00102e84);\n  if (iVar1 == 1) {\n    local_30 = 0x7fffffffffffffff;\n  }\n  else if ((iVar1 != 0) || (local_30 < 1)) {\n    uVar2 = quote(param_1);\n    local_28 = gettext(\"invalid field number: %s\");\n    error(1,0,local_28,uVar2);\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_30 + -1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "string_to_join_field",
                        "xstrtoimax",
                        "quote",
                        "gettext",
                        "error",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "string_to_join_field",
                        "decode_field_spec",
                        "add_file_name",
                        "main"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "decode_field_spec",
                "func_c_signature": "void decode_field_spec(char *param_1,int *param_2,undefined8 *param_3)",
                "decompiled_code": "void decode_field_spec(char *param_1,int *param_2,undefined8 *param_3) {\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  iVar1 = (int)*param_1;\n  if (iVar1 == 0x30) {\n    if (param_1[1] != '\\0') {\n      uVar2 = quote(param_1);\n      uVar3 = gettext(\"invalid field specifier: %s\");\n      error(1,0,uVar3,uVar2);\n    }\n    *param_2 = 0;\n    *param_3 = 0;\n  }\n  else if ((iVar1 < 0x30) || (1 < iVar1 - 0x31U)) {\n    uVar2 = quote(param_1);\n    uVar3 = gettext(\"invalid file number in field spec: %s\");\n    error(1,0,uVar3,uVar2);\n  }\n  else {\n    if (param_1[1] != '.') {\n      uVar2 = quote(param_1);\n      uVar3 = gettext(\"invalid field specifier: %s\");\n      error(1,0,uVar3,uVar2);\n    }\n    *param_2 = *param_1 + -0x30;\n    uVar2 = string_to_join_field(param_1 + 2);\n    *param_3 = uVar2;\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "decode_field_spec",
                        "quote",
                        "gettext",
                        "error",
                        "string_to_join_field"
                    ],
                    "calling_functions": [
                        "decode_field_spec",
                        "add_field_list"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "comma_or_blank",
                "func_c_signature": "undefined4 comma_or_blank(int param_1)",
                "decompiled_code": "undefined4 comma_or_blank(int param_1) {\n  int iVar1;\n  \n  if ((param_1 != 0x2c) && (iVar1 = c32isblank(param_1), iVar1 == 0)) {\n    return 0;\n  }\n  return 1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "comma_or_blank",
                        "c32isblank"
                    ],
                    "calling_functions": [
                        "comma_or_blank"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "add_field_list",
                "func_c_signature": "void add_field_list(char *param_1)",
                "decompiled_code": "void add_field_list(char *param_1) {\n  long in_FS_OFFSET;\n  undefined4 local_2c;\n  char *local_28;\n  char *local_20;\n  ulong local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_28 = param_1;\n  do {\n    local_20 = local_28;\n    local_28 = (char *)skip_str_matching(local_28,comma_or_blank,0);\n    if (*local_28 != '\\0') {\n      local_18 = mcel_scanz(local_28);\n      *local_28 = '\\0';\n      local_28 = local_28 + (local_18 >> 0x28 & 0xff);\n    }\n    decode_field_spec(local_20,&local_2c,&local_18);\n    add_field(local_2c,local_18);\n  } while (*local_28 != '\\0');\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "add_field_list",
                        "skip_str_matching",
                        "mcel_scanz",
                        "decode_field_spec",
                        "add_field",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "add_field_list",
                        "add_file_name",
                        "main"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "set_join_field",
                "func_c_signature": "void set_join_field(long *param_1,long param_2)",
                "decompiled_code": "void set_join_field(long *param_1,long param_2) {\n  long lVar1;\n  undefined8 uVar2;\n  \n  if ((-1 < *param_1) && (param_2 != *param_1)) {\n    lVar1 = *param_1;\n    uVar2 = gettext(\"incompatible join fields %td, %td\");\n    error(1,0,uVar2,lVar1,param_2);\n  }\n  *param_1 = param_2;\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "set_join_field",
                        "gettext",
                        "error"
                    ],
                    "calling_functions": [
                        "set_join_field",
                        "add_file_name",
                        "main"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "add_file_name",
                "func_c_signature": "void add_file_name(undefined8 param_1,undefined8 *param_2,int *param_3,int *param_4,int *param_5,\n                  int *param_6,undefined4 *param_7)",
                "decompiled_code": "void add_file_name(undefined8 param_1,undefined8 *param_2,int *param_3,int *param_4,int *param_5,\n                  int *param_6,undefined4 *param_7) {\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  bool bVar5;\n  int local_34;\n  \n  local_34 = *param_5;\n  if (local_34 != 2) goto LAB_00101fdc;\n  bVar5 = *param_3 == 0;\n  uVar4 = param_2[bVar5];\n  iVar1 = param_3[bVar5];\n  if (iVar1 == 3) {\n    add_field_list(uVar4);\n  }\n  else if (iVar1 < 4) {\n    if (iVar1 == 2) {\n      param_4[1] = param_4[1] + -1;\n      uVar4 = string_to_join_field(uVar4);\n      set_join_field(&join_field_2,uVar4);\n    }\n    else if (iVar1 < 3) {\n      if (iVar1 == 0) {\n        uVar2 = quotearg_style(4,param_1);\n        uVar3 = gettext(\"extra operand %s\");\n        error(0,0,uVar3,uVar2);\n        usage(1);\n      }\n      else if (iVar1 != 1) goto LAB_00101fae;\n      *param_4 = *param_4 + -1;\n      uVar4 = string_to_join_field(uVar4);\n      set_join_field(&join_field_1,uVar4);\n    }\n  }\nLAB_00101fae:\n  if (!bVar5) {\n    *param_3 = param_3[1];\n    *param_2 = param_2[1];\n  }\n  local_34 = 1;\nLAB_00101fdc:\n  param_3[local_34] = *param_6;\n  param_2[local_34] = param_1;\n  *param_5 = local_34 + 1;\n  if (*param_6 == 3) {\n    *param_7 = 3;\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "add_file_name",
                        "add_field_list",
                        "string_to_join_field",
                        "set_join_field",
                        "quotearg_style",
                        "gettext",
                        "error",
                        "usage"
                    ],
                    "calling_functions": [
                        "add_file_name",
                        "main"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "undefined8 main(int param_1,undefined8 *param_2)",
                "decompiled_code": "undefined8 main(int param_1,undefined8 *param_2) {\n  char cVar1;\n  uint uVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  long in_FS_OFFSET;\n  int local_11c;\n  int local_118;\n  int local_114;\n  int local_110;\n  int local_10c;\n  undefined4 local_108;\n  undefined4 local_104;\n  undefined4 local_100;\n  undefined4 local_fc;\n  undefined4 local_f8;\n  undefined4 local_f4;\n  undefined4 local_f0;\n  undefined4 local_ec;\n  undefined4 local_e8;\n  undefined4 local_e4;\n  undefined4 local_e0;\n  undefined4 local_dc;\n  undefined4 local_d8;\n  int local_d4;\n  undefined4 local_d0;\n  int local_cc;\n  undefined4 local_c8;\n  int local_c4;\n  undefined4 local_c0;\n  int local_bc;\n  undefined4 local_b8;\n  int local_b4;\n  undefined4 local_b0;\n  undefined4 local_ac;\n  long local_a8;\n  long local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined *local_68;\n  undefined *local_60;\n  undefined8 local_58;\n  undefined *local_50;\n  undefined *local_48;\n  undefined8 local_40;\n  ulong local_38;\n  undefined local_30 [8];\n  int local_28 [2];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_118 = 0;\n  local_28[0] = 0;\n  local_28[1] = 0;\n  local_114 = 0;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  hard_LC_COLLATE = hard_locale(3);\n  atexit((__func *)&close_stdout);\n  atexit(free_spareline);\n  print_pairables = 1;\n  seen_unpairable = 0;\n  DAT_00102ce6 = '\\0';\n  issued_disorder_warning = '\\0';\n  check_input_order = 0;\n  do {\n    local_10c = getopt_long(param_1,param_2,\"-a:e:i1:2:j:o:t:v:z\",longopts,0);\n    if (local_10c == -1) {\n      local_118 = 0;\n      local_10c = 0xffffffff;\n      while (_optind < param_1) {\n        lVar4 = (long)_optind;\n        _optind = _optind + 1;\n        add_file_name(param_2[lVar4],&g_names,local_30,local_28,&local_114,&local_118,&local_11c);\n      }\n      if (local_114 != 2) {\n        if (local_114 == 0) {\n          local_78 = gettext(\"missing operand\");\n          local_e8 = 0;\n          local_e4 = 0;\n          error(0,0,local_78);\n        }\n        else {\n          uVar5 = quote(param_2[(long)param_1 + -1]);\n          local_70 = gettext(\"missing operand after %s\");\n          local_e0 = 0;\n          local_dc = 0;\n          error(0,0,local_70,uVar5);\n        }\n        usage(1);\n      }\n      for (local_110 = 0; local_110 < 2; local_110 = local_110 + 1) {\n        if (local_28[local_110] != 0) {\n          set_join_field(&join_field_1,(long)local_110);\n          set_join_field(&join_field_2,(long)local_110);\n        }\n      }\n      if (join_field_1 < 0) {\n        join_field_1 = 0;\n      }\n      if (join_field_2 < 0) {\n        join_field_2 = 0;\n      }\n      cVar1 = streq(g_names,&DAT_00103abd);\n      local_a8 = _stdin;\n      if (cVar1 == '\\0') {\n        local_a8 = fopen_safer(g_names,&DAT_00103abf);\n      }\n      if (local_a8 == 0) {\n        uVar5 = quotearg_n_style_colon(0,3,g_names);\n        piVar6 = __errno_location();\n        local_d4 = *piVar6;\n        local_d8 = 1;\n        local_68 = &DAT_00103ac1;\n        error(1,local_d4,&DAT_00103ac1,uVar5);\n      }\n      cVar1 = streq(DAT_00102cc8,&DAT_00103abd);\n      local_a0 = _stdin;\n      if (cVar1 == '\\0') {\n        local_a0 = fopen_safer(DAT_00102cc8,&DAT_00103abf);\n      }\n      if (local_a0 == 0) {\n        uVar5 = quotearg_n_style_colon(0,3,DAT_00102cc8);\n        piVar6 = __errno_location();\n        local_cc = *piVar6;\n        local_d0 = 1;\n        local_60 = &DAT_00103ac1;\n        error(1,local_cc,&DAT_00103ac1,uVar5);\n      }\n      if (local_a8 == local_a0) {\n        uVar5 = gettext(\"both files cannot be standard input\");\n        piVar6 = __errno_location();\n        local_c4 = *piVar6;\n        local_c8 = 1;\n        local_58 = uVar5;\n        error(1,local_c4,uVar5);\n      }\n      system_join(local_a8,local_a0);\n      iVar3 = rpl_fclose(local_a8);\n      if (iVar3 != 0) {\n        uVar5 = quotearg_n_style_colon(0,3,g_names);\n        piVar6 = __errno_location();\n        local_bc = *piVar6;\n        local_c0 = 1;\n        local_50 = &DAT_00103ac1;\n        error(1,local_bc,&DAT_00103ac1,uVar5);\n      }\n      iVar3 = rpl_fclose(local_a0);\n      if (iVar3 != 0) {\n        uVar5 = quotearg_n_style_colon(0,3,DAT_00102cc8);\n        piVar6 = __errno_location();\n        local_b4 = *piVar6;\n        local_b8 = 1;\n        local_48 = &DAT_00103ac1;\n        error(1,local_b4,&DAT_00103ac1,uVar5);\n      }\n      if ((issued_disorder_warning != '\\0') || (DAT_00102ce6 != '\\0')) {\n        local_40 = gettext(\"input is not in sorted order\");\n        local_b0 = 1;\n        local_ac = 0;\n        error(1,0,local_40);\n      }\n      if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return 0;\n    }\n    local_11c = 0;\n    if (local_10c < 0x83) {\n      if (local_10c < 0x31) {\n        if (local_10c != 1) {\n          if (local_10c < 2) {\n            if (local_10c == -0x83) {\nLAB_001026a3:\n              uVar5 = proper_name_lite(\"Mike Haertel\",\"Mike Haertel\");\n              version_etc(_stdout,&DAT_00103884,\"GNU coreutils\",_Version,uVar5,0);\n                    /* WARNING: Subroutine does not return */\n              exit(0);\n            }\n            if (local_10c == -0x82) {\n              usage(0);\n              goto LAB_001026a3;\n            }\n          }\n          goto switchD_001021ca_caseD_33;\n        }\n        add_file_name(_optarg,&g_names,local_30,local_28,&local_114,&local_118,&local_11c);\n      }\n      else {\n        switch(local_10c) {\n        case 0x31:\n          uVar5 = string_to_join_field(_optarg);\n          set_join_field(&join_field_1,uVar5);\n          break;\n        case 0x32:\n          uVar5 = string_to_join_field(_optarg);\n          set_join_field(&join_field_2,uVar5);\n          break;\n        default:\n          goto switchD_001021ca_caseD_33;\n        case 0x65:\n          if ((empty_filler != (char *)0x0) &&\n             (cVar1 = streq(empty_filler,_optarg), cVar1 != '\\x01')) {\n            local_90 = gettext(\"conflicting empty-field replacement strings\");\n            local_100 = 1;\n            local_fc = 0;\n            error(1,0,local_90);\n          }\n          empty_filler = _optarg;\n          break;\n        case 0x69:\n          ignore_case = 1;\n          break;\n        case 0x6a:\n          if ((((*_optarg == '1') || (*_optarg == '2')) && (_optarg[1] == '\\0')) &&\n             ((char *)(param_2[(long)_optind + -1] + 2) == _optarg)) {\n            cVar1 = *_optarg;\n            uVar2 = (uint)(cVar1 == '2');\n            local_28[(int)uVar2] = local_28[(int)uVar2] + 1;\n            local_11c = (cVar1 == '2') + 1;\n          }\n          else {\n            uVar5 = string_to_join_field(_optarg);\n            set_join_field(&join_field_1,uVar5);\n            set_join_field(&join_field_2,join_field_1);\n          }\n          break;\n        case 0x6f:\n          cVar1 = streq(_optarg,&DAT_00103a34);\n          if (cVar1 == '\\0') {\n            add_field_list(_optarg);\n            local_11c = 3;\n          }\n          else {\n            autoformat = 1;\n          }\n          break;\n        case 0x74:\n          if (*_optarg == '\\0') {\n            local_38 = mcel_ch(10,1);\n          }\n          else {\n            cVar1 = streq(_optarg,&DAT_00103a39);\n            if (cVar1 == '\\0') {\n              local_38 = mcel_scanz(_optarg);\n              if (_optarg[local_38 >> 0x28 & 0xff] != '\\0') {\n                uVar5 = quote(_optarg);\n                local_88 = gettext(\"multi-character tab %s\");\n                local_f8 = 1;\n                local_f4 = 0;\n                error(1,0,local_88,uVar5);\n              }\n              output_separator = _optarg;\n            }\n            else {\n              local_38 = mcel_ch(0,1);\n              output_separator = &DAT_00102e84;\n            }\n          }\n          if ((tab._5_1_ != '\\0') && (iVar3 = mcel_cmp(tab,local_38), iVar3 != 0)) {\n            local_80 = gettext(\"incompatible tabs\");\n            local_f0 = 1;\n            local_ec = 0;\n            error(1,0,local_80);\n          }\n          tab = local_38;\n          output_seplen = local_38 >> 0x28 & 0xff;\n          break;\n        case 0x76:\n          print_pairables = 0;\n        case 0x61:\n          iVar3 = xstrtol(_optarg,0,10,&local_38,&DAT_00102e84);\n          if ((iVar3 != 0) || ((local_38 != 1 && (local_38 != 2)))) {\n            uVar5 = quote(_optarg);\n            local_98 = gettext(\"invalid file number: %s\");\n            local_108 = 1;\n            local_104 = 0;\n            error(1,0,local_98,uVar5);\n          }\n          if (local_38 == 1) {\n            print_unpairables_1 = 1;\n          }\n          else {\n            print_unpairables_2 = 1;\n          }\n          break;\n        case 0x7a:\n          eolchar = 0;\n          break;\n        case 0x80:\n          check_input_order = 1;\n          break;\n        case 0x81:\n          check_input_order = 2;\n          break;\n        case 0x82:\n          join_header_lines = 1;\n        }\n      }\n    }\n    else {\nswitchD_001021ca_caseD_33:\n      usage(1);\n    }\n    local_118 = local_11c;\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "hard_locale",
                        "atexit",
                        "getopt_long",
                        "add_file_name",
                        "gettext",
                        "error",
                        "quote",
                        "usage",
                        "set_join_field",
                        "streq",
                        "fopen_safer",
                        "quotearg_n_style_colon",
                        "__errno_location",
                        "system_join",
                        "rpl_fclose",
                        "__stack_chk_fail",
                        "proper_name_lite",
                        "version_etc",
                        "exit",
                        "string_to_join_field",
                        "add_field_list",
                        "mcel_ch",
                        "mcel_scanz",
                        "mcel_cmp",
                        "xstrtol"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "join_decompiled.c"
                }
            }
        ]
    }
}