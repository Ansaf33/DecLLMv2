{
    "file": "CROMU_00009",
    "decompiled_code": {
        "cmd.c": [
            {
                "func_name": "readUntil",
                "func_c_signature": "uint readUntil(byte *param_1,uint param_2,char param_3)",
                "decompiled_code": "uint readUntil(byte *param_1,uint param_2,char param_3) {\n  int iVar1;\n  int local_18;\n  byte local_11;\n  uint local_10;\n  \n  for (local_10 = 0; local_10 < param_2; local_10 = local_10 + 1) {\n    iVar1 = receive(0,&local_11,1,&local_18);\n    if (iVar1 != 0) {\n      return 0xffffffff;\n    }\n    if (local_18 != 1) {\n      return 0xffffffff;\n    }\n    if ((uint)local_11 == (int)param_3) break;\n    *param_1 = local_11;\n    param_1 = param_1 + 1;\n  }\n  *param_1 = 0;\n  return local_10;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "readUntil",
                        "receive"
                    ],
                    "calling_functions": [
                        "readUntil",
                        "main"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "ExitHandler",
                "func_c_signature": "int ExitHandler(void)",
                "decompiled_code": "int ExitHandler(void) {\n  int iVar1;\n  size_t sVar2;\n  size_t sVar3;\n  __mode_t in_stack_fffffecc;\n  char *__mode;\n  char acStack_128 [256];\n  undefined **ppuStack_28;\n  \n  puts(\"bye\");\n  _terminate();\n  ppuStack_28 = &_GLOBAL_OFFSET_TABLE_;\n  if (ARGC == 2) {\n    if (*DAT_0001a9e4 == '/') {\n      iVar1 = mkdir(DAT_0001a9e4,in_stack_fffffecc);\n    }\n    else {\n      bzero(acStack_128,0x100);\n      sVar2 = strlen(CWD);\n      sVar3 = strlen(DAT_0001a9e4);\n      if (sVar3 + sVar2 + 1 < 0x100) {\n        strcpy(acStack_128,CWD);\n        __mode = DAT_0001a9e4;\n        strcat(acStack_128,DAT_0001a9e4);\n        iVar1 = mkdir(acStack_128,(__mode_t)__mode);\n      }\n      else {\n        puts(\"command too long\");\n        iVar1 = 0;\n      }\n    }\n  }\n  else {\n    puts(\"usage: mkfolder <directory>\");\n    iVar1 = 0;\n  }\n  return iVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "ExitHandler",
                        "puts",
                        "_terminate",
                        "mkdir",
                        "bzero",
                        "strlen",
                        "strcpy",
                        "strcat"
                    ],
                    "calling_functions": [
                        "ExitHandler"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "MkdirHandler",
                "func_c_signature": "int MkdirHandler(void)",
                "decompiled_code": "int MkdirHandler(void) {\n  int iVar1;\n  size_t sVar2;\n  size_t sVar3;\n  __mode_t in_stack_fffffee8;\n  char *__mode;\n  char local_10c [256];\n  \n  if (ARGC == 2) {\n    if (*DAT_0001a9e4 == '/') {\n      iVar1 = mkdir(DAT_0001a9e4,in_stack_fffffee8);\n    }\n    else {\n      bzero(local_10c,0x100);\n      sVar2 = strlen(CWD);\n      sVar3 = strlen(DAT_0001a9e4);\n      if (sVar3 + sVar2 + 1 < 0x100) {\n        strcpy(local_10c,CWD);\n        __mode = DAT_0001a9e4;\n        strcat(local_10c,DAT_0001a9e4);\n        iVar1 = mkdir(local_10c,(__mode_t)__mode);\n      }\n      else {\n        puts(\"command too long\");\n        iVar1 = 0;\n      }\n    }\n  }\n  else {\n    puts(\"usage: mkfolder <directory>\");\n    iVar1 = 0;\n  }\n  return iVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "MkdirHandler",
                        "mkdir",
                        "bzero",
                        "strlen",
                        "strcpy",
                        "strcat",
                        "puts"
                    ],
                    "calling_functions": [
                        "MkdirHandler"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "RmdirHandler",
                "func_c_signature": "int RmdirHandler(void)",
                "decompiled_code": "int RmdirHandler(void) {\n  int iVar1;\n  size_t sVar2;\n  size_t sVar3;\n  char local_10c [256];\n  \n  if (ARGC == 2) {\n    if (*DAT_0001a9e4 == '/') {\n      iVar1 = rmdir(DAT_0001a9e4);\n    }\n    else {\n      bzero(local_10c,0x100);\n      sVar2 = strlen(CWD);\n      sVar3 = strlen(DAT_0001a9e4);\n      if (sVar3 + sVar2 + 1 < 0x100) {\n        strcpy(local_10c,CWD);\n        strcat(local_10c,DAT_0001a9e4);\n        iVar1 = rmdir(local_10c);\n      }\n      else {\n        puts(\"command too long\");\n        iVar1 = 0;\n      }\n    }\n  }\n  else {\n    puts(\"usage: delfolder <directory>\");\n    iVar1 = 0;\n  }\n  return iVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "RmdirHandler",
                        "rmdir",
                        "bzero",
                        "strlen",
                        "strcpy",
                        "strcat",
                        "puts"
                    ],
                    "calling_functions": [
                        "RmdirHandler"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "LsHandler",
                "func_c_signature": "undefined4 LsHandler(void)",
                "decompiled_code": "undefined4 LsHandler(void) {\n  undefined4 uVar1;\n  size_t sVar2;\n  size_t sVar3;\n  char local_10c [256];\n  \n  if (ARGC == 1) {\n    uVar1 = ls(CWD);\n  }\n  else if (ARGC == 2) {\n    if (*DAT_0001a9e4 == '/') {\n      uVar1 = ls(DAT_0001a9e4);\n    }\n    else {\n      bzero(local_10c,0x100);\n      sVar2 = strlen(CWD);\n      sVar3 = strlen(DAT_0001a9e4);\n      if (sVar3 + sVar2 + 1 < 0x100) {\n        strcpy(local_10c,CWD);\n        strcat(local_10c,DAT_0001a9e4);\n        uVar1 = ls(local_10c);\n      }\n      else {\n        puts(\"command too long\");\n        uVar1 = 0;\n      }\n    }\n  }\n  else {\n    puts(\"usage: show <directory>\");\n    uVar1 = 0;\n  }\n  return uVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "LsHandler",
                        "ls",
                        "bzero",
                        "strlen",
                        "strcpy",
                        "strcat",
                        "puts"
                    ],
                    "calling_functions": [
                        "LsHandler"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "RmHandler",
                "func_c_signature": "int RmHandler(void)",
                "decompiled_code": "int RmHandler(void) {\n  int iVar1;\n  size_t sVar2;\n  size_t sVar3;\n  char local_10c [256];\n  \n  if (ARGC == 2) {\n    if (*DAT_0001a9e4 == '/') {\n      iVar1 = unlink(DAT_0001a9e4);\n    }\n    else {\n      bzero(local_10c,0x100);\n      sVar2 = strlen(CWD);\n      sVar3 = strlen(DAT_0001a9e4);\n      if (sVar3 + sVar2 + 1 < 0x100) {\n        strcpy(local_10c,CWD);\n        strcat(local_10c,DAT_0001a9e4);\n        iVar1 = unlink(local_10c);\n      }\n      else {\n        puts(\"command too long\");\n        iVar1 = 0;\n      }\n    }\n  }\n  else {\n    puts(\"usage: delete <file>\");\n    iVar1 = 0;\n  }\n  return iVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "RmHandler",
                        "unlink",
                        "bzero",
                        "strlen",
                        "strcpy",
                        "strcat",
                        "puts"
                    ],
                    "calling_functions": [
                        "RmHandler"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "EchoHandler",
                "func_c_signature": "undefined4 EchoHandler(void)",
                "decompiled_code": "undefined4 EchoHandler(void) {\n  undefined4 uVar1;\n  size_t sVar2;\n  int iVar3;\n  size_t sVar4;\n  char local_214 [256];\n  char local_114 [256];\n  void *local_14;\n  FILE *local_10;\n  \n  if ((ARGC < 2) || (ARGC == 3)) {\n    puts(\"usage: echo <text> [>|>>] [file]\");\n    uVar1 = 0;\n  }\n  else if (ARGC == 2) {\n    bzero(local_214,0x100);\n    sVar4 = 0xff;\n    strncpy(local_214,DAT_0001a9e4,0xff);\n    local_14 = (void *)Unescape(local_214);\n    if (local_14 == (void *)0xffffffff) {\n      puts(\"unable to write to file\");\n      uVar1 = 0xffffffff;\n    }\n    else {\n      write((int)local_214,local_14,sVar4);\n      uVar1 = 0;\n    }\n  }\n  else {\n    if (ARGC == 4) {\n      bzero(local_114,0x100);\n      if (*DAT_0001a9ec == '/') {\n        sVar4 = strlen(DAT_0001a9ec);\n        if (0xff < sVar4) {\n          puts(\"invalid file name\");\n          return 0xffffffff;\n        }\n        strcpy(local_114,DAT_0001a9ec);\n      }\n      else {\n        sVar4 = strlen(CWD);\n        sVar2 = strlen(DAT_0001a9ec);\n        if (0xff < sVar2 + sVar4 + 1) {\n          puts(\"command too long\");\n          return 0;\n        }\n        strcpy(local_114,CWD);\n        strcat(local_114,DAT_0001a9ec);\n      }\n      iVar3 = strcmp(DAT_0001a9e8,\">\");\n      if (iVar3 == 0) {\n        local_10 = fopen(local_114,\"w\");\n        if (local_10 == (FILE *)0x0) {\n          puts(\"unable to write to file\");\n          return 0xffffffff;\n        }\n        bzero(local_214,0x100);\n        strncpy(local_214,DAT_0001a9e4,0xff);\n        local_14 = (void *)Unescape(local_214);\n        if (local_14 == (void *)0xffffffff) {\n          puts(\"unable to write to file\");\n          fclose(local_10);\n          return 0xffffffff;\n        }\n        fwrite(local_214,(size_t)local_14,1,local_10);\n        fclose(local_10);\n      }\n      else {\n        iVar3 = strcmp(DAT_0001a9e8,\">>\");\n        if (iVar3 != 0) {\n          puts(\"usage: echo <text> [>|>>] [file]\");\n          return 0;\n        }\n        local_10 = fopen(local_114,\"a\");\n        if (local_10 == (FILE *)0x0) {\n          puts(\"unable to write to file\");\n          return 0xffffffff;\n        }\n        bzero(local_214,0x100);\n        strncpy(local_214,DAT_0001a9e4,0xff);\n        local_14 = (void *)Unescape(local_214);\n        if (local_14 == (void *)0xffffffff) {\n          fclose(local_10);\n          puts(\"unable to write to file\");\n          return 0xffffffff;\n        }\n        fwrite(local_214,(size_t)local_14,1,local_10);\n        fclose(local_10);\n      }\n    }\n    uVar1 = 0;\n  }\n  return uVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "EchoHandler",
                        "puts",
                        "bzero",
                        "strncpy",
                        "Unescape",
                        "write",
                        "strlen",
                        "strcpy",
                        "strcat",
                        "strcmp",
                        "fopen",
                        "fclose",
                        "fwrite"
                    ],
                    "calling_functions": [
                        "EchoHandler"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "CatHandler",
                "func_c_signature": "undefined4 CatHandler(void)",
                "decompiled_code": "undefined4 CatHandler(void) {\n  undefined4 uVar1;\n  size_t sVar2;\n  size_t sVar3;\n  char local_10c [256];\n  \n  if (ARGC == 2) {\n    if (*DAT_0001a9e4 == '/') {\n      uVar1 = ReadFile(DAT_0001a9e4);\n    }\n    else {\n      bzero(local_10c,0x100);\n      sVar2 = strlen(CWD);\n      sVar3 = strlen(DAT_0001a9e4);\n      if (sVar3 + sVar2 + 1 < 0x100) {\n        strcpy(local_10c,CWD);\n        strcat(local_10c,DAT_0001a9e4);\n        uVar1 = ReadFile(local_10c);\n      }\n      else {\n        puts(\"command too long\");\n        uVar1 = 0;\n      }\n    }\n  }\n  else {\n    puts(\"usage: dump <file>\");\n    uVar1 = 0;\n  }\n  return uVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "CatHandler",
                        "ReadFile",
                        "bzero",
                        "strlen",
                        "strcpy",
                        "strcat",
                        "puts"
                    ],
                    "calling_functions": [
                        "CatHandler"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "HelpHandler",
                "func_c_signature": "undefined4 HelpHandler(void)",
                "decompiled_code": "undefined4 HelpHandler(void) {\n  size_t sVar1;\n  char *pcVar2;\n  int local_14;\n  undefined **local_10;\n  \n  for (local_10 = &cmds; *local_10 != (char *)0x0; local_10 = local_10 + 3) {\n    pcVar2 = *local_10;\n    printf(\"@s\",pcVar2);\n    sVar1 = strlen(*local_10);\n    local_14 = 0x14 - sVar1;\n    while (0 < local_14) {\n      printf(\" \",pcVar2);\n      local_14 = local_14 + -1;\n    }\n    printf(\"@s\\n\",local_10[2]);\n  }\n  return 0;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "HelpHandler",
                        "printf",
                        "strlen"
                    ],
                    "calling_functions": [
                        "HelpHandler"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "DfHandler",
                "func_c_signature": "undefined4 DfHandler(void)",
                "decompiled_code": "undefined4 DfHandler(void) {\n  if (ARGC == 1) {\n    StatusFS();\n  }\n  else {\n    puts(\"usage: fsinfo\");\n  }\n  return 0;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "DfHandler",
                        "StatusFS",
                        "puts"
                    ],
                    "calling_functions": [
                        "DfHandler"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "IsHex",
                "func_c_signature": "undefined4 IsHex(char param_1)",
                "decompiled_code": "undefined4 IsHex(char param_1) {\n  undefined4 uVar1;\n  \n  if ((param_1 < '0') || ('9' < param_1)) {\n    if ((param_1 < 'a') || ('f' < param_1)) {\n      if ((param_1 < 'A') || ('F' < param_1)) {\n        uVar1 = 0;\n      }\n      else {\n        uVar1 = 1;\n      }\n    }\n    else {\n      uVar1 = 1;\n    }\n  }\n  else {\n    uVar1 = 1;\n  }\n  return uVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "IsHex"
                    ],
                    "calling_functions": [
                        "IsHex",
                        "Unescape"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "Hex2Char",
                "func_c_signature": "char Hex2Char(char *param_1)",
                "decompiled_code": "char Hex2Char(char *param_1) {\n  char local_5;\n  \n  local_5 = '\\0';\n  if (('/' < *param_1) && (*param_1 < ':')) {\n    local_5 = *param_1 * '\\x10';\n  }\n  if (('`' < *param_1) && (*param_1 < 'g')) {\n    local_5 = local_5 + (*param_1 + -0x57) * '\\x10';\n  }\n  if (('@' < *param_1) && (*param_1 < 'G')) {\n    local_5 = local_5 + (*param_1 + -0x37) * '\\x10';\n  }\n  if (('/' < param_1[1]) && (param_1[1] < ':')) {\n    local_5 = local_5 + param_1[1] + -0x30;\n  }\n  if (('`' < param_1[1]) && (param_1[1] < 'g')) {\n    local_5 = local_5 + param_1[1] + -0x57;\n  }\n  if (('@' < param_1[1]) && (param_1[1] < 'G')) {\n    local_5 = local_5 + param_1[1] + -0x37;\n  }\n  return local_5;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "Hex2Char"
                    ],
                    "calling_functions": [
                        "Hex2Char",
                        "Unescape"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "Unescape",
                "func_c_signature": "int Unescape(char *param_1)",
                "decompiled_code": "int Unescape(char *param_1) {\n  char *pcVar1;\n  char cVar2;\n  int iVar3;\n  char *local_c;\n  char *local_8;\n  \n  local_8 = param_1;\n  if (param_1 == (char *)0x0) {\n    iVar3 = -1;\n  }\n  else {\n    for (; *local_8 != '\\0'; local_8 = local_8 + 1) {\n      if ((*local_8 == '\\\\') && (local_8[1] == 'x')) {\n        iVar3 = IsHex((int)local_8[2]);\n        if (iVar3 != 0) {\n          iVar3 = IsHex((int)local_8[3]);\n          if (iVar3 != 0) {\n            cVar2 = Hex2Char(local_8 + 2);\n            *local_8 = cVar2;\n            pcVar1 = local_8;\n            while ((local_c = pcVar1 + 1, *local_c != '\\0' && (pcVar1[4] != '\\0'))) {\n              *local_c = pcVar1[4];\n              pcVar1 = local_c;\n            }\n            *local_c = '\\0';\n          }\n        }\n      }\n    }\n    iVar3 = (int)local_8 - (int)param_1;\n  }\n  return iVar3;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "Unescape",
                        "IsHex",
                        "Hex2Char"
                    ],
                    "calling_functions": [
                        "EchoHandler",
                        "Unescape"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            }
        ],
        "fs.c": [
            {
                "func_name": "InitFS",
                "func_c_signature": "undefined4 InitFS(uint param_1)",
                "decompiled_code": "undefined4 InitFS(uint param_1) {\n  char *pcVar1;\n  undefined4 uVar2;\n  int iVar3;\n  \n  if ((param_1 & 0xfff) != 0) {\n    param_1 = (param_1 & 0xfffff000) + 0x1000;\n  }\n  if (param_1 < 0x100001) {\n    if ((param_1 & 0x1ff) == 0) {\n      bzero(&fs,0x10c);\n      fs = 0x43524653;\n      DAT_0001a0c4 = 0x200;\n      DAT_0001a0c8 = param_1;\n      iVar3 = allocate(0x1000,0,&DAT_0001a0cc);\n      if (iVar3 == 0) {\n        bzero(DAT_0001a0cc,0x1000);\n        bzero(&free_list,0x800);\n        iVar3 = allocate(0x1000,0,&DAT_0001a1e4);\n        if (iVar3 == 0) {\n          bzero(_DAT_0001a1e4,0x1000);\n          pcVar1 = DAT_0001a0cc;\n          strcpy(DAT_0001a0cc,\"/\");\n          *(undefined4 *)(pcVar1 + 0xd0) = 2;\n          *(undefined4 *)(pcVar1 + 0xd4) = 0;\n          *(undefined4 *)(pcVar1 + 0xd8) = 1;\n          *(void **)(pcVar1 + 0xe0) = _DAT_0001a1e4;\n          free_list = 0x80;\n          uVar2 = 0;\n        }\n        else {\n          puts(\"Failed to allocate data blocks\\n\");\n          uVar2 = 0xffffffff;\n        }\n      }\n      else {\n        puts(\"Failed to allocate inode page\\n\");\n        uVar2 = 0xffffffff;\n      }\n    }\n    else {\n      puts(\"Requested filesystem size is not an even number of blocks\\n\");\n      uVar2 = 0xffffffff;\n    }\n  }\n  else {\n    puts(\"Requested filesystem size is too large\\n\");\n    uVar2 = 0xffffffff;\n  }\n  return uVar2;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "InitFS",
                        "bzero",
                        "allocate",
                        "strcpy",
                        "puts"
                    ],
                    "calling_functions": [
                        "InitFS",
                        "main"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "DestroyFS",
                "func_c_signature": "undefined4 DestroyFS(void)",
                "decompiled_code": "undefined4 DestroyFS(void) {\n  uint uVar1;\n  uint local_10;\n  \n  uVar1 = DAT_0001a0c8 >> 0xc;\n  for (local_10 = 0; local_10 < uVar1; local_10 = local_10 + 1) {\n    if (*(int *)(&DAT_0001a1e4 + local_10 * 8) != 0) {\n      deallocate(&DAT_0001a1e4 + local_10 * 8,0x1000);\n    }\n  }\n  for (local_10 = 0; (int)local_10 < 0x40; local_10 = local_10 + 1) {\n    if ((&DAT_0001a0cc)[local_10] != 0) {\n      deallocate(&DAT_0001a0cc + local_10,0x1000);\n    }\n  }\n  return 0;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "DestroyFS",
                        "deallocate"
                    ],
                    "calling_functions": [
                        "DestroyFS",
                        "main"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "FindInode",
                "func_c_signature": "int FindInode(char *param_1)",
                "decompiled_code": "int FindInode(char *param_1) {\n  int iVar1;\n  int iVar2;\n  int local_14;\n  int local_10;\n  \n  if (param_1 != (char *)0x0) {\n    for (local_10 = 0; (local_10 < 0x40 && ((&DAT_0001a0cc)[local_10] != 0));\n        local_10 = local_10 + 1) {\n      iVar1 = (&DAT_0001a0cc)[local_10];\n      for (local_14 = 0; local_14 < 0x10; local_14 = local_14 + 1) {\n        if (((*(int *)(iVar1 + local_14 * 0x100 + 0xd0) == 1) ||\n            (*(int *)(iVar1 + local_14 * 0x100 + 0xd0) == 2)) &&\n           (iVar2 = strcmp((char *)(iVar1 + local_14 * 0x100),param_1), iVar2 == 0)) {\n          return iVar1 + local_14 * 0x100;\n        }\n      }\n    }\n  }\n  return 0;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "FindInode",
                        "strcmp"
                    ],
                    "calling_functions": [
                        "FindInode",
                        "CheckFileExists"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "FindDirEntry",
                "func_c_signature": "char * FindDirEntry(int param_1,char *param_2)",
                "decompiled_code": "char * FindDirEntry(int param_1,char *param_2) {\n  int iVar1;\n  char *__s1;\n  int iVar2;\n  int local_14;\n  int local_10;\n  \n  if (((param_1 != 0) && (param_2 != (char *)0x0)) && (*(int *)(param_1 + 0xd0) == 2)) {\n    for (local_10 = 0; local_10 < 8; local_10 = local_10 + 1) {\n      iVar1 = *(int *)(param_1 + (local_10 + 0x38) * 4);\n      if (iVar1 != 0) {\n        for (local_14 = 0;\n            (local_14 < 0x81 && ((uint)((local_14 + 1) * 4) <= *(uint *)(param_1 + 0xd4)));\n            local_14 = local_14 + 1) {\n          __s1 = *(char **)(iVar1 + local_14 * 4);\n          if ((__s1 != (char *)0x0) && (iVar2 = strcmp(__s1,param_2), iVar2 == 0)) {\n            return __s1;\n          }\n        }\n      }\n    }\n  }\n  return (char *)0x0;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "FindDirEntry",
                        "strcmp"
                    ],
                    "calling_functions": [
                        "FindDirEntry",
                        "CheckFileExists"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "CheckFileExists",
                "func_c_signature": "undefined4 CheckFileExists(char *param_1,int *param_2)",
                "decompiled_code": "undefined4 CheckFileExists(char *param_1,int *param_2) {\n  int iVar1;\n  char *pcVar2;\n  undefined4 local_18;\n  int local_14;\n  char *local_10;\n  \n  local_10 = param_1;\n  local_18 = 1;\n  if (param_1 == (char *)0x0) {\n    local_18 = 0xffffffff;\n  }\n  else if (*param_1 == '/') {\n    local_14 = FindInode(&DAT_000172bc);\n    if (local_14 == 0) {\n      puts(\"failed to root find inode\");\n      local_18 = 0xffffffff;\n    }\n    else {\n      iVar1 = strcmp(param_1,\"/\");\n      if (iVar1 == 0) {\n        *param_2 = local_14;\n        local_18 = 2;\n      }\n      else {\n        while (pcVar2 = strtok(local_10,\"/\"), pcVar2 != (char *)0x0) {\n          local_10 = (char *)0x0;\n          local_18 = 0;\n          iVar1 = FindDirEntry(local_14,pcVar2);\n          if (iVar1 != 0) {\n            if (*(int *)(iVar1 + 0xd0) != 2) {\n              *param_2 = iVar1;\n              local_18 = 1;\n              break;\n            }\n            *param_2 = iVar1;\n            local_18 = 2;\n            local_14 = iVar1;\n          }\n        }\n        if (local_10 != (char *)0x0) {\n          local_18 = 0;\n        }\n      }\n    }\n  }\n  else {\n    puts(\"invalid filename\");\n    local_18 = 0xffffffff;\n  }\n  return local_18;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "CheckFileExists",
                        "FindInode",
                        "puts",
                        "strcmp",
                        "strtok",
                        "FindDirEntry"
                    ],
                    "calling_functions": [
                        "CheckFileExists",
                        "CreateFile",
                        "ReadFile",
                        "mkdir",
                        "rmdir",
                        "unlink",
                        "fopen",
                        "ls"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "FindFreeInode",
                "func_c_signature": "int FindFreeInode(void)",
                "decompiled_code": "int FindFreeInode(void) {\n  int iVar1;\n  int local_18;\n  int local_14;\n  int local_10;\n  \n  local_10 = 0;\n  do {\n    if (0x3f < local_10) {\n      return 0;\n    }\n    local_18 = (&DAT_0001a0cc)[local_10];\n    if (local_18 == 0) {\n      iVar1 = allocate(0x1000,0,&DAT_0001a0cc + local_10);\n      if (iVar1 != 0) {\n        puts(\"Failed to allocate inode page\\n\");\n        return 0;\n      }\n      bzero((void *)(&DAT_0001a0cc)[local_10],0x1000);\n      local_18 = (&DAT_0001a0cc)[local_10];\n    }\n    for (local_14 = 0; local_14 < 0x10; local_14 = local_14 + 1) {\n      iVar1 = local_18 + local_14 * 0x100;\n      if (*(int *)(iVar1 + 0xd0) == 0) {\n        return iVar1;\n      }\n    }\n    local_10 = local_10 + 1;\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "FindFreeInode",
                        "allocate",
                        "puts",
                        "bzero"
                    ],
                    "calling_functions": [
                        "FindFreeInode",
                        "CreateFile",
                        "mkdir",
                        "fwrite"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "FindFreeDataBlock",
                "func_c_signature": "int FindFreeDataBlock(void)",
                "decompiled_code": "int FindFreeDataBlock(void) {\n  int iVar1;\n  byte local_15;\n  int local_14;\n  int local_10;\n  \n  local_14 = 7;\n  local_10 = 0;\n  do {\n    if (0xff < local_10) {\n      return 0;\n    }\n    if (*(int *)(&DAT_0001a1e4 + local_10 * 8) == 0) {\n      if (DAT_0001a0c8 <= (uint)(local_10 << 0xc)) {\n        return 0;\n      }\n      iVar1 = allocate(0x1000,0,&DAT_0001a1e4 + local_10 * 8);\n      if (iVar1 != 0) {\n        puts(\"Failed to allocate data blocks\\n\");\n        return 0;\n      }\n      bzero(*(void **)(&DAT_0001a1e4 + local_10 * 8),0x1000);\n    }\n    if ((&free_list)[local_10 * 8] != -1) {\n      local_15 = (&free_list)[local_10 * 8];\n      for (; ((local_15 & 1) != 0 && (local_14 != 0)); local_14 = local_14 + -1) {\n        local_15 = local_15 >> 1;\n      }\n      (&free_list)[local_10 * 8] =\n           (byte)(0x80 >> ((byte)local_14 & 0x1f)) | (&free_list)[local_10 * 8];\n      return *(int *)(&DAT_0001a1e4 + local_10 * 8) + local_14 * 0x200;\n    }\n    local_10 = local_10 + 1;\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "FindFreeDataBlock",
                        "allocate",
                        "puts",
                        "bzero"
                    ],
                    "calling_functions": [
                        "FindFreeDataBlock",
                        "CreateFile",
                        "mkdir",
                        "fwrite"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "SplitPath",
                "func_c_signature": "undefined4 SplitPath(char *param_1,char *param_2,char *param_3)",
                "decompiled_code": "undefined4 SplitPath(char *param_1,char *param_2,char *param_3) {\n  size_t local_10;\n  \n  if (((param_1 != (char *)0x0) && (param_2 != (char *)0x0)) && (param_3 != (char *)0x0)) {\n    strcpy(param_2,param_1);\n    for (local_10 = strlen(param_2); 0 < (int)local_10; local_10 = local_10 - 1) {\n      if (param_2[local_10] == '/') {\n        strcpy(param_3,param_2 + local_10 + 1);\n        param_2[local_10] = '\\0';\n        break;\n      }\n    }\n    if (local_10 == 0) {\n      strcpy(param_3,param_1 + 1);\n      param_2[1] = '\\0';\n    }\n  }\n  return 0;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "SplitPath",
                        "strcpy",
                        "strlen"
                    ],
                    "calling_functions": [
                        "SplitPath",
                        "CreateFile",
                        "mkdir",
                        "rmdir",
                        "unlink"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "CreateFile",
                "func_c_signature": "char * CreateFile(int param_1,char *param_2)",
                "decompiled_code": "char * CreateFile(int param_1,char *param_2) {\n  char *__s;\n  size_t sVar1;\n  int iVar2;\n  char local_240 [256];\n  undefined local_140 [256];\n  int local_40;\n  undefined4 local_3c;\n  char *local_38;\n  size_t local_34;\n  void *local_30;\n  int local_2c;\n  char *local_28;\n  char *local_24;\n  char *local_20;\n  uint local_1c;\n  uint local_18;\n  int local_14;\n  uint local_10;\n  \n  local_3c = 0;\n  local_40 = 0;\n  local_20 = (char *)0x0;\n  local_24 = (char *)0x0;\n  if ((param_1 == 0) || (param_2 == (char *)0x0)) {\n    local_24 = (char *)0x0;\n  }\n  else {\n    bzero(local_140,0x100);\n    bzero(local_240,0x100);\n    sVar1 = strlen(local_240);\n    if (sVar1 < 0xd0) {\n      local_10 = CheckFileExists(param_1,&local_3c);\n      if (local_10 == -1) {\n        local_24 = (char *)0x0;\n      }\n      else if (local_10 == 1) {\n        puts(\"file exists\");\n        local_24 = (char *)0x0;\n      }\n      else {\n        SplitPath(param_1,local_140,local_240);\n        iVar2 = CheckFileExists(local_140,&local_40);\n        if (iVar2 == 2) {\n          sVar1 = strlen(param_2);\n          local_18 = sVar1 / DAT_0001a0c4;\n          sVar1 = strlen(param_2);\n          if (sVar1 % DAT_0001a0c4 != 0) {\n            local_18 = local_18 + 1;\n          }\n          if (local_18 == 0) {\n            local_18 = 1;\n          }\n          local_1c = local_18 >> 3;\n          if ((local_18 & 7) != 0) {\n            local_1c = local_1c + 1;\n          }\n          for (local_10 = 0; local_10 < local_1c; local_10 = local_10 + 1) {\n            local_38 = (char *)FindFreeInode();\n            if (local_38 == (char *)0x0) {\n              puts(\"out of inodes\");\n              return (char *)0x0;\n            }\n            if (local_10 == 0) {\n              local_24 = local_38;\n            }\n            *(undefined4 *)(local_38 + 0xd0) = 1;\n            sVar1 = strlen(param_2);\n            *(size_t *)(local_38 + 0xd4) = sVar1;\n            *(uint *)(local_38 + 0xd8) = local_18;\n            if (local_20 != (char *)0x0) {\n              *(char **)(local_20 + 0xdc) = local_38;\n            }\n            local_20 = local_38;\n            strncpy(local_38,local_240,0xcf);\n          }\n          local_28 = local_24;\n          local_14 = 0;\n          for (local_10 = 0; local_10 < local_18; local_10 = local_10 + 1) {\n            local_30 = (void *)FindFreeDataBlock();\n            if (local_30 == (void *)0x0) {\n              puts(\"out of space\");\n              while (__s = local_28, local_28 != (char *)0x0) {\n                local_20 = local_28;\n                local_28 = *(char **)(local_28 + 0xdc);\n                bzero(__s,0x100);\n              }\n              return (char *)0x0;\n            }\n            if ((local_10 != 0) && ((local_10 & 7) == 0)) {\n              local_28 = *(char **)(local_28 + 0xdc);\n              local_14 = 0;\n            }\n            *(void **)(local_28 + (local_14 + 0x38) * 4) = local_30;\n            local_34 = strlen(param_2 + local_10 * 0x200);\n            sVar1 = local_34;\n            if (0x200 < (int)local_34) {\n              sVar1 = 0x200;\n            }\n            memcpy(local_30,param_2 + local_10 * 0x200,sVar1);\n            local_14 = local_14 + 1;\n          }\n          local_2c = *(int *)(local_40 + 0xe0);\n          for (local_10 = 0; (int)local_10 < 0x80; local_10 = local_10 + 1) {\n            if (*(int *)(local_2c + local_10 * 4) == 0) {\n              *(char **)(local_2c + local_10 * 4) = local_24;\n              if (*(uint *)(local_40 + 0xd4) < (local_10 + 1) * 4) {\n                *(uint *)(local_40 + 0xd4) = (local_10 + 1) * 4;\n              }\n              break;\n            }\n          }\n          if (local_10 == 0x80) {\n            local_28 = local_24;\n            while (local_28 != (char *)0x0) {\n              local_20 = local_28;\n              local_28 = *(char **)(local_28 + 0xdc);\n              for (local_14 = 0; local_14 < 8; local_14 = local_14 + 1) {\n                FreeDataBlock(*(undefined4 *)(local_20 + (local_14 + 0x38) * 4));\n              }\n              bzero(local_20,0x100);\n            }\n            puts(\"directory is full\");\n            local_24 = (char *)0x0;\n          }\n          else {\n            puts(\"file created\");\n          }\n        }\n        else {\n          puts(\"directory doesn\\'t exist\");\n          local_24 = (char *)0x0;\n        }\n      }\n    }\n    else {\n      puts(\"file name too large\");\n      local_24 = (char *)0x0;\n    }\n  }\n  return local_24;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "CreateFile",
                        "bzero",
                        "strlen",
                        "CheckFileExists",
                        "puts",
                        "SplitPath",
                        "FindFreeInode",
                        "strncpy",
                        "FindFreeDataBlock",
                        "memcpy",
                        "FreeDataBlock"
                    ],
                    "calling_functions": [
                        "CreateFile",
                        "fopen"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "ReadFile",
                "func_c_signature": "undefined4 ReadFile(undefined4 param_1)",
                "decompiled_code": "undefined4 ReadFile(undefined4 param_1) {\n  undefined4 uVar1;\n  size_t in_stack_fffffdcc;\n  int local_20;\n  int local_1c;\n  void *local_18;\n  int local_14;\n  uint local_10;\n  \n  local_20 = 0;\n  local_10 = CheckFileExists(param_1,&local_20);\n  if (local_10 == -1) {\n    uVar1 = 1;\n  }\n  else if (local_10 == 0) {\n    puts(\"file doesn\\'t exist\");\n    uVar1 = 1;\n  }\n  else if (local_10 == 2) {\n    puts(\"file is a directory\");\n    uVar1 = 1;\n  }\n  else {\n    local_14 = 0;\n    local_18 = *(void **)(local_20 + 0xd4);\n    for (local_10 = 0; local_10 < *(uint *)(local_20 + 0xd8); local_10 = local_10 + 1) {\n      if ((local_10 != 0) && ((local_10 & 7) == 0)) {\n        local_20 = *(int *)(local_20 + 0xdc);\n        if (local_20 == 0) {\n          return 0;\n        }\n        local_14 = 0;\n      }\n      local_1c = *(int *)(local_20 + (local_14 + 0x38) * 4);\n      if (local_1c == 0) {\n        return 0;\n      }\n      if (local_18 < (void *)0x200) {\n        write(local_1c,local_18,in_stack_fffffdcc);\n      }\n      else {\n        write(local_1c,(void *)0x200,in_stack_fffffdcc);\n        local_18 = (void *)((int)local_18 + -0x200);\n      }\n      local_14 = local_14 + 1;\n    }\n    puts(\"\");\n    uVar1 = 0;\n  }\n  return uVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "ReadFile",
                        "CheckFileExists",
                        "puts",
                        "write"
                    ],
                    "calling_functions": [
                        "CatHandler",
                        "ReadFile"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "mkdir",
                "func_c_signature": "int mkdir(char *__path,__mode_t __mode)",
                "decompiled_code": "int mkdir(char *__path,__mode_t __mode) {\n  int iVar1;\n  size_t sVar2;\n  char local_22c [256];\n  undefined local_12c [256];\n  int local_2c;\n  undefined local_28 [4];\n  char *local_24;\n  int local_20;\n  int local_1c;\n  int local_18;\n  char *local_14;\n  int local_10;\n  \n  if (__path == (char *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    bzero(local_12c,0x100);\n    bzero(local_22c,0x100);\n    local_10 = CheckFileExists(__path,local_28);\n    if (local_10 == -1) {\n      iVar1 = -1;\n    }\n    else if (local_10 == 1) {\n      puts(\"file exists\");\n      iVar1 = -1;\n    }\n    else if (local_10 == 2) {\n      puts(\"directory exists\");\n      iVar1 = -1;\n    }\n    else {\n      SplitPath(__path,local_12c,local_22c);\n      sVar2 = strlen(local_22c);\n      if (sVar2 < 0xd0) {\n        iVar1 = CheckFileExists(local_12c,&local_2c);\n        if (iVar1 == 2) {\n          local_1c = FindFreeDataBlock();\n          if (local_1c == 0) {\n            puts(\"out of space\");\n            iVar1 = -1;\n          }\n          else {\n            local_14 = (char *)FindFreeInode();\n            if (local_14 == (char *)0x0) {\n              puts(\"out of inodes\");\n              iVar1 = -1;\n            }\n            else {\n              *(undefined4 *)(local_14 + 0xd0) = 2;\n              *(undefined4 *)(local_14 + 0xd4) = 0;\n              *(undefined4 *)(local_14 + 0xd8) = 1;\n              *(undefined4 *)(local_14 + 0xdc) = 0;\n              strncpy(local_14,local_22c,0xcf);\n              *(int *)(local_14 + 0xe0) = local_1c;\n              local_20 = *(int *)(local_2c + 0xe0);\n              for (local_10 = 0; local_10 < 0x81; local_10 = local_10 + 1) {\n                if (*(int *)(local_20 + local_10 * 4) == 0) {\n                  *(char **)(local_20 + local_10 * 4) = local_14;\n                  if (*(uint *)(local_2c + 0xd4) < (uint)((local_10 + 1) * 4)) {\n                    *(int *)(local_2c + 0xd4) = (local_10 + 1) * 4;\n                  }\n                  break;\n                }\n              }\n              if (local_10 < 0x81) {\n                puts(\"directory created\");\n                iVar1 = 0;\n              }\n              else {\n                while (local_14 != (char *)0x0) {\n                  local_24 = local_14;\n                  local_14 = *(char **)(local_14 + 0xdc);\n                  for (local_18 = 0; local_18 < 8; local_18 = local_18 + 1) {\n                    FreeDataBlock(*(undefined4 *)(local_24 + (local_18 + 0x38) * 4));\n                  }\n                  bzero(local_24,0x100);\n                }\n                puts(\"directory is full\");\n                iVar1 = -1;\n              }\n            }\n          }\n        }\n        else {\n          puts(\"parent directory doesn\\'t exist\");\n          iVar1 = -1;\n        }\n      }\n      else {\n        puts(\"file name too large\");\n        iVar1 = -1;\n      }\n    }\n  }\n  return iVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "mkdir",
                        "bzero",
                        "CheckFileExists",
                        "puts",
                        "SplitPath",
                        "strlen",
                        "FindFreeDataBlock",
                        "FindFreeInode",
                        "strncpy",
                        "FreeDataBlock"
                    ],
                    "calling_functions": [
                        "ExitHandler",
                        "MkdirHandler",
                        "mkdir"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "rmdir",
                "func_c_signature": "int rmdir(char *__path)",
                "decompiled_code": "int rmdir(char *__path) {\n  int iVar1;\n  undefined local_228 [256];\n  undefined local_128 [256];\n  int local_28;\n  void *local_24;\n  void *local_20;\n  int local_1c;\n  void *local_18;\n  int local_14;\n  uint local_10;\n  \n  if (__path == (char *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    bzero(local_128,0x100);\n    bzero(local_228,0x100);\n    local_10 = CheckFileExists(__path,&local_24);\n    if ((local_10 == 0) || (local_10 == -1)) {\n      puts(\"directory does not exist\");\n      iVar1 = -1;\n    }\n    else if (*(int *)((int)local_24 + 0xd0) == 2) {\n      iVar1 = strcmp(__path,\"/\");\n      if (iVar1 == 0) {\n        puts(\"unable to remove /\");\n        iVar1 = -1;\n      }\n      else {\n        local_1c = *(int *)((int)local_24 + 0xe0);\n        for (local_10 = 0; (int)local_10 < 0x80; local_10 = local_10 + 1) {\n          if (*(int *)(local_1c + local_10 * 4) != 0) {\n            puts(\"directory not empty\");\n            return -1;\n          }\n        }\n        SplitPath(__path,local_128,local_228);\n        iVar1 = CheckFileExists(local_128,&local_28);\n        if (iVar1 == 2) {\n          local_1c = *(int *)(local_28 + 0xe0);\n          for (local_10 = 0; (int)local_10 < 0x80; local_10 = local_10 + 1) {\n            if (*(void **)(local_1c + local_10 * 4) == local_24) {\n              *(undefined4 *)(local_1c + local_10 * 4) = 0;\n              if ((local_10 + 1) * 4 == *(int *)(local_28 + 0xd4)) {\n                *(uint *)(local_28 + 0xd4) = local_10 * 4;\n              }\n              break;\n            }\n          }\n          if (local_10 == 0x80) {\n            puts(\n                \"parent directory doesn\\'t have an entry for this directory...file system corruption detected\"\n                );\n            iVar1 = 1;\n          }\n          else {\n            local_14 = 0;\n            local_18 = local_24;\n            for (local_10 = 0; local_10 < *(uint *)((int)local_18 + 0xd8); local_10 = local_10 + 1)\n            {\n              if ((local_10 != 0) && ((local_10 & 7) == 0)) {\n                local_20 = *(void **)((int)local_18 + 0xdc);\n                bzero(local_18,0x100);\n                local_18 = local_20;\n                local_14 = 0;\n                if (local_20 == (void *)0x0) break;\n              }\n              if (*(int *)((int)local_18 + (local_14 + 0x38) * 4) != 0) {\n                FreeDataBlock(*(undefined4 *)((int)local_18 + (local_14 + 0x38) * 4));\n              }\n              local_14 = local_14 + 1;\n            }\n            bzero(local_24,0x100);\n            puts(\"directory removed\");\n            iVar1 = 0;\n          }\n        }\n        else {\n          puts(\"parent directory doesn\\'t exist...file system corruption detected\");\n          iVar1 = 1;\n        }\n      }\n    }\n    else {\n      puts(\"not a directory\");\n      iVar1 = -1;\n    }\n  }\n  return iVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "rmdir",
                        "bzero",
                        "CheckFileExists",
                        "puts",
                        "strcmp",
                        "SplitPath",
                        "FreeDataBlock"
                    ],
                    "calling_functions": [
                        "RmdirHandler",
                        "rmdir"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "FreeDataBlock",
                "func_c_signature": "bool FreeDataBlock(uint param_1)",
                "decompiled_code": "bool FreeDataBlock(uint param_1) {\n  int iVar1;\n  int local_14;\n  int local_10;\n  \n  if (param_1 == 0) {\n    return true;\n  }\n  for (local_10 = 0; local_10 < 0x100; local_10 = local_10 + 1) {\n    iVar1 = local_10 * 8;\n    if ((*(uint *)(&DAT_0001a1e4 + iVar1) <= param_1) &&\n       (param_1 <= *(int *)(&DAT_0001a1e4 + iVar1) + 0xe00U)) {\n      local_14 = 0;\n      goto LAB_0001365b;\n    }\n  }\nLAB_00013694:\n  if (local_10 == 0x100) {\n    puts(\"unable to free block\");\n  }\n  return local_10 == 0x100;\nLAB_0001365b:\n  if (7 < local_14) goto LAB_00013661;\n  if (param_1 == *(int *)(&DAT_0001a1e4 + iVar1) + local_14 * 0x200) {\n    (&free_list)[iVar1] = (byte)(0x80 >> ((byte)local_14 & 0x1f)) ^ (&free_list)[iVar1];\n    bzero((void *)(*(int *)(&DAT_0001a1e4 + iVar1) + local_14 * 0x200),0x200);\n    goto LAB_00013661;\n  }\n  local_14 = local_14 + 1;\n  goto LAB_0001365b;\nLAB_00013661:\n  if (local_14 == 8) {\n    puts(\"unable to free block\");\n    return true;\n  }\n  goto LAB_00013694;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "FreeDataBlock",
                        "puts",
                        "bzero"
                    ],
                    "calling_functions": [
                        "CreateFile",
                        "mkdir",
                        "rmdir",
                        "FreeDataBlock",
                        "unlink",
                        "fopen"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "unlink",
                "func_c_signature": "int unlink(char *__name)",
                "decompiled_code": "int unlink(char *__name) {\n  int iVar1;\n  undefined local_228 [256];\n  undefined local_128 [256];\n  int local_28;\n  void *local_24;\n  int local_20;\n  void *local_1c;\n  void *local_18;\n  int local_14;\n  uint local_10;\n  \n  bzero(local_128,0x100);\n  bzero(local_228,0x100);\n  local_10 = CheckFileExists(__name,&local_24);\n  if (local_10 == -1) {\n    iVar1 = 1;\n  }\n  else if (local_10 == 0) {\n    puts(\"file doesn\\'t exist\");\n    iVar1 = 1;\n  }\n  else if (local_10 == 2) {\n    puts(\"file is a directory\");\n    iVar1 = 1;\n  }\n  else {\n    SplitPath(__name,local_128,local_228);\n    iVar1 = CheckFileExists(local_128,&local_28);\n    if (iVar1 == 2) {\n      local_14 = 0;\n      local_18 = local_24;\n      for (local_10 = 0; local_10 < *(uint *)((int)local_18 + 0xd8); local_10 = local_10 + 1) {\n        if ((local_10 != 0) && ((local_10 & 7) == 0)) {\n          local_1c = *(void **)((int)local_18 + 0xdc);\n          bzero(local_18,0x100);\n          local_18 = local_1c;\n          local_14 = 0;\n          if (local_1c == (void *)0x0) break;\n        }\n        if (*(int *)((int)local_18 + (local_14 + 0x38) * 4) != 0) {\n          FreeDataBlock(*(undefined4 *)((int)local_18 + (local_14 + 0x38) * 4));\n        }\n        local_14 = local_14 + 1;\n      }\n      local_20 = *(int *)(local_28 + 0xe0);\n      for (local_10 = 0; (int)local_10 < 0x80; local_10 = local_10 + 1) {\n        if (*(void **)(local_20 + local_10 * 4) == local_24) {\n          *(undefined4 *)(local_20 + local_10 * 4) = 0;\n          if ((local_10 + 1) * 4 == *(int *)(local_28 + 0xd4)) {\n            *(uint *)(local_28 + 0xd4) = local_10 * 4;\n          }\n          break;\n        }\n      }\n      bzero(local_24,0x100);\n      puts(\"file removed\");\n      iVar1 = 0;\n    }\n    else {\n      puts(\"parent directory doesn\\'t exist...file system corruption detected\");\n      iVar1 = 1;\n    }\n  }\n  return iVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "unlink",
                        "bzero",
                        "CheckFileExists",
                        "puts",
                        "SplitPath",
                        "FreeDataBlock"
                    ],
                    "calling_functions": [
                        "RmHandler",
                        "unlink"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "fopen",
                "func_c_signature": "FILE * fopen(char *__filename,char *__modes)",
                "decompiled_code": "FILE * fopen(char *__filename,char *__modes) {\n  uint uVar1;\n  int iVar2;\n  FILE *local_24;\n  char *local_20;\n  void *local_1c;\n  void *local_18;\n  uint local_14;\n  int local_10;\n  \n  local_20 = (char *)0x0;\n  if (__filename == (char *)0x0) {\n    local_24 = (FILE *)0x0;\n  }\n  else {\n    local_10 = CheckFileExists(__filename,&local_20);\n    if (local_10 == -1) {\n      local_24 = (FILE *)0x0;\n    }\n    else {\n      if (local_10 == 0) {\n        iVar2 = strcmp(__modes,\"w\");\n        if (iVar2 != 0) {\n          puts(\"file doesn\\'t exist\");\n          return (FILE *)0x0;\n        }\n        local_20 = (char *)CreateFile(__filename,&DAT_00017382);\n        if (local_20 == (char *)0x0) {\n          puts(\"file creation failed\\n\");\n          return (FILE *)0x0;\n        }\n      }\n      else if (local_10 == 2) {\n        puts(\"file is a directory\");\n        return (FILE *)0x0;\n      }\n      iVar2 = allocate(0x18,0,&local_24);\n      if (iVar2 == 0) {\n        bzero(local_24,0x18);\n        local_24->_flags = (int)local_20;\n        iVar2 = strcmp(__modes,\"r\");\n        if (iVar2 == 0) {\n          local_24->_IO_read_ptr = (char *)0x0;\n          local_24->_IO_read_end = (char *)0x0;\n          local_24->_IO_read_base = local_20;\n        }\n        else {\n          iVar2 = strcmp(__modes,\"w\");\n          if (iVar2 == 0) {\n            for (local_10 = 1; local_10 < 8; local_10 = local_10 + 1) {\n              FreeDataBlock(*(undefined4 *)(local_20 + (local_10 + 0x38) * 4));\n              *(undefined4 *)(local_20 + (local_10 + 0x38) * 4) = 0;\n            }\n            local_18 = *(void **)(local_20 + 0xdc);\n            while (local_18 != (void *)0x0) {\n              for (local_10 = 0; local_10 < 8; local_10 = local_10 + 1) {\n                FreeDataBlock(*(undefined4 *)((int)local_18 + (local_10 + 0x38) * 4));\n                *(undefined4 *)((int)local_18 + (local_10 + 0x38) * 4) = 0;\n              }\n              local_1c = *(void **)((int)local_18 + 0xdc);\n              bzero(local_18,0x100);\n              local_18 = local_1c;\n            }\n            bzero(*(void **)(local_20 + 0xe0),0x200);\n            *(undefined4 *)(local_20 + 0xd4) = 0;\n            local_24->_IO_read_ptr = (char *)0x0;\n            local_24->_IO_read_end = (char *)0x1;\n            local_24->_IO_read_base = local_20;\n          }\n          else {\n            iVar2 = strcmp(__modes,\"a\");\n            if (iVar2 == 0) {\n              local_24->_IO_read_ptr = *(char **)(local_20 + 0xd4);\n              local_24->_IO_read_end = (char *)0x2;\n              local_24->_IO_read_base = local_20;\n              uVar1 = *(uint *)(local_20 + 0xd4);\n              local_24->_IO_write_base = (char *)((*(uint *)(local_20 + 0xd4) & 0xfff) >> 9);\n              local_24->_IO_write_ptr = (char *)(*(uint *)(local_20 + 0xd4) & 0x1ff);\n              local_14 = uVar1 >> 0xc;\n              while (local_14 != 0) {\n                local_24->_IO_read_base = *(char **)(local_24->_IO_read_base + 0xdc);\n                local_14 = local_14 - 1;\n              }\n            }\n            else {\n              deallocate(local_24,0x18);\n              local_24 = (FILE *)0x0;\n            }\n          }\n        }\n      }\n      else {\n        puts(\"Failed to allocate FILE struct\\n\");\n        local_24 = (FILE *)0x0;\n      }\n    }\n  }\n  return local_24;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "fopen",
                        "CheckFileExists",
                        "strcmp",
                        "puts",
                        "CreateFile",
                        "allocate",
                        "bzero",
                        "FreeDataBlock",
                        "deallocate"
                    ],
                    "calling_functions": [
                        "EchoHandler",
                        "fopen"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "fread",
                "func_c_signature": "size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream)",
                "decompiled_code": "size_t fread(void *__ptr,size_t __size,size_t __n,FILE *__stream) {\n  char *local_18;\n  int local_14;\n  char *local_10;\n  char *local_c;\n  uint local_8;\n  \n  if ((__ptr == (void *)0x0) || (__stream == (FILE *)0x0)) {\n    local_8 = 0;\n  }\n  else if ((__stream->_IO_read_end == (char *)0x0) && (__stream->_flags != 0)) {\n    local_18 = __stream->_IO_read_base;\n    local_c = __stream->_IO_write_base;\n    local_14 = *(int *)(local_18 + (int)(local_c + 0x38) * 4);\n    local_8 = 0;\n    local_10 = __stream->_IO_write_ptr;\n    while ((local_8 < __size * __n && (__stream->_IO_read_ptr < *(char **)(__stream->_flags + 0xd4))\n           )) {\n      if ((local_10 != (char *)0x0) && (((uint)local_10 & 0x1ff) == 0)) {\n        if ((local_c != (char *)0x0) && (((uint)local_c & 7) == 0)) {\n          local_18 = *(char **)(local_18 + 0xdc);\n          if (local_18 == (char *)0x0) {\n            __stream->_IO_read_base = (char *)0x0;\n            __stream->_IO_write_base = local_c;\n            __stream->_IO_write_ptr = local_10;\n            return local_8;\n          }\n          local_c = (char *)0xffffffff;\n        }\n        local_14 = *(int *)(local_18 + (int)(local_c + 0x39) * 4);\n        if (local_14 == 0) {\n          __stream->_IO_read_base = local_18;\n          __stream->_IO_write_base = local_c + 1;\n          __stream->_IO_write_ptr = local_10;\n          return local_8;\n        }\n        local_10 = (char *)0x0;\n        local_c = local_c + 1;\n      }\n      *(char *)(local_8 + (int)__ptr) = local_10[local_14];\n      __stream->_IO_read_ptr = __stream->_IO_read_ptr + 1;\n      local_8 = local_8 + 1;\n      local_10 = local_10 + 1;\n    }\n    __stream->_IO_read_base = local_18;\n    __stream->_IO_write_base = local_c;\n    __stream->_IO_write_ptr = local_10;\n  }\n  else {\n    local_8 = 0;\n  }\n  return local_8;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "fread"
                    ],
                    "calling_functions": [
                        "fread"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "fwrite",
                "func_c_signature": "size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s)",
                "decompiled_code": "size_t fwrite(void *__ptr,size_t __size,size_t __n,FILE *__s) {\n  char *pcVar1;\n  int local_20;\n  char *local_1c;\n  char *local_18;\n  char *local_14;\n  uint local_10;\n  \n  if ((__ptr == (void *)0x0) || (__s == (FILE *)0x0)) {\n    local_10 = 0;\n  }\n  else if ((__s->_IO_read_end == (char *)0x1) || (__s->_IO_read_end == (char *)0x2)) {\n    local_14 = __s->_IO_read_base;\n    local_18 = __s->_IO_write_base;\n    local_20 = *(int *)(local_14 + (int)(local_18 + 0x38) * 4);\n    local_1c = __s->_IO_write_ptr;\n    for (local_10 = 0; local_10 < __size * __n; local_10 = local_10 + 1) {\n      if ((local_1c != (char *)0x0) && (((uint)local_1c & 0x1ff) == 0)) {\n        local_18 = local_18 + 1;\n        if ((local_18 != (char *)0x0) && (((uint)local_18 & 7) == 0)) {\n          if (*(int *)(local_14 + 0xdc) != 0) {\n            __s->_IO_read_base = local_14;\n            __s->_IO_write_base = local_18;\n            __s->_IO_write_ptr = local_1c;\n            return local_10;\n          }\n          pcVar1 = (char *)FindFreeInode();\n          if (pcVar1 == (char *)0x0) {\n            puts(\"out of inodes\");\n            return 0;\n          }\n          *(undefined4 *)(pcVar1 + 0xd0) = *(undefined4 *)(__s->_flags + 0xd0);\n          *(undefined4 *)(pcVar1 + 0xd4) = *(undefined4 *)(__s->_flags + 0xd4);\n          *(undefined4 *)(pcVar1 + 0xd8) = *(undefined4 *)(__s->_flags + 0xd8);\n          *(undefined4 *)(pcVar1 + 0xdc) = 0;\n          strncpy(pcVar1,(char *)__s->_flags,0xcf);\n          *(char **)(local_14 + 0xdc) = pcVar1;\n          local_18 = (char *)0x0;\n        }\n        local_20 = FindFreeDataBlock();\n        if (local_20 == 0) {\n          puts(\"out of space\");\n          __s->_IO_read_base = local_14;\n          __s->_IO_write_base = local_18;\n          __s->_IO_write_ptr = local_1c;\n          while (local_14 != (char *)0x0) {\n            pcVar1 = *(char **)(local_14 + 0xdc);\n            bzero(local_14,0x100);\n            local_14 = pcVar1;\n          }\n          return local_10;\n        }\n        *(int *)(local_14 + (int)(local_18 + 0x38) * 4) = local_20;\n        local_1c = (char *)0x0;\n        *(int *)(__s->_flags + 0xd8) = *(int *)(__s->_flags + 0xd8) + 1;\n      }\n      local_1c[local_20] = *(char *)(local_10 + (int)__ptr);\n      *(int *)(__s->_flags + 0xd4) = *(int *)(__s->_flags + 0xd4) + 1;\n      __s->_IO_read_ptr = __s->_IO_read_ptr + 1;\n      local_1c = local_1c + 1;\n    }\n    __s->_IO_read_base = local_14;\n    __s->_IO_write_base = local_18;\n    __s->_IO_write_ptr = local_1c;\n  }\n  else {\n    local_10 = 0;\n  }\n  return local_10;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "fwrite",
                        "FindFreeInode",
                        "puts",
                        "strncpy",
                        "FindFreeDataBlock",
                        "bzero"
                    ],
                    "calling_functions": [
                        "EchoHandler",
                        "fwrite"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "fclose",
                "func_c_signature": "int fclose(FILE *__stream)",
                "decompiled_code": "int fclose(FILE *__stream) {\n  int iVar1;\n  \n  if (__stream == (FILE *)0x0) {\n    iVar1 = -1;\n  }\n  else {\n    deallocate(__stream,0x18);\n    iVar1 = 0;\n  }\n  return iVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "fclose",
                        "deallocate"
                    ],
                    "calling_functions": [
                        "EchoHandler",
                        "fclose"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "StatusFS",
                "func_c_signature": "undefined4 StatusFS(void)",
                "decompiled_code": "undefined4 StatusFS(void) {\n  int local_1c;\n  int local_18;\n  int local_14;\n  int local_10;\n  \n  local_18 = 0;\n  local_1c = 0;\n  printf(\"Filesystem info:\\n\");\n  printf(\"  Blocksize: @d\\n\",DAT_0001a0c4);\n  for (local_10 = 0; (local_10 < 0x40 && ((&DAT_0001a0cc)[local_10] != 0)); local_10 = local_10 + 1)\n  {\n    for (local_14 = 0; local_14 < 0x10; local_14 = local_14 + 1) {\n      if (*(int *)((&DAT_0001a0cc)[local_10] + local_14 * 0x100 + 0xd0) != 0) {\n        local_18 = local_18 + 1;\n      }\n    }\n  }\n  printf(\"  Used Inodes: @d/@d\\n\",local_18,0x400);\n  for (local_10 = 0; (local_10 < 0x100 && (*(int *)(&DAT_0001a1e4 + local_10 * 8) != 0));\n      local_10 = local_10 + 1) {\n    for (local_14 = 0; local_14 < 8; local_14 = local_14 + 1) {\n      if (((int)(uint)(byte)(&free_list)[local_10 * 8] >> ((byte)local_14 & 0x1f) & 1U) != 0) {\n        local_1c = local_1c + 1;\n      }\n    }\n  }\n  printf(\"  Used Blocks: @d/@d\\n\",local_1c,DAT_0001a0c8 >> 9);\n  return 0;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "StatusFS",
                        "printf"
                    ],
                    "calling_functions": [
                        "DfHandler",
                        "StatusFS"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "ls",
                "func_c_signature": "undefined4 ls(int param_1)",
                "decompiled_code": "undefined4 ls(int param_1) {\n  undefined4 uVar1;\n  size_t sVar2;\n  char *pcVar3;\n  int local_20;\n  char *local_1c;\n  int local_18;\n  int local_14;\n  int local_10;\n  \n  if (param_1 == 0) {\n    uVar1 = 0xffffffff;\n  }\n  else {\n    local_10 = CheckFileExists(param_1,&local_20);\n    if (local_10 == 0) {\n      puts(\"No such directory\");\n      uVar1 = 0xffffffff;\n    }\n    else if (local_10 == 1) {\n      puts(\"File is not a directory\");\n      uVar1 = 0xffffffff;\n    }\n    else if (local_10 == -1) {\n      uVar1 = 0xffffffff;\n    }\n    else {\n      local_18 = *(int *)(local_20 + 0xe0);\n      if (local_18 == 0) {\n        uVar1 = 0xffffffff;\n      }\n      else {\n        printf(\"Directory listing of @s\\n\",param_1);\n        for (local_10 = 0;\n            (local_10 < 0x80 &&\n            (local_1c = *(char **)(local_18 + local_10 * 4), local_1c != (char *)0x0));\n            local_10 = local_10 + 1) {\n          if (*(int *)(local_1c + 0xd0) == 2) {\n            printf(\"d \",param_1);\n          }\n          else {\n            printf(\"  \",param_1);\n          }\n          pcVar3 = local_1c;\n          printf(\"@s\",local_1c);\n          sVar2 = strlen(local_1c);\n          local_14 = 0x32 - sVar2;\n          while (0 < local_14) {\n            local_14 = local_14 + -1;\n            printf(\" \",pcVar3);\n          }\n          param_1 = *(int *)(local_1c + 0xd4);\n          local_14 = local_14 + -1;\n          printf(\" @d\\n\",param_1);\n        }\n        uVar1 = 0;\n      }\n    }\n  }\n  return uVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "ls",
                        "CheckFileExists",
                        "puts",
                        "printf",
                        "strlen"
                    ],
                    "calling_functions": [
                        "LsHandler",
                        "ls"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            }
        ],
        "service.c": [
            {
                "func_name": "FreeArgs",
                "func_c_signature": "undefined4 FreeArgs(void)",
                "decompiled_code": "undefined4 FreeArgs(void) {\n  size_t sVar1;\n  int local_10;\n  \n  for (local_10 = 0; (&ARGV)[local_10] != 0; local_10 = local_10 + 1) {\n    sVar1 = strlen((char *)(&ARGV)[local_10]);\n    deallocate((&ARGV)[local_10],sVar1);\n    (&ARGV)[local_10] = 0;\n  }\n  return 0;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "FreeArgs",
                        "strlen",
                        "deallocate"
                    ],
                    "calling_functions": [
                        "FreeArgs",
                        "ParseArgs",
                        "main"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "ParseArgs",
                "func_c_signature": "uint ParseArgs(char *param_1)",
                "decompiled_code": "uint ParseArgs(char *param_1) {\n  char **ppcVar1;\n  char cVar2;\n  uint uVar3;\n  char *pcVar4;\n  size_t sVar5;\n  size_t sVar6;\n  int iVar7;\n  char *local_1c;\n  int local_18;\n  char *local_14;\n  int local_10;\n  \n  local_10 = 0;\n  bzero(&ARGV,0x28);\n  ARGC = 0;\n  local_14 = strtok(param_1,\" \");\n  iVar7 = ARGC;\n  if (local_14 == (char *)0x0) {\n    ARGC = 0;\n  }\n  else {\n    ARGC = ARGC + 1;\n    pcVar4 = strdup(local_14);\n    (&ARGV)[iVar7] = pcVar4;\n    while ((local_14 = strtok((char *)0x0,\" \"), local_14 != (char *)0x0 && (ARGC < 9))) {\n      if ((local_10 == 0) || (sVar5 = strlen(local_14), local_14[sVar5 - 1] != '\\\"')) {\n        if (local_10 == 0) {\n          cVar2 = *local_14;\n          sVar5 = strlen(local_14);\n          uVar3 = ARGC;\n          if (local_14[sVar5 - 1] == '\\\"' && cVar2 == '\\\"') {\n            sVar5 = strlen(local_14);\n            local_14[sVar5 - 1] = '\\0';\n            uVar3 = ARGC;\n            ARGC = ARGC + 1;\n            pcVar4 = strdup(local_14 + 1);\n            (&ARGV)[uVar3] = pcVar4;\n          }\n          else if (*local_14 == '\\\"') {\n            local_10 = 1;\n            pcVar4 = strdup(local_14);\n            (&ARGV)[uVar3] = pcVar4;\n          }\n          else {\n            ARGC = ARGC + 1;\n            pcVar4 = strdup(local_14);\n            (&ARGV)[uVar3] = pcVar4;\n          }\n        }\n        else {\n          sVar5 = strlen((char *)(&ARGV)[ARGC]);\n          sVar6 = strlen(local_14);\n          local_18 = sVar6 + sVar5 + 2;\n          iVar7 = allocate(local_18,0,&local_1c);\n          if (iVar7 != 0) {\n            FreeArgs();\n            ARGC = 0;\n            return 0;\n          }\n          strcpy(local_1c,(char *)(&ARGV)[ARGC]);\n          strcat(local_1c,\" \");\n          strcat(local_1c,local_14);\n          sVar5 = strlen((char *)(&ARGV)[ARGC]);\n          deallocate((&ARGV)[ARGC],sVar5);\n          (&ARGV)[ARGC] = local_1c;\n        }\n      }\n      else {\n        sVar5 = strlen((char *)(&ARGV)[ARGC]);\n        sVar6 = strlen(local_14);\n        local_18 = sVar6 + sVar5 + 1;\n        iVar7 = allocate(local_18,0,&local_1c);\n        if (iVar7 != 0) {\n          FreeArgs();\n          ARGC = 0;\n          return 0;\n        }\n        strcpy(local_1c,(char *)((&ARGV)[ARGC] + 1));\n        strcat(local_1c,\" \");\n        sVar5 = strlen(local_14);\n        local_14[sVar5 - 1] = '\\0';\n        strcat(local_1c,local_14);\n        sVar5 = strlen((char *)(&ARGV)[ARGC]);\n        deallocate((&ARGV)[ARGC],sVar5);\n        ppcVar1 = (char **)(&ARGV + ARGC);\n        ARGC = ARGC + 1;\n        *ppcVar1 = local_1c;\n        local_10 = 0;\n      }\n    }\n    if (local_10 == 0) {\n      if (ARGC == 9) {\n        puts(\"too many args\");\n        FreeArgs();\n        ARGC = 0;\n      }\n    }\n    else {\n      puts(\"missing quote\");\n      FreeArgs();\n      ARGC = 0;\n    }\n  }\n  return ARGC;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "ParseArgs",
                        "bzero",
                        "strtok",
                        "strdup",
                        "strlen",
                        "allocate",
                        "FreeArgs",
                        "strcpy",
                        "strcat",
                        "deallocate",
                        "puts"
                    ],
                    "calling_functions": [
                        "ParseArgs",
                        "main"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "undefined4 main(void)",
                "decompiled_code": "undefined4 main(void) {\n  int iVar1;\n  undefined4 uVar2;\n  undefined local_114 [256];\n  undefined **local_14;\n  undefined *local_10;\n  \n  local_10 = &stack0x00000004;\n  bzero(CWD,0x100);\n  strcpy(CWD,\"/\");\n  iVar1 = InitFS(0x80000);\n  if (iVar1 == 0) {\n    puts(\"Welcome to the cgcfs shell!\");\n    puts(\"Type help for a list of available commands.\");\n    printf(\"% \");\n    bzero(local_114,0x100);\n    while( true ) {\n      iVar1 = readUntil(local_114,0xff,10);\n      if (iVar1 == -1) break;\n      ParseArgs(local_114);\n      if (ARGC == 0) {\n        FreeArgs();\n        bzero(local_114,0x100);\n        printf(\"% \");\n      }\n      else {\n        if (ARGV != (char *)0x0) {\n          for (local_14 = &cmds; *local_14 != (char *)0x0; local_14 = local_14 + 3) {\n            iVar1 = strcmp(*local_14,ARGV);\n            if (iVar1 == 0) {\n              (*(code *)local_14[1])();\n              break;\n            }\n          }\n        }\n        if (local_14 == (char **)0x0) {\n          puts(\"Invalid command\");\n        }\n        if (*local_14 == (char *)0x0) {\n          puts(\"Invalid command\");\n        }\n        FreeArgs();\n        bzero(local_114,0x100);\n        printf(\"% \");\n      }\n    }\n    iVar1 = DestroyFS();\n    if (iVar1 == 0) {\n      uVar2 = 0;\n    }\n    else {\n      puts(\"Failed to destroy the RAM file system\\n\");\n      uVar2 = 0xffffffff;\n    }\n  }\n  else {\n    puts(\"Failed to initialize the RAM file system\\n\");\n    uVar2 = 0xffffffff;\n  }\n  return uVar2;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "bzero",
                        "strcpy",
                        "InitFS",
                        "puts",
                        "printf",
                        "readUntil",
                        "ParseArgs",
                        "FreeArgs",
                        "strcmp",
                        "DestroyFS"
                    ],
                    "calling_functions": [
                        "_start",
                        "main"
                    ],
                    "defined_in_file": "CROMU_00009_decompiled.c"
                }
            }
        ]
    }
}