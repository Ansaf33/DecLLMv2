{
    "file": "mv",
    "decompiled_code": {
        "mv.c": [
            {
                "func_name": "rm_option_init",
                "func_c_signature": "void rm_option_init(undefined *param_1)",
                "decompiled_code": "void rm_option_init(undefined *param_1) {\n  undefined8 uVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  \n  *param_1 = 0;\n  param_1[10] = 1;\n  param_1[9] = 1;\n  param_1[8] = 0;\n  *(undefined4 *)(param_1 + 4) = 5;\n  param_1[0x19] = 0;\n  param_1[0x1a] = 0;\n  param_1[0x1b] = 1;\n  uVar1 = get_root_dev_ino(dev_ino_buf_1);\n  *(undefined8 *)(param_1 + 0x10) = uVar1;\n  if (*(long *)(param_1 + 0x10) == 0) {\n    uVar1 = quotearg_style(4,&DAT_00101ae2);\n    uVar2 = gettext(\"failed to get attributes of %s\");\n    piVar3 = __errno_location();\n    error(1,*piVar3,uVar2,uVar1);\n  }\n  param_1[0x18] = 0;\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "rm_option_init",
                        "get_root_dev_ino",
                        "quotearg_style",
                        "gettext",
                        "__errno_location",
                        "error"
                    ],
                    "calling_functions": [
                        "rm_option_init",
                        "do_move"
                    ],
                    "defined_in_file": "mv_decompiled.c"
                }
            },
            {
                "func_name": "cp_option_init",
                "func_c_signature": "void cp_option_init(long param_1)",
                "decompiled_code": "void cp_option_init(long param_1) {\n  int iVar1;\n  \n  cp_options_default(param_1);\n  *(undefined *)(param_1 + 0x14) = 0;\n  *(undefined4 *)(param_1 + 0x4c) = 1;\n  *(undefined4 *)(param_1 + 4) = 2;\n  *(undefined *)(param_1 + 0x15) = 0;\n  *(undefined *)(param_1 + 0x16) = 0;\n  *(undefined *)(param_1 + 0x17) = 0;\n  *(undefined4 *)(param_1 + 8) = 0;\n  *(undefined *)(param_1 + 0x18) = 1;\n  *(undefined *)(param_1 + 0x1b) = 0;\n  *(undefined *)(param_1 + 0x1e) = 0;\n  *(undefined *)(param_1 + 0x1f) = 1;\n  *(undefined *)(param_1 + 0x30) = 1;\n  *(undefined *)(param_1 + 0x20) = 1;\n  *(undefined *)(param_1 + 0x21) = 1;\n  *(undefined *)(param_1 + 0x22) = 0;\n  *(undefined *)(param_1 + 0x33) = 0;\n  *(undefined8 *)(param_1 + 0x28) = 0;\n  *(undefined *)(param_1 + 0x37) = 0;\n  *(undefined *)(param_1 + 0x31) = 1;\n  *(undefined *)(param_1 + 0x32) = 0;\n  *(undefined *)(param_1 + 0x34) = 0;\n  *(undefined *)(param_1 + 0x35) = 1;\n  *(undefined *)(param_1 + 0x36) = 0;\n  *(undefined *)(param_1 + 0x38) = 1;\n  *(undefined4 *)(param_1 + 0xc) = 2;\n  *(undefined *)(param_1 + 0x3a) = 0;\n  *(undefined *)(param_1 + 0x39) = 0;\n  *(undefined4 *)(param_1 + 0x10) = 0;\n  iVar1 = isatty(0);\n  *(bool *)(param_1 + 0x43) = iVar1 != 0;\n  *(undefined *)(param_1 + 0x44) = 0;\n  *(undefined4 *)(param_1 + 0x3c) = 0;\n  *(undefined *)(param_1 + 0x40) = 0;\n  *(undefined8 *)(param_1 + 0x50) = 0;\n  *(undefined8 *)(param_1 + 0x58) = 0;\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "cp_option_init",
                        "cp_options_default",
                        "isatty"
                    ],
                    "calling_functions": [
                        "cp_option_init",
                        "main"
                    ],
                    "defined_in_file": "mv_decompiled.c"
                }
            },
            {
                "func_name": "do_move",
                "func_c_signature": "char do_move(EVP_PKEY_CTX *param_1,EVP_PKEY_CTX *param_2,undefined8 param_3,undefined8 param_4,\n            long param_5)",
                "decompiled_code": "char do_move(EVP_PKEY_CTX *param_1,EVP_PKEY_CTX *param_2,undefined8 param_3,undefined8 param_4,\n            long param_5) {\n  int iVar1;\n  long in_FS_OFFSET;\n  char local_57;\n  char local_56;\n  char local_55;\n  EVP_PKEY_CTX *local_50;\n  undefined local_48 [26];\n  undefined local_2e;\n  EVP_PKEY_CTX *local_28;\n  undefined8 local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = copy(param_1,param_2);\n  local_55 = (char)iVar1;\n  if (local_55 != '\\0') {\n    if (local_57 == '\\0') {\n      local_50 = param_1;\n      if (local_56 != '\\0') {\n        local_50 = (EVP_PKEY_CTX *)0x0;\n      }\n    }\n    else {\n      local_50 = (EVP_PKEY_CTX *)0x0;\n      local_55 = '\\0';\n    }\n    if (local_50 != (EVP_PKEY_CTX *)0x0) {\n      rm_option_init(local_48);\n      local_2e = *(undefined *)(param_5 + 0x40);\n      local_28 = local_50;\n      local_20 = 0;\n      iVar1 = rm(&local_28,local_48);\n      if ((((iVar1 != 2) && (iVar1 != 3)) && (iVar1 != 4)) && (iVar1 != 5)) {\n                    /* WARNING: Subroutine does not return */\n        __assert_fail(\"((status) == RM_OK || (status) == RM_USER_ACCEPTED || (status) == RM_USER_DECLINED || (status) == RM_ERROR)\"\n                      ,\"/workspace/home/aiclub1/B220032CS_Jaefar/fyp/repos/ansaf/coreutils/src/mv.c\"\n                      ,0xf1,\"do_move\");\n      }\n      if (iVar1 == 5) {\n        local_55 = '\\0';\n      }\n    }\n  }\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_55;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "do_move",
                        "copy",
                        "rm_option_init",
                        "rm",
                        "__assert_fail",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "do_move",
                        "main"
                    ],
                    "defined_in_file": "mv_decompiled.c"
                }
            },
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\n                            \"Usage: %s [OPTION]... [-T] SOURCE DEST\\n  or:  %s [OPTION]... SOURCE... DIRECTORY\\n  or:  %s [OPTION]... -t DIRECTORY SOURCE...\\n\"\n                            );\n    printf(pcVar3,uVar2,uVar2,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"Rename SOURCE to DEST, or move SOURCE(s) to DIRECTORY.\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_mandatory_arg_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"      --backup[=CONTROL]       make a backup of each existing destination file\\n  -b                           like --backup but does not accept an argument\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"      --debug                  explain how a file is copied.  Implies -v\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --exchange               exchange source and destination\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -f, --force                  do not prompt before overwriting\\n  -i, --interactive            prompt before overwrite\\n  -n, --no-clobber             do not overwrite an existing file\\nIf you specify more than one of -i, -f, -n, only the final one takes effect.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"      --no-copy                do not copy if renaming fails\\n      --strip-trailing-slashes  remove any trailing slashes from each SOURCE\\n                                 argument\\n  -S, --suffix=SUFFIX          override the usual backup suffix\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -t, --target-directory=DIRECTORY  move all SOURCE arguments into DIRECTORY\\n  -T, --no-target-directory    treat DEST as a normal file\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"      --update[=UPDATE]        control which existing files are updated;\\n                                 UPDATE={all,none,none-fail,older(default)}\\n  -u                           equivalent to --update[=older].  See below\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -v, --verbose                explain what is being done\\n  -Z, --context                set SELinux security context of destination\\n                                 file to default type\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_update_parameters_note();\n    emit_backup_suffix_note();\n    emit_ancillary_info(&DAT_00102271);\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "SOURCE",
                    "older"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "SOURCE",
                        "fputs_unlocked",
                        "emit_mandatory_arg_note",
                        "older",
                        "emit_update_parameters_note",
                        "emit_backup_suffix_note",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "mv_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "void main(int param_1,undefined8 *param_2)",
                "decompiled_code": "void main(int param_1,undefined8 *param_2) {\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  char cVar4;\n  byte bVar5;\n  int iVar6;\n  undefined4 uVar7;\n  long lVar8;\n  undefined8 uVar9;\n  undefined8 uVar10;\n  undefined8 uVar11;\n  int *piVar12;\n  long in_FS_OFFSET;\n  byte local_211;\n  int local_20c;\n  undefined4 local_208;\n  int local_204;\n  int local_200;\n  undefined8 local_1a8;\n  long local_1a0;\n  long local_198;\n  long local_190;\n  undefined8 *local_188;\n  long local_180;\n  undefined8 local_178;\n  undefined8 local_170;\n  void *local_168;\n  undefined8 local_160;\n  undefined8 local_150;\n  undefined8 local_148;\n  undefined8 local_140;\n  undefined8 local_138;\n  undefined8 local_130;\n  undefined8 local_128;\n  undefined8 local_120;\n  undefined4 local_118 [2];\n  int local_110;\n  undefined local_ff;\n  char local_fe;\n  int local_dc;\n  undefined local_d8;\n  undefined local_d6;\n  undefined local_d3;\n  int local_d0;\n  undefined local_b8 [24];\n  undefined4 local_a0;\n  undefined8 local_20;\n  \n  local_20 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  bVar3 = false;\n  local_1a0 = 0;\n  local_198 = 0;\n  bVar2 = false;\n  local_190 = 0;\n  bVar1 = false;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit((__func *)&close_stdin);\n  cp_option_init(local_118);\n  priv_set_remove_linkdir();\n  while (iVar6 = getopt_long(param_1,param_2,\"bfint:uvS:TZ\",long_options,0), iVar6 != -1) {\n    if (iVar6 < 0x84) {\n      if (iVar6 < 0x53) {\n        if (iVar6 == -0x83) {\nLAB_00100c6b:\n          uVar10 = proper_name_lite(\"Jim Meyering\",\"Jim Meyering\");\n          uVar11 = proper_name_lite(\"David MacKenzie\",\"David MacKenzie\");\n          uVar9 = proper_name_lite(\"Mike Parker\",\"Mike Parker\");\n          version_etc(_stdout,&DAT_00102271,\"GNU coreutils\",_Version,uVar9,uVar11,uVar10,0);\n                    /* WARNING: Subroutine does not return */\n          exit(0);\n        }\n        if (iVar6 == -0x82) {\n          usage(0);\n          goto LAB_00100c6b;\n        }\n        goto switchD_00100a1e_caseD_55;\n      }\n      switch(iVar6) {\n      case 0x53:\n        bVar3 = true;\n        local_1a0 = _optarg;\n        break;\n      case 0x54:\n        bVar1 = true;\n        break;\n      default:\n        goto switchD_00100a1e_caseD_55;\n      case 0x5a:\n        break;\n      case 0x62:\n        bVar3 = true;\n        if (_optarg != 0) {\n          local_198 = _optarg;\n        }\n        break;\n      case 0x66:\n        local_110 = 1;\n        break;\n      case 0x69:\n        local_110 = 3;\n        break;\n      case 0x6e:\n        local_110 = 2;\n        break;\n      case 0x74:\n        if (local_190 != 0) {\n          local_160 = gettext(\"multiple target directories specified\");\n          error(1,0,local_160);\n        }\n        local_190 = _optarg;\n        break;\n      case 0x75:\n        local_dc = 1;\n        if (_optarg != 0) {\n          lVar8 = __xargmatch_internal\n                            (\"--update\",_optarg,update_type_string,update_type,4,_argmatch_die,1);\n          local_dc = *(int *)(update_type + lVar8 * 4);\n        }\n        break;\n      case 0x76:\n        local_d8 = 1;\n        break;\n      case 0x80:\n        local_d8 = 1;\n        local_d6 = 1;\n        break;\n      case 0x81:\n        local_fe = '\\x01';\n        break;\n      case 0x82:\n        local_ff = 1;\n        break;\n      case 0x83:\n        bVar2 = true;\n      }\n    }\n    else {\nswitchD_00100a1e_caseD_55:\n      usage(1);\n    }\n  }\n  local_20c = param_1 - _optind;\n  local_188 = param_2 + _optind;\n  if (local_20c <= (int)(uint)(local_190 == 0)) {\n    if (local_20c < 1) {\n      local_150 = gettext(\"missing file operand\");\n      error(0,0,local_150);\n    }\n    else {\n      uVar10 = quotearg_style(4,*local_188);\n      local_148 = gettext(\"missing destination file operand after %s\");\n      error(0,0,local_148,uVar10);\n    }\n    usage(1);\n  }\n  local_a0 = 0;\n  local_208 = 0xffffff9c;\n  if (bVar1) {\n    if (local_190 != 0) {\n      local_140 = gettext(\"cannot combine --target-directory (-t) and --no-target-directory (-T)\");\n      error(1,0,local_140);\n    }\n    if (local_20c < 3) goto LAB_00101175;\n    uVar10 = quotearg_style(4,local_188[2]);\n    local_138 = gettext(\"extra operand %s\");\n    error(0,0,local_138,uVar10);\n    usage(1);\n  }\n  if (local_190 != 0) {\n    local_208 = target_directory_operand(local_190,local_b8);\n    cVar4 = target_dirfd_valid(local_208);\n    if (cVar4 == '\\x01') goto LAB_00101175;\n    uVar10 = quotearg_style(4,local_190);\n    uVar11 = gettext(\"target directory %s\");\n    piVar12 = __errno_location();\n    local_130 = uVar11;\n    error(1,*piVar12,uVar11,uVar10);\n  }\n  local_180 = local_188[(long)local_20c + -1];\n  if ((local_20c == 2) && (local_fe != '\\x01')) {\n    iVar6 = renameatu(0xffffff9c,*local_188,0xffffff9c,local_180,1);\n    if (iVar6 == 0) {\n      local_d0 = 0;\n    }\n    else {\n      piVar12 = __errno_location();\n      local_d0 = *piVar12;\n    }\n  }\n  if (local_d0 != 0) {\n    uVar7 = target_directory_operand(local_180,local_b8);\n    cVar4 = target_dirfd_valid(uVar7);\n    if (cVar4 == '\\0') {\n      piVar12 = __errno_location();\n      iVar6 = *piVar12;\n      if (2 < local_20c) {\n        uVar10 = quotearg_style(4,local_180);\n        local_128 = gettext(\"target %s\");\n        error(1,iVar6,local_128,uVar10);\n      }\n    }\n    else {\n      local_d0 = -1;\n      local_190 = local_180;\n      local_20c = local_20c + -1;\n      local_208 = uVar7;\n    }\n  }\nLAB_00101175:\n  if (bVar2) {\n    for (local_204 = 0; local_204 < local_20c; local_204 = local_204 + 1) {\n      strip_trailing_slashes(local_188[local_204]);\n    }\n  }\n  if (local_110 == 2) {\n    local_dc = 2;\n  }\n  if ((bVar3) && (((local_fe != '\\0' || (local_dc == 2)) || (local_dc == 3)))) {\n    local_120 = gettext(\"cannot combine --backup with --exchange, -n, or --update=none-fail\");\n    error(0,0,local_120);\n    usage(1);\n  }\n  if (bVar3) {\n    uVar10 = gettext(\"backup type\");\n    local_118[0] = xget_version(uVar10,local_198);\n  }\n  else {\n    local_118[0] = 0;\n  }\n  set_simple_backup_suffix(local_1a0);\n  hash_init();\n  if (local_190 == 0) {\n    local_d3 = 1;\n    local_211 = do_move(*local_188,local_188[1],0xffffff9c,local_188[1],local_118);\n  }\n  else {\n    if (1 < local_20c) {\n      dest_info_init(local_118);\n    }\n    local_211 = true;\n    for (local_200 = 0; local_200 < local_20c; local_200 = local_200 + 1) {\n      local_d3 = local_20c == local_200 + 1;\n      local_178 = local_188[local_200];\n      local_170 = last_component(local_178);\n      local_168 = (void *)file_name_concat(local_190,local_170,&local_1a8);\n      strip_trailing_slashes(local_1a8);\n      bVar5 = do_move(local_178,local_168,local_208,local_1a8,local_118);\n      local_211 = (bVar5 & local_211) != 0;\n      free(local_168);\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  exit((uint)(local_211 ^ 1));\n}",
                "globals": [],
                "externs": [
                    "directory"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "cp_option_init",
                        "priv_set_remove_linkdir",
                        "getopt_long",
                        "proper_name_lite",
                        "version_etc",
                        "exit",
                        "usage",
                        "gettext",
                        "error",
                        "__xargmatch_internal",
                        "quotearg_style",
                        "directory",
                        "target_directory_operand",
                        "target_dirfd_valid",
                        "__errno_location",
                        "renameatu",
                        "strip_trailing_slashes",
                        "xget_version",
                        "set_simple_backup_suffix",
                        "hash_init",
                        "do_move",
                        "dest_info_init",
                        "last_component",
                        "file_name_concat",
                        "free"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "mv_decompiled.c"
                }
            }
        ]
    }
}