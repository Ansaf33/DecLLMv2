{
    "file": "uniq",
    "decompiled_code": {
        "uniq.c": [
            {
                "func_name": "swap_lines",
                "func_c_signature": "void swap_lines(undefined8 *param_1,undefined8 *param_2)",
                "decompiled_code": "void swap_lines(undefined8 *param_1,undefined8 *param_2) {\n  undefined8 uVar1;\n  \n  uVar1 = *param_1;\n  *param_1 = *param_2;\n  *param_2 = uVar1;\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "swap_lines"
                    ],
                    "calling_functions": [
                        "swap_lines",
                        "check_file"
                    ],
                    "defined_in_file": "uniq_decompiled.c"
                }
            },
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\"Usage: %s [OPTION]... [INPUT [OUTPUT]]\\n\");\n    printf(pcVar3,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"Filter adjacent matching lines from INPUT (or standard input),\\nwriting to OUTPUT (or standard output).\\n\\nWith no options, matching lines are merged to the first occurrence.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_mandatory_arg_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -c, --count           prefix lines by the number of occurrences\\n  -d, --repeated        only print duplicate lines, one for each group\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -D                    print all duplicate lines\\n      --all-repeated[=METHOD]  like -D, but allow separating groups\\n                                 with an empty line;\\n                                 METHOD={none(default),prepend,separate}\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"  -f, --skip-fields=N   avoid comparing the first N fields\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"      --group[=METHOD]  show all items, separating groups with an empty line;\\n                          METHOD={separate(default),prepend,append,both}\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -i, --ignore-case     ignore differences in case when comparing\\n  -s, --skip-chars=N    avoid comparing the first N characters\\n  -u, --unique          only print unique lines\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"  -z, --zero-terminated     line delimiter is NUL, not newline\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"  -w, --check-chars=N   compare no more than N characters in lines\\n\")\n    ;\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nA field is a run of blanks (usually spaces and/or TABs), then non-blank\\ncharacters.  Fields are skipped before chars.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\n\\'uniq\\' does not detect repeated lines unless they are adjacent.\\nYou may want to sort the input first, or use \\'sort -u\\' without \\'uniq\\'.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_ancillary_info(&DAT_001020e9);\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "INPUT",
                    "OUTPUT",
                    "none",
                    "separate",
                    "blanks"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "INPUT",
                        "OUTPUT",
                        "fputs_unlocked",
                        "emit_mandatory_arg_note",
                        "none",
                        "separate",
                        "blanks",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "uniq_decompiled.c"
                }
            },
            {
                "func_name": "strict_posix2",
                "func_c_signature": "undefined4 strict_posix2(void)",
                "decompiled_code": "undefined4 strict_posix2(void) {\n  int iVar1;\n  undefined4 uVar2;\n  \n  iVar1 = posix2_version();\n  if ((iVar1 < 0x30db0) || (0x31068 < iVar1)) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "strict_posix2",
                        "posix2_version"
                    ],
                    "calling_functions": [
                        "strict_posix2",
                        "main"
                    ],
                    "defined_in_file": "uniq_decompiled.c"
                }
            },
            {
                "func_name": "size_opt",
                "func_c_signature": "long size_opt(undefined8 param_1,undefined8 param_2)",
                "decompiled_code": "long size_opt(undefined8 param_1,undefined8 param_2) {\n  uint uVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  long local_20;\n  char *local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  uVar1 = xstrtoimax(param_1,0,10,&local_20,&DAT_001019d4);\n  if ((1 < uVar1) || (local_20 < 0)) {\n    uVar2 = gettext(param_2);\n    local_18 = \"%s: %s\";\n    error(1,0,\"%s: %s\",param_1,uVar2);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_20;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "size_opt",
                        "xstrtoimax",
                        "gettext",
                        "error",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "size_opt",
                        "main"
                    ],
                    "defined_in_file": "uniq_decompiled.c"
                }
            },
            {
                "func_name": "newline_or_blank",
                "func_c_signature": "undefined4 newline_or_blank(int param_1)",
                "decompiled_code": "undefined4 newline_or_blank(int param_1) {\n  int iVar1;\n  \n  if ((param_1 != 10) && (iVar1 = c32isblank(param_1), iVar1 == 0)) {\n    return 0;\n  }\n  return 1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "newline_or_blank",
                        "c32isblank"
                    ],
                    "calling_functions": [
                        "newline_or_blank"
                    ],
                    "defined_in_file": "uniq_decompiled.c"
                }
            },
            {
                "func_name": "find_field",
                "func_c_signature": "ulong find_field(long param_1,long *param_2)",
                "decompiled_code": "ulong find_field(long param_1,long *param_2) {\n  ulong uVar1;\n  undefined8 uVar2;\n  size_t sVar3;\n  ulong uVar4;\n  ulong local_40;\n  long local_38;\n  long local_30;\n  long local_28;\n  ulong local_20;\n  long local_18;\n  \n  local_40 = *(ulong *)(param_1 + 0x10);\n  uVar1 = local_40 + *(long *)(param_1 + 8) + -1;\n  local_38 = skip_fields;\n  while ((0 < local_38 && (local_40 < uVar1))) {\n    uVar2 = skip_buf_matching(local_40,uVar1,newline_or_blank,1);\n    local_40 = skip_buf_matching(uVar2,uVar1,newline_or_blank,0);\n    local_38 = local_38 + -1;\n  }\n  local_30 = skip_chars;\n  for (; (0 < local_30 && (local_40 < uVar1)); local_40 = local_40 + (uVar4 >> 0x28 & 0xff)) {\n    uVar4 = mcel_scan(local_40,uVar1);\n    local_30 = local_30 + -1;\n  }\n  if (check_chars < (long)(uVar1 - local_40)) {\n    sVar3 = __ctype_get_mb_cur_max();\n    if (sVar3 < 2) {\n      local_28 = check_chars;\n    }\n    else {\n      local_20 = local_40;\n      local_18 = check_chars;\n      while ((0 < local_18 && (local_40 < uVar1))) {\n        uVar4 = mcel_scan(local_40,uVar1);\n        local_20 = local_20 + (uVar4 >> 0x28 & 0xff);\n        local_18 = local_18 + -1;\n      }\n      local_28 = local_20 - local_40;\n    }\n  }\n  else {\n    local_28 = uVar1 - local_40;\n  }\n  *param_2 = local_28;\n  return local_40;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "find_field",
                        "skip_buf_matching",
                        "mcel_scan",
                        "__ctype_get_mb_cur_max"
                    ],
                    "calling_functions": [
                        "find_field",
                        "check_file"
                    ],
                    "defined_in_file": "uniq_decompiled.c"
                }
            },
            {
                "func_name": "different",
                "func_c_signature": "undefined4 different(void *param_1,void *param_2,size_t param_3,size_t param_4)",
                "decompiled_code": "undefined4 different(void *param_1,void *param_2,size_t param_3,size_t param_4) {\n  int iVar1;\n  undefined4 uVar2;\n  \n  if (ignore_case == '\\0') {\n    if ((param_3 == param_4) && (iVar1 = memcmp(param_1,param_2,param_3), iVar1 == 0)) {\n      uVar2 = 0;\n    }\n    else {\n      uVar2 = 1;\n    }\n  }\n  else if ((param_3 == param_4) && (iVar1 = memcasecmp(param_1,param_2,param_3), iVar1 == 0)) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = 1;\n  }\n  return uVar2;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "different",
                        "memcmp",
                        "memcasecmp"
                    ],
                    "calling_functions": [
                        "different",
                        "check_file"
                    ],
                    "defined_in_file": "uniq_decompiled.c"
                }
            },
            {
                "func_name": "writeline",
                "func_c_signature": "void writeline(long param_1,char param_2,long param_3)",
                "decompiled_code": "void writeline(long param_1,char param_2,long param_3) {\n  byte bVar1;\n  size_t sVar2;\n  \n  if (param_3 == 0) {\n    bVar1 = output_unique ^ 1;\n  }\n  else if (param_2 == '\\x01') {\n    bVar1 = output_later_repeated ^ 1;\n  }\n  else {\n    bVar1 = output_first_repeated ^ 1;\n  }\n  if (bVar1 == 0) {\n    if (count_occurrences != '\\0') {\n      printf(\"%7jd \",param_3 + 1);\n    }\n    sVar2 = fwrite_unlocked(*(void **)(param_1 + 0x10),1,*(size_t *)(param_1 + 8),_stdout);\n    if (sVar2 != *(size_t *)(param_1 + 8)) {\n      write_error();\n    }\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "writeline",
                        "printf",
                        "fwrite_unlocked",
                        "write_error"
                    ],
                    "calling_functions": [
                        "writeline",
                        "check_file"
                    ],
                    "defined_in_file": "uniq_decompiled.c"
                }
            },
            {
                "func_name": "check_file",
                "func_c_signature": "void check_file(undefined8 param_1,undefined8 param_2,char param_3)",
                "decompiled_code": "void check_file(undefined8 param_1,undefined8 param_2,char param_3) {\n  bool bVar1;\n  char cVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  size_t sVar7;\n  undefined8 uVar8;\n  long in_FS_OFFSET;\n  bool bVar9;\n  undefined *local_c8;\n  undefined *local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  long local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  long local_90;\n  long local_88;\n  undefined8 local_80;\n  undefined *local_78;\n  undefined *local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined local_58 [16];\n  void *local_48;\n  undefined local_38 [16];\n  void *local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  cVar2 = streq(param_1,&DAT_001020fb);\n  if ((cVar2 != '\\x01') && (lVar4 = freopen_safer(param_1,&DAT_001020fd,_stdin), lVar4 == 0)) {\n    uVar5 = quotearg_n_style_colon(0,3,param_1);\n    piVar6 = __errno_location();\n    local_78 = &DAT_001020ff;\n    error(1,*piVar6,&DAT_001020ff,uVar5);\n  }\n  cVar2 = streq(param_2,&DAT_001020fb);\n  if ((cVar2 != '\\x01') && (lVar4 = freopen_safer(param_2,&DAT_00102102,_stdout), lVar4 == 0)) {\n    uVar5 = quotearg_n_style_colon(0,3,param_2);\n    piVar6 = __errno_location();\n    local_70 = &DAT_001020ff;\n    error(1,*piVar6,&DAT_001020ff,uVar5);\n  }\n  fadvise(_stdin,2);\n  local_c8 = local_58;\n  local_c0 = local_38;\n  initbuffer(local_c8);\n  initbuffer(local_c0);\n  if (((output_unique == '\\0') || (output_first_repeated == '\\0')) || (count_occurrences == '\\x01'))\n  {\n    lVar4 = readlinebuffer_delim(local_c0,_stdin,(int)param_3);\n    if (lVar4 != 0) {\n      local_98 = find_field(local_c0,&local_b8);\n      local_90 = 0;\n      bVar1 = true;\n      while (iVar3 = feof_unlocked(_stdin), iVar3 == 0) {\n        lVar4 = readlinebuffer_delim(local_c8,_stdin,(int)param_3);\n        if (lVar4 == 0) {\n          iVar3 = ferror_unlocked(_stdin);\n          if (iVar3 != 0) goto LAB_00100fd9;\n          break;\n        }\n        local_80 = find_field(local_c8,&local_b0);\n        cVar2 = different(local_80,local_98,local_b0,local_b8);\n        bVar9 = cVar2 == '\\0';\n        local_90 = local_90 + (ulong)bVar9;\n        if (local_90 == 0x7fffffffffffffff) {\n          if (count_occurrences != '\\0') {\n            local_68 = gettext(\"too many repeated lines\");\n            error(1,0,local_68);\n          }\n          local_90 = local_90 + -1;\n        }\n        if (delimit_groups != 0) {\n          if (bVar9) {\n            if ((local_90 == 1) && ((delimit_groups == 1 || ((delimit_groups == 2 && (!bVar1)))))) {\n              putchar_unlocked((int)param_3);\n            }\n          }\n          else if (local_90 != 0) {\n            bVar1 = false;\n          }\n        }\n        if ((!bVar9) || (output_later_repeated != '\\0')) {\n          writeline(local_c0,bVar9,local_90);\n          swap_lines(&local_c0,&local_c8);\n          local_98 = local_80;\n          local_b8 = local_b0;\n          if (!bVar9) {\n            local_90 = 0;\n          }\n        }\n      }\n      writeline(local_c0,0,local_90);\n    }\n  }\n  else {\n    local_a8 = 0;\n    bVar1 = false;\n    while ((iVar3 = feof_unlocked(_stdin), iVar3 == 0 &&\n           (lVar4 = readlinebuffer_delim(local_c8,_stdin,(int)param_3), lVar4 != 0))) {\n      local_88 = find_field(local_c8,&local_b0);\n      if ((local_a8 == 0) || (cVar2 = different(local_88,local_a8,local_b0,local_a0), cVar2 != '\\0')\n         ) {\n        bVar9 = true;\n      }\n      else {\n        bVar9 = false;\n      }\n      if (((bVar9) && (grouping != 0)) &&\n         (((grouping == 1 || (grouping == 4)) || ((bVar1 && ((grouping == 2 || (grouping == 3)))))))\n         ) {\n        putchar_unlocked((int)param_3);\n      }\n      if ((bVar9) || (grouping != 0)) {\n        sVar7 = fwrite_unlocked(*(void **)(local_c8 + 0x10),1,*(size_t *)(local_c8 + 8),_stdout);\n        if (sVar7 != *(size_t *)(local_c8 + 8)) {\n          write_error();\n        }\n        swap_lines(&local_c0,&local_c8);\n        local_a8 = local_88;\n        local_a0 = local_b0;\n        bVar1 = true;\n      }\n    }\n    if (((grouping == 4) || (grouping == 2)) && (bVar1)) {\n      putchar_unlocked((int)param_3);\n    }\n  }\nLAB_00100fd9:\n  iVar3 = ferror_unlocked(_stdin);\n  if ((iVar3 != 0) || (iVar3 = rpl_fclose(_stdin), iVar3 != 0)) {\n    uVar5 = quotearg_style(4,param_1);\n    uVar8 = gettext(\"error reading %s\");\n    piVar6 = __errno_location();\n    local_60 = uVar8;\n    error(1,*piVar6,uVar8,uVar5);\n  }\n  free(local_48);\n  free(local_28);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "check_file",
                        "streq",
                        "freopen_safer",
                        "quotearg_n_style_colon",
                        "__errno_location",
                        "error",
                        "fadvise",
                        "initbuffer",
                        "readlinebuffer_delim",
                        "find_field",
                        "feof_unlocked",
                        "ferror_unlocked",
                        "different",
                        "gettext",
                        "putchar_unlocked",
                        "writeline",
                        "swap_lines",
                        "fwrite_unlocked",
                        "write_error",
                        "rpl_fclose",
                        "quotearg_style",
                        "free",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "check_file",
                        "main"
                    ],
                    "defined_in_file": "uniq_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "undefined8 main(int param_1,undefined8 *param_2)",
                "decompiled_code": "undefined8 main(int param_1,undefined8 *param_2) {\n  bool bVar1;\n  char cVar2;\n  uint uVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  long lVar6;\n  undefined8 uVar7;\n  long in_FS_OFFSET;\n  undefined local_9f;\n  int local_9c;\n  int local_98;\n  int local_94;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  char *local_38 [3];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_9c = 0;\n  pcVar4 = getenv(\"POSIXLY_CORRECT\");\n  local_98 = 0;\n  local_94 = 0;\n  local_9f = 10;\n  bVar1 = false;\n  local_38[1] = &DAT_001020fb;\n  local_38[0] = \"-\";\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit((__func *)&close_stdout);\nLAB_0010117f:\n  while ((local_9c == -1 ||\n         (((pcVar4 != (char *)0x0 && (local_94 != 0)) ||\n          (local_9c = getopt_long(param_1,param_2,\"-0123456789Dcdf:is:uw:z\",longopts,0),\n          local_9c == -1))))) {\n    if (param_1 <= _optind) {\n      if ((grouping != 0) && (bVar1)) {\n        local_50 = gettext(\"--group is mutually exclusive with -c/-d/-D/-u\");\n        error(0,0,local_50);\n        usage(1);\n      }\n      if ((grouping != 0) && (count_occurrences != '\\0')) {\n        local_48 = gettext(\"grouping and printing repeat counts is meaningless\");\n        error(0,0,local_48);\n        usage(1);\n      }\n      if ((count_occurrences != '\\0') && (output_later_repeated != '\\0')) {\n        local_40 = gettext(\"printing all duplicated lines and repeat counts is meaningless\");\n        error(0,0,local_40);\n        usage(1);\n      }\n      check_file(local_38[0],local_38[1],local_9f);\n      if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return 0;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (local_94 == 2) {\n      uVar5 = quote(param_2[_optind]);\n      local_60 = gettext(\"extra operand %s\");\n      error(0,0,local_60,uVar5);\n      usage(1);\n    }\n    local_38[local_94] = (char *)param_2[_optind];\n    _optind = _optind + 1;\n    local_94 = local_94 + 1;\n  }\n  if (local_9c < 0x81) {\n    if (0x2f < local_9c) {\n      switch(local_9c) {\n      case 0x30:\n      case 0x31:\n      case 0x32:\n      case 0x33:\n      case 0x34:\n      case 0x35:\n      case 0x36:\n      case 0x37:\n      case 0x38:\n      case 0x39:\n        if (local_98 == 2) {\n          skip_fields = 0;\n        }\n        lVar6 = skip_fields * 10;\n        if ((SEXT816(lVar6) != SEXT816(skip_fields) * SEXT816(10)) ||\n           (skip_fields = (local_9c + -0x30) + lVar6, SCARRY8((long)(local_9c + -0x30),lVar6))) {\n          skip_fields = 0x7fffffffffffffff;\n        }\n        local_98 = 1;\n        break;\n      default:\n        goto switchD_00101334_caseD_3a;\n      case 0x44:\n        output_unique = 0;\n        output_later_repeated = '\\x01';\n        if (_optarg == (char *)0x0) {\n          delimit_groups = 0;\n        }\n        else {\n          lVar6 = __xargmatch_internal\n                            (\"--all-repeated\",_optarg,delimit_method_string,delimit_method_map,4,\n                             _argmatch_die,1);\n          delimit_groups = *(undefined4 *)(delimit_method_map + lVar6 * 4);\n        }\n        bVar1 = true;\n        break;\n      case 99:\n        count_occurrences = '\\x01';\n        bVar1 = true;\n        break;\n      case 100:\n        output_unique = 0;\n        bVar1 = true;\n        break;\n      case 0x66:\n        local_98 = 2;\n        skip_fields = size_opt(_optarg,\"invalid number of fields to skip\");\n        break;\n      case 0x69:\n        ignore_case = 1;\n        break;\n      case 0x73:\n        skip_chars = size_opt(_optarg,\"invalid number of bytes to skip\");\n        break;\n      case 0x75:\n        output_first_repeated = 0;\n        bVar1 = true;\n        break;\n      case 0x77:\n        check_chars = size_opt(_optarg,\"invalid number of bytes to compare\");\n        break;\n      case 0x7a:\n        local_9f = 0;\n        break;\n      case 0x80:\n        if (_optarg == (char *)0x0) {\n          grouping = 3;\n        }\n        else {\n          lVar6 = __xargmatch_internal\n                            (\"--group\",_optarg,grouping_method_string,grouping_method_map,4,\n                             _argmatch_die,1);\n          grouping = *(int *)(grouping_method_map + lVar6 * 4);\n        }\n      }\n      goto LAB_0010117f;\n    }\n    if (local_9c == 1) {\n      if (((*_optarg == '+') && (cVar2 = strict_posix2(), cVar2 != '\\x01')) &&\n         (uVar3 = xstrtoimax(_optarg,0,10,&local_68,&DAT_001019d4), uVar3 < 2)) {\n        skip_chars = local_68;\n      }\n      else {\n        if (local_94 == 2) {\n          uVar5 = quote(_optarg);\n          local_58 = gettext(\"extra operand %s\");\n          error(0,0,local_58,uVar5);\n          usage(1);\n        }\n        local_38[local_94] = _optarg;\n        local_94 = local_94 + 1;\n      }\n      goto LAB_0010117f;\n    }\n    if (local_9c < 2) {\n      if (local_9c != -0x83) {\n        if (local_9c != -0x82) goto switchD_00101334_caseD_3a;\n        usage(0);\n      }\n      uVar5 = proper_name_lite(\"David MacKenzie\",\"David MacKenzie\");\n      uVar7 = proper_name_lite(\"Richard M. Stallman\",\"Richard M. Stallman\");\n      version_etc(_stdout,&DAT_001020e9,\"GNU coreutils\",_Version,uVar7,uVar5,0);\n                    /* WARNING: Subroutine does not return */\n      exit(0);\n    }\n  }\nswitchD_00101334_caseD_3a:\n  usage(1);\n  goto LAB_0010117f;\n}",
                "globals": [],
                "externs": [
                    "SEXT816",
                    "SCARRY8"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "getenv",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "getopt_long",
                        "gettext",
                        "error",
                        "usage",
                        "check_file",
                        "__stack_chk_fail",
                        "quote",
                        "SEXT816",
                        "SCARRY8",
                        "__xargmatch_internal",
                        "size_opt",
                        "strict_posix2",
                        "xstrtoimax",
                        "proper_name_lite",
                        "version_etc",
                        "exit"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "uniq_decompiled.c"
                }
            }
        ]
    }
}