{
    "file": "stdbuf",
    "decompiled_code": {
        "stdbuf.c": [
            {
                "func_name": "parse_size",
                "func_c_signature": "undefined8 parse_size(undefined8 param_1,undefined8 *param_2)",
                "decompiled_code": "undefined8 parse_size(undefined8 param_1,undefined8 *param_2) {\n  int iVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = xstrtoumax(param_1,0,10,&local_28,\"EGkKMPQRTYZ0\");\n  if (iVar1 == 0) {\n    piVar2 = __errno_location();\n    *piVar2 = 0;\n    *param_2 = local_28;\n    uVar3 = 0;\n  }\n  else {\n    if (iVar1 == 1) {\n      iVar1 = 0x4b;\n    }\n    else {\n      piVar2 = __errno_location();\n      iVar1 = *piVar2;\n    }\n    piVar2 = __errno_location();\n    *piVar2 = iVar1;\n    uVar3 = 0xffffffff;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar3;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "parse_size",
                        "xstrtoumax",
                        "__errno_location",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "parse_size",
                        "main"
                    ],
                    "defined_in_file": "stdbuf_decompiled.c"
                }
            },
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\"Usage: %s OPTION... COMMAND\\n\");\n    printf(pcVar3,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"Run COMMAND, with modified buffering operations for its standard streams.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_mandatory_arg_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -i, --input=MODE   adjust standard input stream buffering\\n  -o, --output=MODE  adjust standard output stream buffering\\n  -e, --error=MODE   adjust standard error stream buffering\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nIf MODE is \\'L\\' the corresponding stream will be line buffered.\\nThis option is invalid with standard input.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"\\nIf MODE is \\'0\\' the corresponding stream will be unbuffered.\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nOtherwise MODE is a number which may be followed by one of the following:\\nKB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G,T,P,E,Z,Y,R,Q.\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\nIn this case the corresponding stream will be fully buffered with the buffer\\nsize set to MODE bytes.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nNOTE: If COMMAND adjusts the buffering of its standard streams (\\'tee\\' does\\nfor example) then that will override corresponding changes by \\'stdbuf\\'.\\nAlso some filters (like \\'dd\\' and \\'cat\\' etc.) don\\'t use streams for I/O,\\nand are thus unaffected by \\'stdbuf\\' settings.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_exec_status(\"stdbuf\");\n    emit_ancillary_info(\"stdbuf\");\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "streams",
                    "filters"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "fputs_unlocked",
                        "emit_mandatory_arg_note",
                        "streams",
                        "filters",
                        "emit_exec_status",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "stdbuf_decompiled.c"
                }
            },
            {
                "func_name": "set_program_path",
                "func_c_signature": "void set_program_path(char *param_1)",
                "decompiled_code": "void set_program_path(char *param_1) {\n  int iVar1;\n  char *pcVar2;\n  char *local_20;\n  char *local_18;\n  \n  pcVar2 = strchr(param_1,0x2f);\n  if (pcVar2 == (char *)0x0) {\n    local_20 = (char *)xreadlink(\"/proc/self/exe\");\n    if (local_20 == (char *)0x0) {\n      local_20 = getenv(\"PATH\");\n      if (local_20 != (char *)0x0) {\n        local_20 = (char *)xstrdup(local_20);\n        local_18 = strtok(local_20,\":\");\n        while (local_18 != (char *)0x0) {\n          pcVar2 = (char *)file_name_concat(local_18,param_1,0);\n          iVar1 = access(pcVar2,1);\n          if (iVar1 == 0) {\n            program_path = dir_name(pcVar2);\n            free(pcVar2);\n            break;\n          }\n          free(pcVar2);\n          local_18 = strtok((char *)0x0,\":\");\n        }\n      }\n    }\n    else {\n      program_path = dir_name(local_20);\n    }\n    free(local_20);\n  }\n  else {\n    program_path = dir_name(param_1);\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "set_program_path",
                        "strchr",
                        "xreadlink",
                        "getenv",
                        "xstrdup",
                        "strtok",
                        "file_name_concat",
                        "access",
                        "dir_name",
                        "free"
                    ],
                    "calling_functions": [
                        "set_program_path",
                        "main"
                    ],
                    "defined_in_file": "stdbuf_decompiled.c"
                }
            },
            {
                "func_name": "optc_to_fileno",
                "func_c_signature": "undefined4 optc_to_fileno(int param_1)",
                "decompiled_code": "undefined4 optc_to_fileno(int param_1) {\n  undefined4 local_c;\n  \n  local_c = 0xffffffff;\n  if (param_1 == 0x6f) {\n    local_c = 1;\n  }\n  else if (param_1 < 0x70) {\n    if (param_1 == 0x65) {\n      local_c = 2;\n    }\n    else if (param_1 == 0x69) {\n      local_c = 0;\n    }\n  }\n  return local_c;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "optc_to_fileno"
                    ],
                    "calling_functions": [
                        "optc_to_fileno",
                        "main"
                    ],
                    "defined_in_file": "stdbuf_decompiled.c"
                }
            },
            {
                "func_name": "set_LD_PRELOAD",
                "func_c_signature": "void set_LD_PRELOAD(void)",
                "decompiled_code": "void set_LD_PRELOAD(void) {\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  long in_FS_OFFSET;\n  int local_124;\n  char *local_110;\n  char *local_108;\n  char **local_100;\n  char *local_f8;\n  char *local_f0;\n  undefined8 local_e8;\n  undefined8 local_e0;\n  char *local_d8;\n  char *local_d0;\n  undefined8 local_c8;\n  stat local_b8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_f8 = \"LD_PRELOAD\";\n  local_f0 = getenv(\"LD_PRELOAD\");\n  local_d8 = program_path;\n  local_d0 = \"/usr/local/libexec/coreutils\";\n  local_c8 = 0;\n  local_100 = &local_d8;\n  do {\n    if (**local_100 == '\\0') {\n      local_108 = (char *)xstrdup(\"libstdbuf.so\");\n      goto LAB_0010085e;\n    }\n    iVar1 = asprintf(&local_108,\"%s/%s\",*local_100,\"libstdbuf.so\");\n    if (iVar1 < 0) {\n      xalloc_die();\n    }\n    iVar1 = stat(local_108,&local_b8);\n    if (iVar1 == 0) goto LAB_0010085e;\n    free(local_108);\n    local_100 = local_100 + 1;\n  } while (*local_100 != (char *)0x0);\n  uVar2 = quote(\"libstdbuf.so\");\n  local_e8 = gettext(\"failed to find %s\");\n  error(0x7d,0,local_e8,uVar2);\nLAB_0010085e:\n  if (local_f0 == (char *)0x0) {\n    local_124 = asprintf(&local_110,\"%s=%s\",local_f8,local_108);\n  }\n  else {\n    local_124 = asprintf(&local_110,\"%s=%s:%s\",local_f8,local_f0,local_108);\n  }\n  if (local_124 < 0) {\n    xalloc_die();\n  }\n  free(local_108);\n  iVar1 = putenv(local_110);\n  if (iVar1 != 0) {\n    uVar2 = quote(local_110);\n    uVar3 = gettext(\"failed to update the environment with %s\");\n    piVar4 = __errno_location();\n    local_e0 = uVar3;\n    error(0x7d,*piVar4,uVar3,uVar2);\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "set_LD_PRELOAD",
                        "getenv",
                        "xstrdup",
                        "asprintf",
                        "xalloc_die",
                        "stat",
                        "free",
                        "quote",
                        "gettext",
                        "error",
                        "putenv",
                        "__errno_location",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "set_LD_PRELOAD",
                        "main"
                    ],
                    "defined_in_file": "stdbuf_decompiled.c"
                }
            },
            {
                "func_name": "set_libstdbuf_options",
                "func_c_signature": "undefined set_libstdbuf_options(void)",
                "decompiled_code": "undefined set_libstdbuf_options(void) {\n  uint uVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  undefined local_45;\n  int local_44;\n  char *local_38;\n  ulong local_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_45 = 0;\n  for (local_30 = 0; local_30 < 3; local_30 = local_30 + 1) {\n    if (*(long *)(stdbuf + local_30 * 0x18 + 0x10) != 0) {\n      if (**(char **)(stdbuf + local_30 * 0x18 + 0x10) == 'L') {\n        uVar1 = c_toupper(*(undefined4 *)(stdbuf + local_30 * 0x18 + 8));\n        local_44 = asprintf(&local_38,\"%s%c=L\",\"_STDBUF_\",(ulong)uVar1);\n      }\n      else {\n        uVar3 = *(undefined8 *)(stdbuf + local_30 * 0x18);\n        uVar1 = c_toupper(*(undefined4 *)(stdbuf + local_30 * 0x18 + 8));\n        local_44 = asprintf(&local_38,\"%s%c=%zu\",\"_STDBUF_\",(ulong)uVar1,uVar3);\n      }\n      if (local_44 < 0) {\n        xalloc_die();\n      }\n      iVar2 = putenv(local_38);\n      if (iVar2 != 0) {\n        uVar3 = quote(local_38);\n        uVar4 = gettext(\"failed to update the environment with %s\");\n        piVar5 = __errno_location();\n        local_28 = uVar4;\n        error(0x7d,*piVar5,uVar4,uVar3);\n      }\n      local_45 = 1;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_45;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "set_libstdbuf_options",
                        "c_toupper",
                        "asprintf",
                        "xalloc_die",
                        "putenv",
                        "quote",
                        "gettext",
                        "__errno_location",
                        "error",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "set_libstdbuf_options",
                        "main"
                    ],
                    "defined_in_file": "stdbuf_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "undefined4 main(int param_1,undefined8 *param_2)",
                "decompiled_code": "undefined4 main(int param_1,undefined8 *param_2) {\n  char **__argv;\n  char cVar1;\n  uint uVar2;\n  int iVar3;\n  undefined4 uVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  undefined8 uVar7;\n  \n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  initialize_exit_failure(0x7d);\n  atexit((__func *)&close_stdout);\n  do {\n    while( true ) {\n      iVar3 = getopt_long(param_1,param_2,\"+i:o:e:\",longopts,0);\n      if (iVar3 == -1) {\n        __argv = (char **)(param_2 + _optind);\n        if (param_1 - _optind < 1) {\n          uVar5 = gettext(\"missing operand\");\n          error(0,0,uVar5);\n          usage(0x7d);\n        }\n        cVar1 = set_libstdbuf_options();\n        if (cVar1 != '\\x01') {\n          uVar5 = gettext(\"you must specify a buffering mode option\");\n          error(0,0,uVar5);\n          usage(0x7d);\n        }\n        set_program_path(_program_name);\n        if (program_path == (void *)0x0) {\n          program_path = (void *)xstrdup(\"/usr/local/lib/coreutils\");\n        }\n        set_LD_PRELOAD();\n        free(program_path);\n        execvp(*__argv,__argv);\n        piVar6 = __errno_location();\n        if (*piVar6 == 2) {\n          uVar4 = 0x7f;\n        }\n        else {\n          uVar4 = 0x7e;\n        }\n        uVar5 = quote(*__argv);\n        uVar7 = gettext(\"failed to run command %s\");\n        piVar6 = __errno_location();\n        error(0,*piVar6,uVar7,uVar5);\n        return uVar4;\n      }\n      if (iVar3 < 0x70) break;\nLAB_00100e62:\n      usage(0x7d);\n    }\n    if (iVar3 < 0x65) {\n      if (iVar3 != -0x83) {\n        if (iVar3 != -0x82) goto LAB_00100e62;\n        goto LAB_00100dfd;\n      }\n      goto LAB_00100e07;\n    }\n    if ((0x411UL >> ((char)iVar3 + 0x9bU & 0x3f) & 1) == 0) goto LAB_00100e62;\n    uVar2 = optc_to_fileno(iVar3);\n    if (((int)uVar2 < 0) || (2 < uVar2)) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"0 <= opt_fileno && opt_fileno < ((size_t) (sizeof (stdbuf) / sizeof ((stdbuf)[0]) + 0 * sizeof (struct { unsigned int _gl_verify_error_if_negative : __builtin_types_compatible_p (typeof (stdbuf), typeof (&*(stdbuf))) ? -1 : 1; })))\"\n                    ,\n                    \"/workspace/home/aiclub1/B220032CS_Jaefar/fyp/repos/ansaf/coreutils/src/stdbuf.c\"\n                    ,0x150,(char *)&__PRETTY_FUNCTION___0);\n    }\n    *(int *)(stdbuf + (long)(int)uVar2 * 0x18 + 8) = iVar3;\n    while (cVar1 = c_isspace((int)*_optarg), cVar1 != '\\0') {\n      _optarg = _optarg + 1;\n    }\n    *(char **)(stdbuf + (long)(int)uVar2 * 0x18 + 0x10) = _optarg;\n    if ((iVar3 == 0x69) && (*_optarg == 'L')) {\n      uVar5 = gettext(\"line buffering standard input is meaningless\");\n      error(0,0,uVar5);\n      usage(0x7d);\n    }\n    cVar1 = streq(_optarg,&DAT_00101a15);\n    if ((cVar1 != '\\x01') &&\n       (iVar3 = parse_size(_optarg,stdbuf + (long)(int)uVar2 * 0x18), iVar3 == -1)) {\n      uVar5 = quote(_optarg);\n      uVar7 = gettext(\"invalid mode %s\");\n      piVar6 = __errno_location();\n      error(0x7d,*piVar6,uVar7,uVar5);\nLAB_00100dfd:\n      usage(0);\nLAB_00100e07:\n      uVar5 = proper_name_lite(\"Padraig Brady\",&DAT_00101a27);\n      version_etc(_stdout,\"stdbuf\",\"GNU coreutils\",_Version,uVar5,0);\n                    /* WARNING: Subroutine does not return */\n      exit(0);\n    }\n  } while( true );\n}",
                "globals": [],
                "externs": [
                    "sizeof",
                    "__builtin_types_compatible_p",
                    "typeof"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "initialize_exit_failure",
                        "atexit",
                        "getopt_long",
                        "gettext",
                        "error",
                        "usage",
                        "set_libstdbuf_options",
                        "set_program_path",
                        "xstrdup",
                        "set_LD_PRELOAD",
                        "free",
                        "execvp",
                        "__errno_location",
                        "quote",
                        "optc_to_fileno",
                        "__assert_fail",
                        "sizeof",
                        "__builtin_types_compatible_p",
                        "typeof",
                        "c_isspace",
                        "streq",
                        "parse_size",
                        "proper_name_lite",
                        "version_etc",
                        "exit"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "stdbuf_decompiled.c"
                }
            }
        ]
    }
}