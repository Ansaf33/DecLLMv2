#include <stdbool.h> // For bool
#include <stdint.h>  // For uint32_t, uint64_t, uint8_t
#include <stdlib.h>  // For malloc, NULL, free
#include <stdio.h>   // For printf, fprintf (for main function)

// LCG Context structure inferred from assembly-like usage (param_1 + 4)
// This structure places the 'lcg_state' pointer at an offset of 4 bytes,
// which matches the original code's access pattern `*(undefined4 **)(param_1 + 4)`.
typedef struct lcg_ctx_s {
    uint32_t _dummy_field; // Placeholder to make `lcg_state` start at offset 4
    uint32_t *lcg_state;   // Pointer to the actual LCG state (uint32_t[2])
} lcg_ctx_t;

// Function: lcg_init
// Initializes the LCG context. Allocates memory for the internal state.
// Returns true on failure (if malloc returns NULL), false on success.
bool lcg_init(lcg_ctx_t *ctx) {
    // Allocate 8 bytes for the two uint32_t state variables (state[0] and state[1])
    ctx->lcg_state = (uint32_t *)malloc(2 * sizeof(uint32_t));
    if (ctx->lcg_state != NULL) {
        // Initialize state values as per original code
        ctx->lcg_state[0] = 1;
        ctx->lcg_state[1] = 0;
    }
    // Return true if allocation failed (ctx->lcg_state is NULL), false otherwise
    return ctx->lcg_state == NULL;
}

// Function: next
// Generates the next 32-bit random number and updates the LCG state.
// lcg_state is a pointer to an array of two uint32_t values: {val, carry}.
// This function corresponds to the original `next` function.
uint32_t next(uint32_t *lcg_state) {
    uint32_t current_val = lcg_state[0];
    uint64_t product = (uint64_t)current_val * 0x4c957f2d; // Multiplier from original code

    // Update lcg_state[0] (the 'val' part)
    lcg_state[0] = (uint32_t)product + 1;

    // Calculate carry term for lcg_state[1] update
    // (uint)(0xfffffffe < uVar3) from original code translates to (uint32_t)product >= 0xfffffffe
    uint32_t carry_term = ((uint32_t)product >= 0xfffffffe) ? 1 : 0;

    // Update lcg_state[1] (the 'carry' or 'accumulator' part)
    // Using uint64_t for intermediate sum to prevent overflow before final truncation to uint32_t
    uint64_t sum_64 = (uint64_t)current_val * 0x5851f42d + // Another multiplier from original code
                      (uint64_t)lcg_state[1] * 0x4c957f2d +
                      (product >> 32) + // Higher 32 bits of the product
                      carry_term;
    lcg_state[1] = (uint32_t)sum_64; // Truncate the result to 32 bits

    return lcg_state[1]; // Return the updated carry/accumulator value
}

// Function: lcg_get_bytes
// Fills a buffer with random bytes generated by the LCG.
// Bytes are extracted from each 32-bit random number from MSB (most significant byte) to LSB (least significant byte).
// Returns the number of bytes actually written to the buffer.
size_t lcg_get_bytes(lcg_ctx_t *ctx, uint8_t *buffer, size_t num_bytes) {
    size_t bytes_written = 0;

    while (num_bytes > 0) {
        uint32_t random_val = next(ctx->lcg_state);

        // Extract and write bytes from random_val, MSB first
        if (num_bytes-- > 0) {
            *buffer++ = (uint8_t)(random_val >> 24); // 4th byte (MSB)
            bytes_written++;
        } else { break; } // Should not happen with num_bytes check
        if (num_bytes-- > 0) {
            *buffer++ = (uint8_t)(random_val >> 16); // 3rd byte
            bytes_written++;
        } else { break; }
        if (num_bytes-- > 0) {
            *buffer++ = (uint8_t)(random_val >> 8);  // 2nd byte
            bytes_written++;
        } else { break; }
        if (num_bytes-- > 0) {
            *buffer++ = (uint8_t)random_val;         // 1st byte (LSB)
            bytes_written++;
        } else { break; }
    }
    return bytes_written;
}

// Function: lcg_free
// Frees the dynamically allocated memory for the LCG state.
void lcg_free(lcg_ctx_t *ctx) {
    if (ctx != NULL && ctx->lcg_state != NULL) {
        free(ctx->lcg_state);
        ctx->lcg_state = NULL; // Prevent double-free
    }
}

// Main function for testing and demonstration
int main() {
    lcg_ctx_t lcg_context = {0}; // Initialize context, _dummy_field to 0, lcg_state to NULL

    // Initialize LCG context
    if (lcg_init(&lcg_context)) {
        fprintf(stderr, "Error: Failed to initialize LCG context.\n");
        return 1;
    }

    printf("LCG initialized. Initial state: {0x%08x, 0x%08x}\n",
           lcg_context.lcg_state[0], lcg_context.lcg_state[1]);

    // Generate and print some random bytes
    uint8_t buffer[16]; // Buffer to store 16 random bytes
    size_t bytes_generated = lcg_get_bytes(&lcg_context, buffer, sizeof(buffer));

    printf("Generated %zu bytes:\n", bytes_generated);
    for (size_t i = 0; i < bytes_generated; ++i) {
        printf("%02x ", buffer[i]);
        if ((i + 1) % 4 == 0) {
            printf(" "); // Space after every 4 bytes for readability
        }
        if ((i + 1) % 8 == 0) {
            printf("\n"); // Newline after every 8 bytes
        }
    }
    printf("\n");

    printf("LCG state after generating bytes: {0x%08x, 0x%08x}\n",
           lcg_context.lcg_state[0], lcg_context.lcg_state[1]);

    // Test generating a partial number of bytes (e.g., 3 bytes)
    uint8_t buffer_partial[3];
    bytes_generated = lcg_get_bytes(&lcg_context, buffer_partial, sizeof(buffer_partial));

    printf("\nGenerated %zu partial bytes:\n", bytes_generated);
    for (size_t i = 0; i < bytes_generated; ++i) {
        printf("%02x ", buffer_partial[i]);
    }
    printf("\n");
    printf("LCG state after generating partial bytes: {0x%08x, 0x%08x}\n",
           lcg_context.lcg_state[0], lcg_context.lcg_state[1]);

    // Clean up allocated memory
    lcg_free(&lcg_context);
    printf("\nLCG context freed.\n");

    return 0;
}