{
    "file": "mknod",
    "decompiled_code": {
        "mknod.c": [
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\"Usage: %s [OPTION]... NAME TYPE [MAJOR MINOR]\\n\");\n    printf(pcVar3,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"Create the special file NAME of the given TYPE.\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_mandatory_arg_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -m, --mode=MODE    set file permission bits to MODE, not a=rw - umask\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -Z                   set the SELinux security context to default type\\n      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\\n                         or SMACK security context to CTX\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nBoth MAJOR and MINOR must be specified when TYPE is b, c, or u, and they\\nmust be omitted when TYPE is p.  If MAJOR or MINOR begins with 0x or 0X,\\nit is interpreted as hexadecimal; otherwise, if it begins with 0, as octal;\\notherwise, as decimal.  TYPE may be:\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\n  b      create a block (buffered) special file\\n  c, u   create a character (unbuffered) special file\\n  p      create a FIFO\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pcVar3 = (char *)gettext(\n                            \"\\nYour shell may have its own version of %s, which usually supersedes\\nthe version described here.  Please refer to your shell\\'s documentation\\nfor details about the options it supports.\\n\"\n                            );\n    printf(pcVar3,\"mknod\");\n    emit_ancillary_info(\"mknod\");\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "block",
                    "character"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "fputs_unlocked",
                        "emit_mandatory_arg_note",
                        "block",
                        "character",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "mknod_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "undefined8 main(int param_1,undefined8 *param_2)",
                "decompiled_code": "undefined8 main(int param_1,undefined8 *param_2) {\n  char cVar1;\n  int iVar2;\n  __mode_t __mask;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  int *piVar5;\n  long in_FS_OFFSET;\n  uint local_164;\n  uint local_160;\n  int local_15c;\n  ulong local_e0;\n  ulong local_d8;\n  long local_d0;\n  long local_c8;\n  long local_c0;\n  void *local_b8;\n  ulong local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  ulonglong local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined8 local_80;\n  undefined8 local_78;\n  undefined8 local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined *local_40;\n  undefined *local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_c8 = 0;\n  local_d0 = 0;\n  local_c0 = 0;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit((__func *)&close_stdout);\n  while (iVar2 = getopt_long(param_1,param_2,&DAT_0010175f,longopts,0), iVar2 != -1) {\n    if (iVar2 == 0x6d) {\n      local_c8 = _optarg;\n    }\n    else if (iVar2 < 0x6e) {\n      if (iVar2 != 0x5a) {\n        if (iVar2 < 0x5b) {\n          if (iVar2 == -0x83) {\nLAB_00100617:\n            uVar3 = proper_name_lite(\"David MacKenzie\",\"David MacKenzie\");\n            version_etc(_stdout,\"mknod\",\"GNU coreutils\",_Version,uVar3,0);\n                    /* WARNING: Subroutine does not return */\n            exit(0);\n          }\n          if (iVar2 == -0x82) {\n            usage(0);\n            goto LAB_00100617;\n          }\n        }\n        goto LAB_00100672;\n      }\n      cVar1 = is_smack_enabled();\n      if (cVar1 == '\\0') {\n        if (_optarg != 0) {\n          local_90 = gettext(\n                            \"warning: ignoring --context; it requires an SELinux/SMACK-enabled kernel\"\n                            );\n          error(0,0,local_90);\n        }\n      }\n      else {\n        local_d0 = _optarg;\n      }\n    }\n    else {\nLAB_00100672:\n      usage(1);\n    }\n  }\n  local_164 = 0x1b6;\n  if (local_c8 != 0) {\n    local_b8 = (void *)mode_compile(local_c8);\n    if (local_b8 == (void *)0x0) {\n      local_88 = gettext(\"invalid mode\");\n      error(1,0,local_88);\n    }\n    __mask = umask(0);\n    umask(__mask);\n    local_164 = mode_adjust(0x1b6,0,__mask,local_b8,0);\n    free(local_b8);\n    if (0x1ff < local_164) {\n      local_80 = gettext(\"mode must specify only file permission bits\");\n      error(1,0,local_80);\n    }\n  }\n  if ((_optind < param_1) &&\n     ((param_1 <= _optind + 1 || (*(char *)param_2[(long)_optind + 1] != 'p')))) {\n    local_b0 = 4;\n  }\n  else {\n    local_b0 = 2;\n  }\n  if ((ulong)(long)(param_1 - _optind) < local_b0) {\n    if (_optind < param_1) {\n      uVar3 = quote(param_2[(long)param_1 + -1]);\n      local_70 = gettext(\"missing operand after %s\");\n      error(0,0,local_70,uVar3);\n    }\n    else {\n      local_78 = gettext(\"missing operand\");\n      error(0,0,local_78);\n    }\n    if ((local_b0 == 4) && (param_1 - _optind == 2)) {\n      uVar3 = gettext(\"Special files require major and minor device numbers.\");\n      fprintf(_stderr,\"%s\\n\",uVar3);\n    }\n    usage(1);\n  }\n  if (local_b0 < (ulong)(long)(param_1 - _optind)) {\n    uVar3 = quote(param_2[local_b0 + (long)_optind]);\n    local_68 = gettext(\"extra operand %s\");\n    error(0,0,local_68,uVar3);\n    if ((local_b0 == 2) && (param_1 - _optind == 4)) {\n      uVar3 = gettext(\"Fifos do not have major and minor device numbers.\");\n      fprintf(_stderr,\"%s\\n\",uVar3);\n    }\n    usage(1);\n  }\n  if (local_d0 != 0) {\n    cVar1 = is_smack_enabled();\n    if (cVar1 == '\\0') {\n      local_15c = setfscreatecon(local_d0);\n    }\n    else {\n      local_15c = smack_set_label_for_self(local_d0);\n    }\n    if (local_15c < 0) {\n      uVar3 = quote(local_d0);\n      uVar4 = gettext(\"failed to set default file creation context to %s\");\n      piVar5 = __errno_location();\n      local_60 = uVar4;\n      error(1,*piVar5,uVar4,uVar3);\n    }\n  }\n  cVar1 = *(char *)param_2[(long)_optind + 1];\n  if (cVar1 == 'u') {\nLAB_00100b7b:\n    local_160 = 0x2000;\nLAB_00100b86:\n    local_a8 = param_2[(long)_optind + 2];\n    local_a0 = param_2[(long)_optind + 3];\n    iVar2 = xstrtoumax(local_a8,0,0,&local_e0,&DAT_00101224);\n    if ((iVar2 != 0) || ((local_e0 & 0xffffffff) != local_e0)) {\n      uVar3 = quote(local_a8);\n      local_58 = gettext(\"invalid major device number %s\");\n      error(1,0,local_58,uVar3);\n    }\n    iVar2 = xstrtoumax(local_a0,0,0,&local_d8,&DAT_00101224);\n    if ((iVar2 != 0) || ((local_d8 & 0xffffffff) != local_d8)) {\n      uVar3 = quote(local_a0);\n      local_50 = gettext(\"invalid minor device number %s\");\n      error(1,0,local_50,uVar3);\n    }\n    local_98 = gnu_dev_makedev((uint)local_e0,(uint)local_d8);\n    if (local_98 == 0xffffffffffffffff) {\n      local_48 = gettext(\"invalid device %s %s\");\n      error(1,0,local_48,local_a8,local_a0);\n    }\n    if (local_c0 != 0) {\n      defaultcon(local_c0,param_2[_optind],local_160);\n    }\n    iVar2 = rpl_mknod(param_2[_optind],local_164 | local_160,local_98);\n    if (iVar2 == 0) goto LAB_00100fec;\n    uVar3 = quotearg_n_style_colon(0,3,param_2[_optind]);\n    piVar5 = __errno_location();\n    local_40 = &DAT_001018dc;\n    error(1,*piVar5,&DAT_001018dc,uVar3);\nLAB_00100e84:\n    if (local_c0 != 0) {\n      defaultcon(local_c0,param_2[_optind],0x1000);\n    }\n    iVar2 = mkfifo((char *)param_2[_optind],local_164);\n    if (iVar2 == 0) goto LAB_00100fec;\n    uVar3 = quotearg_n_style_colon(0,3,param_2[_optind]);\n    piVar5 = __errno_location();\n    local_38 = &DAT_001018dc;\n    error(1,*piVar5,&DAT_001018dc,uVar3);\n  }\n  else if (cVar1 < 'v') {\n    if (cVar1 == 'p') goto LAB_00100e84;\n    if (cVar1 < 'q') {\n      if (cVar1 == 'b') {\n        local_160 = 0x6000;\n        goto LAB_00100b86;\n      }\n      if (cVar1 == 'c') goto LAB_00100b7b;\n    }\n  }\n  uVar3 = quote(param_2[(long)_optind + 1]);\n  local_30 = gettext(\"invalid device type %s\");\n  error(0,0,local_30,uVar3);\n  usage(1);\nLAB_00100fec:\n  if ((local_c8 != 0) && (iVar2 = lchmod((char *)param_2[_optind],local_164), iVar2 != 0)) {\n    uVar3 = quotearg_style(4,param_2[_optind]);\n    uVar4 = gettext(\"cannot set permissions of %s\");\n    piVar5 = __errno_location();\n    local_28 = uVar4;\n    error(1,*piVar5,uVar4,uVar3);\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return 0;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "getopt_long",
                        "proper_name_lite",
                        "version_etc",
                        "exit",
                        "usage",
                        "is_smack_enabled",
                        "gettext",
                        "error",
                        "mode_compile",
                        "umask",
                        "mode_adjust",
                        "free",
                        "quote",
                        "fprintf",
                        "setfscreatecon",
                        "smack_set_label_for_self",
                        "__errno_location",
                        "xstrtoumax",
                        "gnu_dev_makedev",
                        "defaultcon",
                        "rpl_mknod",
                        "quotearg_n_style_colon",
                        "mkfifo",
                        "lchmod",
                        "quotearg_style",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "mknod_decompiled.c"
                }
            }
        ]
    }
}