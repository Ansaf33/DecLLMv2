{
    "file": "nl",
    "decompiled_code": {
        "nl.c": [
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\"Usage: %s [OPTION]... [FILE]...\\n\");\n    printf(pcVar3,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"Write each FILE to standard output, with line numbers added.\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_stdin_note();\n    emit_mandatory_arg_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -b, --body-numbering=STYLE      use STYLE for numbering body lines\\n  -d, --section-delimiter=CC      use CC for logical page delimiters\\n  -f, --footer-numbering=STYLE    use STYLE for numbering footer lines\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -h, --header-numbering=STYLE    use STYLE for numbering header lines\\n  -i, --line-increment=NUMBER     line number increment at each line\\n  -l, --join-blank-lines=NUMBER   group of NUMBER empty lines counted as one\\n  -n, --number-format=FORMAT      insert line numbers according to FORMAT\\n  -p, --no-renumber               do not reset line numbers for each section\\n  -s, --number-separator=STRING   add STRING after (possible) line number\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -v, --starting-line-number=NUMBER  first line number for each section\\n  -w, --number-width=NUMBER       use NUMBER columns for line numbers\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nDefault options are: -bt -d\\'\\\\:\\' -fn -hn -i1 -l1 -n\\'rn\\' -s<TAB> -v1 -w6\\n\\nCC are two delimiter characters used to construct logical page delimiters;\\na missing second character implies \\':\\'.  As a GNU extension one can specify\\nmore than two characters, and also specifying the empty string (-d \\'\\')\\ndisables section matching.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nSTYLE is one of:\\n\\n  a      number all lines\\n  t      number only nonempty lines\\n  n      number no lines\\n  pBRE   number only lines that contain a match for the basic regular\\n         expression, BRE\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nFORMAT is one of:\\n\\n  ln     left justified, no leading zeros\\n  rn     right justified, no leading zeros\\n  rz     right justified, leading zeros\\n\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_ancillary_info(&DAT_0010237b);\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "after",
                    "string"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "fputs_unlocked",
                        "emit_stdin_note",
                        "emit_mandatory_arg_note",
                        "after",
                        "string",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "nl_decompiled.c"
                }
            },
            {
                "func_name": "build_type_arg",
                "func_c_signature": "undefined build_type_arg(char **param_1,re_pattern_buffer *param_2,char *param_3)",
                "decompiled_code": "undefined build_type_arg(char **param_1,re_pattern_buffer *param_2,char *param_3) {\n  char cVar1;\n  size_t __length;\n  char *pcVar2;\n  undefined local_21;\n  \n  local_21 = 1;\n  cVar1 = *_optarg;\n  if (cVar1 == 't') {\nLAB_00100559:\n    *param_1 = _optarg;\n  }\n  else {\n    if (cVar1 < 'u') {\n      if (cVar1 == 'p') {\n        pcVar2 = _optarg + 1;\n        *param_1 = _optarg;\n        _optarg = pcVar2;\n        param_2->buffer = (uchar *)0x0;\n        param_2->allocated = 0;\n        param_2->fastmap = param_3;\n        param_2->translate = (uchar *)0x0;\n        _re_syntax_options = 0x2c6;\n        __length = strlen(_optarg);\n        pcVar2 = re_compile_pattern(_optarg,__length,param_2);\n        if (pcVar2 == (char *)0x0) {\n          return 1;\n        }\n        error(1,0,&DAT_0010237e,pcVar2);\n      }\n      else if ((cVar1 < 'q') && ((cVar1 == 'a' || (cVar1 == 'n')))) goto LAB_00100559;\n    }\n    local_21 = 0;\n  }\n  return local_21;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "build_type_arg",
                        "strlen",
                        "re_compile_pattern",
                        "error"
                    ],
                    "calling_functions": [
                        "build_type_arg",
                        "main"
                    ],
                    "defined_in_file": "nl_decompiled.c"
                }
            },
            {
                "func_name": "print_lineno",
                "func_c_signature": "void print_lineno(void)",
                "decompiled_code": "void print_lineno(void) {\n  undefined8 uVar1;\n  bool bVar2;\n  \n  if (line_no_overflow != '\\0') {\n    uVar1 = gettext(\"line number overflow\");\n    error(1,0,uVar1);\n  }\n  printf(lineno_format,(ulong)lineno_width,line_no,separator_str);\n  bVar2 = SCARRY8(page_incr,line_no);\n  line_no = page_incr + line_no;\n  if (bVar2) {\n    line_no_overflow = '\\x01';\n  }\n  return;\n}",
                "globals": [],
                "externs": [
                    "SCARRY8"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "print_lineno",
                        "gettext",
                        "error",
                        "printf",
                        "SCARRY8"
                    ],
                    "calling_functions": [
                        "print_lineno",
                        "proc_text"
                    ],
                    "defined_in_file": "nl_decompiled.c"
                }
            },
            {
                "func_name": "reset_lineno",
                "func_c_signature": "void reset_lineno(void)",
                "decompiled_code": "void reset_lineno(void) {\n  if (reset_numbers != '\\0') {\n    line_no = starting_line_number;\n    line_no_overflow = 0;\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "reset_lineno"
                    ],
                    "calling_functions": [
                        "reset_lineno",
                        "proc_header",
                        "proc_body",
                        "proc_footer"
                    ],
                    "defined_in_file": "nl_decompiled.c"
                }
            },
            {
                "func_name": "proc_header",
                "func_c_signature": "void proc_header(void)",
                "decompiled_code": "void proc_header(void) {\n  current_type = header_type;\n  current_regex = header_regex;\n  reset_lineno();\n  putchar_unlocked(10);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "proc_header",
                        "reset_lineno",
                        "putchar_unlocked"
                    ],
                    "calling_functions": [
                        "proc_header",
                        "process_file"
                    ],
                    "defined_in_file": "nl_decompiled.c"
                }
            },
            {
                "func_name": "proc_body",
                "func_c_signature": "void proc_body(void)",
                "decompiled_code": "void proc_body(void) {\n  current_type = body_type;\n  current_regex = body_regex;\n  reset_lineno();\n  putchar_unlocked(10);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "proc_body",
                        "reset_lineno",
                        "putchar_unlocked"
                    ],
                    "calling_functions": [
                        "proc_body",
                        "process_file"
                    ],
                    "defined_in_file": "nl_decompiled.c"
                }
            },
            {
                "func_name": "proc_footer",
                "func_c_signature": "void proc_footer(void)",
                "decompiled_code": "void proc_footer(void) {\n  current_type = footer_type;\n  current_regex = footer_regex;\n  reset_lineno();\n  putchar_unlocked(10);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "proc_footer",
                        "reset_lineno",
                        "putchar_unlocked"
                    ],
                    "calling_functions": [
                        "proc_footer",
                        "process_file"
                    ],
                    "defined_in_file": "nl_decompiled.c"
                }
            },
            {
                "func_name": "proc_text",
                "func_c_signature": "void proc_text(void)",
                "decompiled_code": "void proc_text(void) {\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  \n  cVar1 = *current_type;\n  if (cVar1 == 't') {\n    if ((long)line_buf._8_8_ < 2) {\n      fputs_unlocked(print_no_line_fmt,_stdout);\n    }\n    else {\n      print_lineno();\n    }\n  }\n  else if (cVar1 < 'u') {\n    if (cVar1 == 'p') {\n      iVar2 = re_search(current_regex,(char *)line_buf._16_8_,(int)line_buf._8_8_ + -1,0,\n                        (int)line_buf._8_8_ + -1,(re_registers *)0x0);\n      if (iVar2 == -2) {\n        uVar3 = gettext(\"error in regular expression search\");\n        piVar4 = __errno_location();\n        error(1,*piVar4,uVar3);\n      }\n      else if (iVar2 != -1) {\n        print_lineno();\n        goto LAB_0010097a;\n      }\n      fputs_unlocked(print_no_line_fmt,_stdout);\n    }\n    else if (cVar1 < 'q') {\n      if (cVar1 == 'a') {\n        if (blank_join < 2) {\n          print_lineno();\n        }\n        else if (((long)line_buf._8_8_ < 2) &&\n                (blank_lines_0 = blank_lines_0 + 1, blank_lines_0 != blank_join)) {\n          fputs_unlocked(print_no_line_fmt,_stdout);\n        }\n        else {\n          print_lineno();\n          blank_lines_0 = 0;\n        }\n      }\n      else if (cVar1 == 'n') {\n        fputs_unlocked(print_no_line_fmt,_stdout);\n      }\n    }\n  }\nLAB_0010097a:\n  fwrite_unlocked((void *)line_buf._16_8_,1,line_buf._8_8_,_stdout);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "proc_text",
                        "fputs_unlocked",
                        "print_lineno",
                        "re_search",
                        "gettext",
                        "__errno_location",
                        "error",
                        "fwrite_unlocked"
                    ],
                    "calling_functions": [
                        "proc_text",
                        "process_file"
                    ],
                    "defined_in_file": "nl_decompiled.c"
                }
            },
            {
                "func_name": "check_section",
                "func_c_signature": "undefined8 check_section(void)",
                "decompiled_code": "undefined8 check_section(void) {\n  char cVar1;\n  ulong uVar2;\n  \n  uVar2 = line_buf._8_8_ - 1;\n  if (((uVar2 < 2) || (footer_del_len < 2)) ||\n     (cVar1 = memeq(line_buf._16_8_,section_del,2), cVar1 != '\\x01')) {\n    return 3;\n  }\n  if ((uVar2 == header_del_len) &&\n     (cVar1 = memeq(line_buf._16_8_,header_del,header_del_len), cVar1 != '\\0')) {\n    return 0;\n  }\n  if ((uVar2 == body_del_len) &&\n     (cVar1 = memeq(line_buf._16_8_,body_del,body_del_len), cVar1 != '\\0')) {\n    return 1;\n  }\n  if ((uVar2 == footer_del_len) &&\n     (cVar1 = memeq(line_buf._16_8_,footer_del,footer_del_len), cVar1 != '\\0')) {\n    return 2;\n  }\n  return 3;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "check_section",
                        "memeq"
                    ],
                    "calling_functions": [
                        "check_section",
                        "process_file"
                    ],
                    "defined_in_file": "nl_decompiled.c"
                }
            },
            {
                "func_name": "process_file",
                "func_c_signature": "void process_file(undefined8 param_1)",
                "decompiled_code": "void process_file(undefined8 param_1) {\n  uint uVar1;\n  int iVar2;\n  long lVar3;\n  \n  while (lVar3 = readlinebuffer(line_buf,param_1), lVar3 != 0) {\n    uVar1 = check_section();\n    if (uVar1 == 3) {\n      proc_text();\n    }\n    else if (uVar1 < 4) {\n      if (uVar1 == 2) {\n        proc_footer();\n      }\n      else if (uVar1 < 3) {\n        if (uVar1 == 0) {\n          proc_header();\n        }\n        else if (uVar1 == 1) {\n          proc_body();\n        }\n      }\n    }\n    iVar2 = ferror_unlocked(_stdout);\n    if (iVar2 != 0) {\n      write_error();\n    }\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "process_file",
                        "readlinebuffer",
                        "check_section",
                        "proc_text",
                        "proc_footer",
                        "proc_header",
                        "proc_body",
                        "ferror_unlocked",
                        "write_error"
                    ],
                    "calling_functions": [
                        "process_file",
                        "nl_file"
                    ],
                    "defined_in_file": "nl_decompiled.c"
                }
            },
            {
                "func_name": "nl_file",
                "func_c_signature": "bool nl_file(undefined8 param_1)",
                "decompiled_code": "bool nl_file(undefined8 param_1) {\n  char cVar1;\n  int iVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  int local_44;\n  FILE *local_30;\n  \n  cVar1 = streq(param_1,&DAT_001023bb);\n  if (cVar1 == '\\0') {\n    local_30 = (FILE *)rpl_fopen(param_1,&DAT_001023bd);\n    if (local_30 == (FILE *)0x0) {\n      uVar4 = quotearg_n_style_colon(0,3,param_1);\n      piVar3 = __errno_location();\n      error(0,*piVar3,&DAT_0010237e,uVar4);\n      return false;\n    }\n  }\n  else {\n    have_read_stdin = 1;\n    local_30 = _stdin;\n  }\n  fadvise(local_30,2);\n  process_file(local_30);\n  piVar3 = __errno_location();\n  local_44 = *piVar3;\n  iVar2 = ferror_unlocked(local_30);\n  if (iVar2 == 0) {\n    local_44 = 0;\n  }\n  cVar1 = streq(param_1,&DAT_001023bb);\n  if (cVar1 == '\\0') {\n    iVar2 = rpl_fclose(local_30);\n    if ((iVar2 != 0) && (local_44 == 0)) {\n      piVar3 = __errno_location();\n      local_44 = *piVar3;\n    }\n  }\n  else {\n    clearerr_unlocked(local_30);\n  }\n  if (local_44 != 0) {\n    uVar4 = quotearg_n_style_colon(0,3,param_1);\n    error(0,local_44,&DAT_0010237e,uVar4);\n  }\n  return local_44 == 0;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "nl_file",
                        "streq",
                        "rpl_fopen",
                        "quotearg_n_style_colon",
                        "__errno_location",
                        "error",
                        "fadvise",
                        "process_file",
                        "ferror_unlocked",
                        "rpl_fclose",
                        "clearerr_unlocked"
                    ],
                    "calling_functions": [
                        "nl_file",
                        "main"
                    ],
                    "defined_in_file": "nl_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "byte main(int param_1,undefined8 *param_2)",
                "decompiled_code": "byte main(int param_1,undefined8 *param_2) {\n  undefined *__src;\n  char cVar1;\n  byte bVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  size_t sVar6;\n  char *pcVar7;\n  int *piVar8;\n  byte local_7d;\n  char *local_50;\n  \n  local_7d = true;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit((__func *)&close_stdout);\n  have_read_stdin = '\\0';\n  do {\n    while( true ) {\n      iVar3 = getopt_long(param_1,param_2,\"h:b:f:v:i:pl:s:w:n:d:\",longopts,0);\n      if (iVar3 == -1) {\n        if ((bool)local_7d != true) {\n          usage(1);\n        }\n        sVar6 = strlen(section_del);\n        header_del_len = sVar6 * 3;\n        header_del = (char *)xmalloc(header_del_len + 1);\n        __src = section_del;\n        pcVar7 = stpcpy(header_del,section_del);\n        pcVar7 = stpcpy(pcVar7,__src);\n        strcpy(pcVar7,__src);\n        body_del_len = sVar6 * 2;\n        body_del = header_del + sVar6;\n        footer_del = body_del + sVar6;\n        footer_del_len = sVar6;\n        initbuffer(line_buf);\n        sVar6 = strlen(separator_str);\n        print_no_line_fmt = (void *)xmalloc(sVar6 + (long)lineno_width + 1);\n        memset(print_no_line_fmt,0x20,(long)lineno_width + sVar6);\n        *(undefined *)((long)print_no_line_fmt + sVar6 + (long)lineno_width) = 0;\n        line_no = starting_line_number;\n        current_type = body_type;\n        current_regex = body_regex;\n        if (param_1 == _optind) {\n          local_7d = nl_file(&DAT_001023bb);\n        }\n        else {\n          for (; _optind < param_1; _optind = _optind + 1) {\n            bVar2 = nl_file(param_2[_optind]);\n            local_7d = (bVar2 & local_7d) != 0;\n          }\n        }\n        if ((have_read_stdin != '\\0') && (iVar3 = rpl_fclose(_stdin), iVar3 == -1)) {\n          piVar8 = __errno_location();\n          error(1,*piVar8,&DAT_001023bb);\n        }\n        return local_7d ^ 1;\n      }\n      if (iVar3 < 0x78) break;\nswitchD_00100dcc_caseD_63:\n      local_7d = false;\n    }\n    if (iVar3 < 0x62) {\n      if (iVar3 == -0x83) {\nLAB_0010122e:\n        uVar4 = proper_name_lite(\"David MacKenzie\",\"David MacKenzie\");\n        uVar5 = proper_name_lite(\"Scott Bartram\",\"Scott Bartram\");\n        version_etc(_stdout,&DAT_0010237b,\"GNU coreutils\",_Version,uVar5,uVar4,0);\n                    /* WARNING: Subroutine does not return */\n        exit(0);\n      }\n      if (iVar3 == -0x82) {\n        usage(0);\n        goto LAB_0010122e;\n      }\n      goto switchD_00100dcc_caseD_63;\n    }\n    switch(iVar3) {\n    case 0x62:\n      cVar1 = build_type_arg(&body_type,body_regex,body_fastmap);\n      if (cVar1 != '\\x01') {\n        uVar4 = quote(_optarg);\n        uVar5 = gettext(\"invalid body numbering style: %s\");\n        error(0,0,uVar5,uVar4);\n        local_7d = false;\n      }\n      break;\n    default:\n      goto switchD_00100dcc_caseD_63;\n    case 100:\n      sVar6 = strlen(_optarg);\n      if ((sVar6 == 1) || (sVar6 == 2)) {\n        local_50 = section_del;\n        while (*_optarg != '\\0') {\n          cVar1 = *_optarg;\n          _optarg = _optarg + 1;\n          *local_50 = cVar1;\n          local_50 = local_50 + 1;\n        }\n      }\n      else {\n        section_del = _optarg;\n      }\n      break;\n    case 0x66:\n      cVar1 = build_type_arg(&footer_type,footer_regex,footer_fastmap);\n      if (cVar1 != '\\x01') {\n        uVar4 = quote(_optarg);\n        uVar5 = gettext(\"invalid footer numbering style: %s\");\n        error(0,0,uVar5,uVar4);\n        local_7d = false;\n      }\n      break;\n    case 0x68:\n      cVar1 = build_type_arg(&header_type,header_regex,header_fastmap);\n      if (cVar1 != '\\x01') {\n        uVar4 = quote(_optarg);\n        uVar5 = gettext(\"invalid header numbering style: %s\");\n        error(0,0,uVar5,uVar4);\n        local_7d = false;\n      }\n      break;\n    case 0x69:\n      uVar4 = gettext(\"invalid line number increment\");\n      page_incr = xdectoimax(_optarg,0x8000000000000000,0x7fffffffffffffff,&DAT_00101b84,uVar4,0);\n      break;\n    case 0x6c:\n      uVar4 = gettext(\"invalid line number of blank lines\");\n      blank_join = xnumtoimax(_optarg,10,1,0x7fffffffffffffff,&DAT_00101b84,uVar4,0,6);\n      break;\n    case 0x6e:\n      cVar1 = streq(_optarg,&DAT_001024d0);\n      if (cVar1 == '\\0') {\n        cVar1 = streq(_optarg,&DAT_001024d3);\n        if (cVar1 == '\\0') {\n          cVar1 = streq(_optarg,&DAT_001024d6);\n          if (cVar1 == '\\0') {\n            uVar4 = quote(_optarg);\n            uVar5 = gettext(\"invalid line numbering format: %s\");\n            error(0,0,uVar5,uVar4);\n            local_7d = false;\n          }\n          else {\n            lineno_format = FORMAT_RIGHT_LZ;\n          }\n        }\n        else {\n          lineno_format = FORMAT_RIGHT_NOLZ;\n        }\n      }\n      else {\n        lineno_format = FORMAT_LEFT;\n      }\n      break;\n    case 0x70:\n      reset_numbers = 0;\n      break;\n    case 0x73:\n      separator_str = _optarg;\n      break;\n    case 0x76:\n      uVar4 = gettext(\"invalid starting line number\");\n      starting_line_number =\n           xdectoimax(_optarg,0x8000000000000000,0x7fffffffffffffff,&DAT_00101b84,uVar4,0);\n      break;\n    case 0x77:\n      uVar4 = gettext(\"invalid line number field width\");\n      lineno_width = xnumtoimax(_optarg,10,1,0x7fffffff,&DAT_00101b84,uVar4,0,4);\n    }\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "getopt_long",
                        "usage",
                        "strlen",
                        "xmalloc",
                        "stpcpy",
                        "strcpy",
                        "initbuffer",
                        "memset",
                        "nl_file",
                        "rpl_fclose",
                        "__errno_location",
                        "error",
                        "proper_name_lite",
                        "version_etc",
                        "exit",
                        "build_type_arg",
                        "quote",
                        "gettext",
                        "xdectoimax",
                        "xnumtoimax",
                        "streq"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "nl_decompiled.c"
                }
            }
        ]
    }
}