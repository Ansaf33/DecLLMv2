{
    "file": "date",
    "decompiled_code": {
        "date.c": [
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\n                            \"Usage: %s [OPTION]... [+FORMAT]\\n  or:  %s [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]\\n\"\n                            );\n    printf(pcVar3,uVar2,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"Display date and time in the given FORMAT.\\nWith -s, or with [MMDDhhmm[[CC]YY][.ss]], set the date and time.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_mandatory_arg_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -d, --date=STRING          display time described by STRING, not \\'now\\'\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"      --debug                annotate the parsed date, and\\n                              warn about questionable usage to standard error\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -f, --file=DATEFILE        like --date; once for each line of DATEFILE\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -I[FMT], --iso-8601[=FMT]  output date/time in ISO 8601 format.\\n                               FMT=\\'date\\' for date only (the default),\\n                               \\'hours\\', \\'minutes\\', \\'seconds\\', or \\'ns\\'\\n                               for date and time to the indicated precision.\\n                               Example: 2006-08-14T02:34:56-06:00\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  --resolution               output the available resolution of timestamps\\n                               Example: 0.000000001\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -R, --rfc-email            output date and time in RFC 5322 format.\\n                               Example: Mon, 14 Aug 2006 02:34:56 -0600\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"      --rfc-3339=FMT         output date/time in RFC 3339 format.\\n                               FMT=\\'date\\', \\'seconds\\', or \\'ns\\'\\n                               for date and time to the indicated precision.\\n                               Example: 2006-08-14 02:34:56-06:00\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -r, --reference=FILE       display the last modification time of FILE\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -s, --set=STRING           set time described by STRING\\n  -u, --utc, --universal     print or set Coordinated Universal Time (UTC)\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nAll options that specify the date to display are mutually exclusive.\\nI.e.: --date, --file, --reference, --resolution.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nFORMAT controls the output.  Interpreted sequences are:\\n\\n  %%   a literal %\\n  %a   locale\\'s abbreviated weekday name (e.g., Sun)\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  %A   locale\\'s full weekday name (e.g., Sunday)\\n  %b   locale\\'s abbreviated month name (e.g., Jan)\\n  %B   locale\\'s full month name (e.g., January)\\n  %c   locale\\'s date and time (e.g., Thu Mar  3 23:05:25 2005)\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  %C   century; like %Y, except omit last two digits (e.g., 20)\\n  %d   day of month (e.g., 01)\\n  %D   date (ambiguous); same as %m/%d/%y\\n  %e   day of month, space padded; same as %_d\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  %F   full date; like %+4Y-%m-%d\\n  %g   last two digits of year of ISO week number (ambiguous; 00-99); see %G\\n  %G   year of ISO week number; normally useful only with %V\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  %h   same as %b\\n  %H   hour (00..23)\\n  %I   hour (01..12)\\n  %j   day of year (001..366)\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  %k   hour, space padded ( 0..23); same as %_H\\n  %l   hour, space padded ( 1..12); same as %_I\\n  %m   month (01..12)\\n  %M   minute (00..59)\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  %n   a newline\\n  %N   nanoseconds (000000000..999999999)\\n  %p   locale\\'s equivalent of either AM or PM; blank if not known\\n  %P   like %p, but lower case\\n  %q   quarter of year (1..4)\\n  %r   locale\\'s 12-hour clock time (e.g., 11:11:04 PM)\\n  %R   24-hour hour and minute; same as %H:%M\\n  %s   seconds since the Epoch (1970-01-01 00:00 UTC)\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  %S   second (00..60)\\n  %t   a tab\\n  %T   time; same as %H:%M:%S\\n  %u   day of week (1..7); 1 is Monday\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  %U   week number of year, with Sunday as first day of week (00..53)\\n  %V   ISO week number, with Monday as first day of week (01..53)\\n  %w   day of week (0..6); 0 is Sunday\\n  %W   week number of year, with Monday as first day of week (00..53)\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  %x   locale\\'s date (can be ambiguous; e.g., 12/31/99)\\n  %X   locale\\'s time representation (e.g., 23:13:48)\\n  %y   last two digits of year (ambiguous; 00..99)\\n  %Y   year\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  %z   +hhmm numeric time zone (e.g., -0400)\\n  %:z  +hh:mm numeric time zone (e.g., -04:00)\\n  %::z  +hh:mm:ss numeric time zone (e.g., -04:00:00)\\n  %:::z  numeric time zone with : to necessary precision (e.g., -04, +05:30)\\n  %Z   alphabetic time zone abbreviation (e.g., EDT)\\n\\nBy default, date pads numeric fields with zeroes.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"The following optional flags may follow \\'%\\':\\n\\n  -  (hyphen) do not pad the field\\n  _  (underscore) pad with spaces\\n  0  (zero) pad with zeros\\n  +  pad with zeros, and put \\'+\\' before future years with >4 digits\\n  ^  use upper case if possible\\n  #  use opposite case if possible\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nAfter any flags comes an optional field width, as a decimal number;\\nthen an optional modifier, which is either\\nE to use the locale\\'s alternate representations if available, or\\nO to use the locale\\'s alternate numeric symbols if available.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nExamples:\\nConvert seconds since the Epoch (1970-01-01 UTC) to a date\\n  $ date --date=\\'@2147483647\\'\\n\\nShow the time on the west coast of the US (use tzselect(1) to find TZ)\\n  $ TZ=\\'America/Los_Angeles\\' date\\n\\nShow the local time for 9AM next Friday on the west coast of the US\\n  $ date --date=\\'TZ=\\\"America/Los_Angeles\\\" 09:00 next Fri\\'\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_ancillary_info(&DAT_00101b39);\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "only",
                    "Time",
                    "name",
                    "time",
                    "digits",
                    "month",
                    "date",
                    "number",
                    "hour",
                    "year",
                    "padded",
                    "minute",
                    "nanoseconds",
                    "Epoch",
                    "second",
                    "week",
                    "representation",
                    "zone",
                    "precision",
                    "abbreviation",
                    "_",
                    "US",
                    "tzselect"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "fputs_unlocked",
                        "emit_mandatory_arg_note",
                        "only",
                        "Time",
                        "name",
                        "time",
                        "digits",
                        "month",
                        "date",
                        "number",
                        "hour",
                        "year",
                        "padded",
                        "minute",
                        "nanoseconds",
                        "Epoch",
                        "second",
                        "week",
                        "representation",
                        "zone",
                        "precision",
                        "abbreviation",
                        "_",
                        "US",
                        "tzselect",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "date_decompiled.c"
                }
            },
            {
                "func_name": "res_width",
                "func_c_signature": "int res_width(long param_1)",
                "decompiled_code": "int res_width(long param_1) {\n  int local_14;\n  long local_10;\n  \n  local_14 = 9;\n  local_10 = 1;\n  while (local_10 = local_10 * 10, local_10 <= param_1) {\n    local_14 = local_14 + -1;\n  }\n  return local_14;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "res_width"
                    ],
                    "calling_functions": [
                        "res_width",
                        "adjust_resolution"
                    ],
                    "defined_in_file": "date_decompiled.c"
                }
            },
            {
                "func_name": "adjust_resolution",
                "func_c_signature": "long adjust_resolution(char *param_1)",
                "decompiled_code": "long adjust_resolution(char *param_1) {\n  char cVar1;\n  undefined8 uVar2;\n  long local_18;\n  char *local_10;\n  \n  local_18 = 0;\n  for (local_10 = param_1; *local_10 != '\\0'; local_10 = local_10 + 1) {\n    if (*local_10 == '%') {\n      if ((local_10[1] == '-') && (local_10[2] == 'N')) {\n        if (local_18 == 0) {\n          local_18 = xstrdup(param_1);\n        }\n        uVar2 = gettime_res();\n        cVar1 = res_width(uVar2);\n        local_10[local_18 + (1 - (long)param_1)] = cVar1 + '0';\n        local_10 = local_10 + 2;\n      }\n      else {\n        local_10 = local_10 + (local_10[1] == '%');\n      }\n    }\n  }\n  return local_18;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "adjust_resolution",
                        "xstrdup",
                        "gettime_res",
                        "res_width"
                    ],
                    "calling_functions": [
                        "adjust_resolution",
                        "main"
                    ],
                    "defined_in_file": "date_decompiled.c"
                }
            },
            {
                "func_name": "set_LC_TIME",
                "func_c_signature": "undefined8 set_LC_TIME(long param_1)",
                "decompiled_code": "undefined8 set_LC_TIME(long param_1) {\n  char *pcVar1;\n  undefined8 uVar2;\n  \n  pcVar1 = getenv(\"LC_ALL\");\n  if ((pcVar1 != (char *)0x0) && (*pcVar1 != '\\0')) {\n    xsetenv(\"LC_CTYPE\",pcVar1,1);\n    xsetenv(\"LC_TIME\",pcVar1,1);\n    xsetenv(\"LC_MESSAGES\",pcVar1,1);\n    xsetenv(\"LC_NUMERIC\",pcVar1,1);\n    unsetenv(\"LC_ALL\");\n  }\n  pcVar1 = getenv(\"LC_TIME\");\n  if ((pcVar1 == (char *)0x0) || (*pcVar1 == '\\0')) {\n    uVar2 = 0;\n  }\n  else {\n    uVar2 = xstrdup(pcVar1);\n  }\n  if (param_1 == 0) {\n    unsetenv(\"LC_TIME\");\n  }\n  else {\n    xsetenv(\"LC_TIME\",param_1,1);\n  }\n  setlocale(2,\"\");\n  return uVar2;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "set_LC_TIME",
                        "getenv",
                        "xsetenv",
                        "unsetenv",
                        "xstrdup",
                        "setlocale"
                    ],
                    "calling_functions": [
                        "set_LC_TIME",
                        "show_date_helper"
                    ],
                    "defined_in_file": "date_decompiled.c"
                }
            },
            {
                "func_name": "show_date_helper",
                "func_c_signature": "undefined show_date_helper(undefined8 param_1,char param_2,undefined8 param_3,undefined8 param_4,\n                          undefined8 param_5)",
                "decompiled_code": "undefined show_date_helper(undefined8 param_1,char param_2,undefined8 param_3,undefined8 param_4,\n                          undefined8 param_5) {\n  undefined8 uVar1;\n  undefined8 uVar2;\n  void *__ptr;\n  void *__ptr_00;\n  undefined local_39;\n  \n  if ((parse_datetime_flags & 1) != 0) {\n    uVar1 = quote(param_1);\n    uVar2 = gettext(\"output format: %s\");\n    error(0,0,uVar2,uVar1);\n  }\n  if (param_2 == '\\0') {\n    local_39 = show_date(param_1,param_3,param_4,param_5);\n  }\n  else {\n    __ptr = (void *)set_LC_TIME(&DAT_00102f87);\n    local_39 = show_date(param_1,param_3,param_4,param_5);\n    __ptr_00 = (void *)set_LC_TIME(__ptr);\n    free(__ptr_00);\n    free(__ptr);\n  }\n  putchar_unlocked(10);\n  return local_39;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "show_date_helper",
                        "quote",
                        "gettext",
                        "error",
                        "show_date",
                        "set_LC_TIME",
                        "free",
                        "putchar_unlocked"
                    ],
                    "calling_functions": [
                        "show_date_helper",
                        "batch_convert",
                        "main"
                    ],
                    "defined_in_file": "date_decompiled.c"
                }
            },
            {
                "func_name": "batch_convert",
                "func_c_signature": "bool batch_convert(undefined8 param_1,undefined8 param_2,undefined param_3,undefined8 param_4,\n                  undefined8 param_5)",
                "decompiled_code": "bool batch_convert(undefined8 param_1,undefined8 param_2,undefined param_3,undefined8 param_4,\n                  undefined8 param_5) {\n  char cVar1;\n  byte bVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  long in_FS_OFFSET;\n  undefined8 local_b0;\n  bool local_99;\n  void *local_78;\n  undefined8 local_70;\n  FILE *local_68;\n  long local_60;\n  undefined *local_58;\n  undefined8 local_50;\n  undefined8 local_48;\n  undefined *local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  cVar1 = streq(param_1,&DAT_00102f89);\n  if (cVar1 == '\\0') {\n    local_68 = (FILE *)rpl_fopen(param_1,&DAT_00102f9a);\n    local_b0 = param_1;\n    if (local_68 == (FILE *)0x0) {\n      uVar4 = quotearg_n_style_colon(0,3,param_1);\n      piVar6 = __errno_location();\n      local_58 = &DAT_00102f9c;\n      error(1,*piVar6,&DAT_00102f9c,uVar4);\n    }\n  }\n  else {\n    local_b0 = gettext(\"standard input\");\n    local_68 = _stdin;\n  }\n  local_78 = (void *)0x0;\n  local_70 = 0;\n  local_99 = true;\n  do {\n    local_60 = rpl_getline(&local_78,&local_70,local_68);\n    if (local_60 < 0) {\n      iVar3 = ferror_unlocked(local_68);\n      if (iVar3 == 0) {\n        iVar3 = rpl_fclose(local_68);\n        if (iVar3 == -1) {\n          uVar4 = quotearg_n_style_colon(0,3,local_b0);\n          piVar6 = __errno_location();\n          local_40 = &DAT_00102f9c;\n          error(1,*piVar6,&DAT_00102f9c,uVar4);\n        }\n        free(local_78);\n        if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n          __stack_chk_fail();\n        }\n        return local_99;\n      }\n      uVar4 = quotearg_n_style_colon(0,3,local_b0);\n      uVar5 = gettext(\"%s: read error\");\n      piVar6 = __errno_location();\n      local_50 = uVar5;\n      error(1,*piVar6,uVar5,uVar4);\n    }\n    cVar1 = parse_datetime2(&local_38,local_78,0,parse_datetime_flags,param_4,param_5);\n    if (cVar1 == '\\x01') {\n      bVar2 = show_date_helper(param_2,param_3,local_38,local_30,param_4);\n      local_99 = (bVar2 & local_99) != 0;\n    }\n    else {\n      if (*(char *)((long)local_78 + local_60 + -1) == '\\n') {\n        *(undefined *)((long)local_78 + local_60 + -1) = 0;\n      }\n      uVar4 = quote(local_78);\n      local_48 = gettext(\"invalid date %s\");\n      error(0,0,local_48,uVar4);\n      local_99 = false;\n    }\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "batch_convert",
                        "streq",
                        "rpl_fopen",
                        "quotearg_n_style_colon",
                        "__errno_location",
                        "error",
                        "gettext",
                        "rpl_getline",
                        "ferror_unlocked",
                        "rpl_fclose",
                        "free",
                        "__stack_chk_fail",
                        "parse_datetime2",
                        "show_date_helper",
                        "quote"
                    ],
                    "calling_functions": [
                        "batch_convert",
                        "main"
                    ],
                    "defined_in_file": "date_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "void main(int param_1,undefined8 *param_2)",
                "decompiled_code": "void main(int param_1,undefined8 *param_2) {\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  byte bVar4;\n  uint uVar5;\n  int iVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  char *pcVar9;\n  long lVar10;\n  undefined8 uVar11;\n  int *piVar12;\n  long in_FS_OFFSET;\n  undefined local_1ce;\n  char local_1cd;\n  byte local_1cc;\n  char local_1c9;\n  char *local_168;\n  char *local_160;\n  char *local_158;\n  char *local_150;\n  char *local_148;\n  undefined local_c8 [16];\n  stat local_b8;\n  undefined8 local_20;\n  \n  local_20 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  local_168 = (char *)0x0;\n  local_160 = (char *)0x0;\n  bVar1 = false;\n  local_158 = (char *)0x0;\n  local_1ce = 0;\n  local_1cd = '\\0';\n  local_150 = (char *)0x0;\n  local_148 = (char *)0x0;\n  bVar2 = false;\n  bVar3 = false;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit((__func *)&close_stdout);\n  do {\n    while( true ) {\n      iVar6 = getopt_long(param_1,param_2,short_options,long_options,0);\n      if (iVar6 == -1) {\n        bVar4 = local_1cd +\n                (local_168 != (char *)0x0) + (local_150 != (char *)0x0) + (local_148 != (char *)0x0)\n        ;\n        if (1 < bVar4) {\n          uVar7 = gettext(\"the options to specify dates for printing are mutually exclusive\");\n          error(0,0,uVar7);\n          usage(1);\n        }\n        if ((bVar1) && (bVar4 != 0)) {\n          uVar7 = gettext(\"the options to print and set the time may not be used together\");\n          error(0,0,uVar7);\n          usage(1);\n        }\n        if ((bVar2) && ((parse_datetime_flags & 1) != 0)) {\n          uVar7 = gettext(\"only using last of multiple -d options\");\n          error(0,0,uVar7);\n        }\n        if ((bVar3) && ((parse_datetime_flags & 1) != 0)) {\n          uVar7 = gettext(\"only using last of multiple -s options\");\n          error(0,0,uVar7);\n        }\n        if (_optind < param_1) {\n          if (_optind + 1 < param_1) {\n            uVar7 = quote(param_2[(long)_optind + 1]);\n            uVar8 = gettext(\"extra operand %s\");\n            error(0,0,uVar8,uVar7);\n            usage(1);\n          }\n          if (*(char *)param_2[_optind] == '+') {\n            if (local_158 != (char *)0x0) {\n              uVar7 = gettext(\"multiple output formats specified\");\n              error(1,0,uVar7);\n            }\n            local_158 = (char *)(param_2[_optind] + 1);\n            _optind = _optind + 1;\n          }\n          else if ((bVar1) || (bVar4 != 0)) {\n            uVar7 = quote(param_2[_optind]);\n            uVar8 = gettext(\n                           \"the argument %s lacks a leading \\'+\\';\\nwhen using an option to specify date(s), any non-option\\nargument must be a format string beginning with \\'+\\'\"\n                           );\n            error(0,0,uVar8,uVar7);\n            usage(1);\n          }\n        }\n        if (local_158 == (char *)0x0) {\n          if (local_1cd == '\\0') {\n            local_158 = (char *)rpl_nl_langinfo(0x2006c);\n            if (*local_158 == '\\0') {\n              local_158 = \"%a %b %e %H:%M:%S %Z %Y\";\n            }\n          }\n          else {\n            local_158 = \"%s.%N\";\n          }\n        }\n        pcVar9 = (char *)adjust_resolution(local_158);\n        if (pcVar9 != (char *)0x0) {\n          local_158 = pcVar9;\n        }\n        pcVar9 = getenv(\"TZ\");\n        uVar7 = tzalloc(pcVar9);\n        if (local_150 == (char *)0x0) {\n          local_1c9 = '\\x01';\n          local_1cc = 1;\n          if ((bVar4 != 0) || (bVar1)) {\n            if (local_148 == (char *)0x0) {\n              if (local_1cd == '\\0') {\n                if (local_160 != (char *)0x0) {\n                  local_168 = local_160;\n                }\n                local_1c9 = parse_datetime2(local_c8,local_168,0,parse_datetime_flags,uVar7,pcVar9);\n              }\n              else {\n                lVar10 = gettime_res();\n                local_c8._8_8_ = lVar10 % 1000000000;\n                local_c8._0_8_ = lVar10 / 1000000000;\n              }\n            }\n            else {\n              iVar6 = stat(local_148,&local_b8);\n              if (iVar6 != 0) {\n                uVar8 = quotearg_n_style_colon(0,3,local_148);\n                piVar12 = __errno_location();\n                error(1,*piVar12,&DAT_00102f9c,uVar8);\n              }\n              local_c8 = get_stat_mtime(&local_b8);\n            }\n          }\n          else if (_optind < param_1) {\n            bVar1 = true;\n            local_168 = (char *)param_2[_optind];\n            local_1c9 = posixtime(local_c8,local_168,7);\n            local_c8._8_8_ = 0;\n          }\n          else {\n            gettime(local_c8);\n          }\n          if (local_1c9 != '\\x01') {\n            uVar8 = quote(local_168);\n            uVar11 = gettext(\"invalid date %s\");\n            error(1,0,uVar11,uVar8);\n          }\n          if (bVar1) {\n            iVar6 = settime(local_c8);\n            if (iVar6 != 0) {\n              uVar8 = gettext(\"cannot set date\");\n              piVar12 = __errno_location();\n              error(0,*piVar12,uVar8);\n              local_1cc = 0;\n            }\n          }\n          bVar4 = show_date_helper(local_158,local_1ce,local_c8._0_8_,local_c8._8_8_,uVar7);\n          local_1cc = (bVar4 & local_1cc) != 0;\n        }\n        else {\n          local_1cc = batch_convert(local_150,local_158,local_1ce,uVar7,pcVar9);\n        }\n                    /* WARNING: Subroutine does not return */\n        exit((uint)(local_1cc ^ 1));\n      }\n      if (iVar6 < 0x83) break;\nswitchD_00100ebd_caseD_4a:\n      usage(1);\n    }\n    if (iVar6 < 0x49) {\n      if (iVar6 != -0x83) {\n        if (iVar6 != -0x82) goto switchD_00100ebd_caseD_4a;\n        goto LAB_001010b1;\n      }\n      goto LAB_001010bb;\n    }\n    switch(iVar6) {\n    case 0x49:\n      if (_optarg == (char *)0x0) {\n        uVar5 = 0;\n      }\n      else {\n        lVar10 = __xargmatch_internal\n                           (\"--iso-8601\",_optarg,time_spec_string,time_spec,4,_argmatch_die,1);\n        uVar5 = *(uint *)(time_spec + lVar10 * 4);\n      }\n      local_158 = iso_8601_format_0 + (ulong)uVar5 * 0x20;\n      local_1ce = 1;\n      break;\n    default:\n      goto switchD_00100ebd_caseD_4a;\n    case 0x52:\n      local_158 = \"%a, %d %b %Y %H:%M:%S %z\";\n      local_1ce = 1;\n      break;\n    case 100:\n      if (local_168 != (char *)0x0) {\n        bVar2 = true;\n      }\n      local_168 = _optarg;\n      break;\n    case 0x66:\n      local_150 = _optarg;\n      break;\n    case 0x72:\n      local_148 = _optarg;\n      break;\n    case 0x73:\n      if (local_160 != (char *)0x0) {\n        bVar3 = true;\n      }\n      local_160 = _optarg;\n      bVar1 = true;\n      break;\n    case 0x75:\n      pcVar9 = (char *)bad_cast(\"TZ=UTC0\");\n      iVar6 = putenv(pcVar9);\n      if (iVar6 != 0) {\n        xalloc_die();\nLAB_001010b1:\n        usage(0);\nLAB_001010bb:\n        uVar7 = proper_name_lite(\"David MacKenzie\",\"David MacKenzie\");\n        version_etc(_stdout,&DAT_00101b39,\"GNU coreutils\",_Version,uVar7,0);\n                    /* WARNING: Subroutine does not return */\n        exit(0);\n      }\n      break;\n    case 0x80:\n      parse_datetime_flags = parse_datetime_flags | 1;\n      break;\n    case 0x81:\n      local_1cd = '\\x01';\n      break;\n    case 0x82:\n      lVar10 = __xargmatch_internal(\"--rfc-3339\",_optarg,0x1033f0,0x101b58,4,_argmatch_die,1);\n      local_158 = rfc_3339_format_1 + (ulong)*(uint *)(time_spec + (lVar10 + 2) * 4) * 0x20;\n      local_1ce = 1;\n    }\n  } while( true );\n}",
                "globals": [],
                "externs": [
                    "date"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "getopt_long",
                        "gettext",
                        "error",
                        "usage",
                        "quote",
                        "date",
                        "rpl_nl_langinfo",
                        "adjust_resolution",
                        "getenv",
                        "tzalloc",
                        "parse_datetime2",
                        "gettime_res",
                        "stat",
                        "quotearg_n_style_colon",
                        "__errno_location",
                        "get_stat_mtime",
                        "posixtime",
                        "gettime",
                        "settime",
                        "show_date_helper",
                        "batch_convert",
                        "exit",
                        "__xargmatch_internal",
                        "bad_cast",
                        "putenv",
                        "xalloc_die",
                        "proper_name_lite",
                        "version_etc"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "date_decompiled.c"
                }
            }
        ]
    }
}