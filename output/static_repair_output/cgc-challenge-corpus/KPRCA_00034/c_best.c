#include <stdint.h> // For uint8_t, uint32_t, uintptr_t
#include <stdlib.h> // For malloc, free
#include <string.h> // For memcpy, memset

// Type definitions
typedef uint8_t byte;
typedef uint32_t uint;
typedef uint32_t undefined4;

// Global arrays (placeholder definitions for compilation)
// In a real scenario, these would be defined with actual values.
// S-box: 256 elements
static const byte S[256] = {
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
};
// Inverse S-box: 256 elements
static const byte Si[256] = {
    0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
    0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
    0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
    0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
    0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
    0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
    0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
    0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
    0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
    0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
    0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
    0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
    0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
    0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
    0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d
};
// Kconst array: 144 elements (9 rounds * 8 bytes + 9 rounds * 8 bytes for second part)
static const byte Kconst[144] = {
    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
    0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
    0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
    0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
    0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
    0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f
};

// Function: rot3
uint rot3(byte param_1) {
  // This performs an 8-bit left rotate by 3 bits.
  return (uint)((param_1 << 3) | (param_1 >> 5));
}

// Function: R
void R(byte *param_1, char *param_2, byte *param_3) {
  // Phase 1: S-box/Si-box operations
  param_3[0] = S[param_1[0] ^ param_3[0]] + param_2[0];
  param_3[1] = param_2[1] ^ Si[(byte)(param_1[1] + param_3[1])];
  param_3[2] = param_2[2] ^ Si[(byte)(param_1[2] + param_3[2])];
  param_3[3] = param_2[3] + S[param_1[3] ^ param_3[3]];
  param_3[4] = param_2[4] + S[param_1[4] ^ param_3[4]];
  param_3[5] = param_2[5] ^ Si[(byte)(param_1[5] + param_3[5])];
  param_3[6] = param_2[6] ^ Si[(byte)(param_1[6] + param_3[6])];
  param_3[7] = param_2[7] + S[param_1[7] ^ param_3[7]];

  // Phase 2, 3, 4: Repeated blocks of arithmetic and permutation
  for (int round_block = 0; round_block < 3; ++round_block) {
    // Arithmetic operations, reduced intermediate variables
    byte temp_a, temp_b;

    temp_a = param_3[0];
    temp_b = param_3[1];
    param_3[1] = temp_b + temp_a;
    param_3[0] = temp_b + (temp_a << 1);

    temp_a = param_3[2];
    temp_b = param_3[3];
    param_3[3] = temp_b + temp_a;
    param_3[2] = temp_b + (temp_a << 1);

    temp_a = param_3[4];
    temp_b = param_3[5];
    param_3[5] = temp_b + temp_a;
    param_3[4] = temp_b + (temp_a << 1);

    temp_a = param_3[6];
    temp_b = param_3[7];
    param_3[7] = temp_b + temp_a;
    param_3[6] = temp_b + (temp_a << 1);

    // Permutation, requires intermediate variables for correct swapping
    byte perm_temp1 = param_3[1];
    byte perm_temp2 = param_3[3];
    byte perm_temp3 = param_3[5];

    param_3[1] = param_3[2];
    param_3[2] = param_3[4];
    param_3[3] = param_3[6];
    param_3[4] = perm_temp1;
    param_3[5] = perm_temp2;
    param_3[6] = perm_temp3;
  }
}

// Function: Rd
void Rd(byte *param_1, byte *param_2, byte *param_3) {
  // Phase 1, 2, 3: Repeated blocks of inverse arithmetic and inverse permutation
  for (int round_block = 0; round_block < 3; ++round_block) {
    // Inverse arithmetic operations, reduced intermediate variables
    byte temp_a, temp_b;

    temp_a = param_3[0]; // current param_3[0]
    temp_b = param_3[1]; // current param_3[1]
    param_3[0] = temp_a - (temp_b - temp_a);
    param_3[1] = temp_b - temp_a;

    temp_a = param_3[2];
    temp_b = param_3[3];
    param_3[2] = temp_a - (temp_b - temp_a);
    param_3[3] = temp_b - temp_a;

    temp_a = param_3[4];
    temp_b = param_3[5];
    param_3[4] = temp_a - (temp_b - temp_a);
    param_3[5] = temp_b - temp_a;

    temp_a = param_3[6];
    temp_b = param_3[7];
    param_3[6] = temp_a - (temp_b - temp_a);
    param_3[7] = temp_b - temp_a;

    // Inverse permutation, requires intermediate variables for correct swapping
    byte perm_temp1 = param_3[1];
    byte perm_temp2 = param_3[2];
    byte perm_temp3 = param_3[3];

    param_3[1] = param_3[4];
    param_3[2] = perm_temp1;
    param_3[3] = param_3[5];
    param_3[4] = perm_temp2;
    param_3[5] = param_3[6];
    param_3[6] = perm_temp3;
  }

  // Phase 4: Inverse S-box/Si-box operations
  param_3[0] = Si[(byte)(param_3[0] - param_2[0])] ^ param_1[0];
  param_3[1] = S[param_2[1] ^ param_3[1]] - param_1[1];
  param_3[2] = S[param_2[2] ^ param_3[2]] - param_1[2];
  param_3[3] = param_1[3] ^ Si[(byte)(param_3[3] - param_2[3])];
  param_3[4] = param_1[4] ^ Si[(byte)(param_3[4] - param_2[4])];
  param_3[5] = S[param_2[5] ^ param_3[5]] - param_1[5];
  param_3[6] = S[param_2[6] ^ param_3[6]] - param_1[6];
  param_3[7] = param_1[7] ^ Si[(byte)(param_3[7] - param_2[7])];
}

// Function: best_init
undefined4 best_init(int param_1, void *param_2) {
  // local_31 needs to be 9 bytes due to (k_idx + i) % 9 access.
  byte local_31[9];
  undefined4 return_code;
  uint8_t *key_schedule;

  key_schedule = (uint8_t *)malloc(0x90); // Allocate 144 bytes
  *(uint8_t **)((uintptr_t)param_1 + 4) = key_schedule; // Store pointer to allocated memory

  if (key_schedule == NULL) {
    return_code = 1; // Allocation failed
  } else {
    // First key schedule part
    memset(local_31, 0, sizeof(local_31)); // Initialize local_31 to zero
    memcpy(local_31, (void *)((uintptr_t)param_2 + 8), 8); // Copy 8 bytes

    for (int k_idx = 0; k_idx < 9; ++k_idx) {
      for (int i = 0; i < 8; ++i) {
        int current_idx = (k_idx + i) % 9;
        local_31[current_idx] = (byte)rot3(local_31[current_idx]);
        key_schedule[k_idx * 8 + i] = Kconst[k_idx * 8 + i] ^ local_31[current_idx];
      }
    }

    // Second key schedule part
    memset(local_31, 0, sizeof(local_31)); // Re-initialize for second part
    memcpy(local_31, param_2, 8); // Copy 8 bytes

    for (int k_idx = 0; k_idx < 9; ++k_idx) {
      for (int i = 0; i < 8; ++i) {
        int current_idx = (k_idx + i) % 9;
        local_31[current_idx] = (byte)rot3(local_31[current_idx]);
        key_schedule[k_idx * 8 + 0x48 + i] = Kconst[(k_idx + 9) * 8 + i] ^ local_31[current_idx];
      }
    }
    return_code = 0; // Success
  }
  return return_code;
}

// Function: best_destroy
void best_destroy(int param_1) {
  free(*(void **)((uintptr_t)param_1 + 4));
}

// Function: best_encode
undefined4 best_encode(int param_1, int param_2) {
  byte block[8];
  uint8_t *key_schedule = *(uint8_t **)((uintptr_t)param_1 + 4);

  for (int i = 0; i < 8; ++i) {
    block[i] = *(byte *)((uintptr_t)param_2 + i);
  }

  R(key_schedule + 0, (char *)(key_schedule + 0x48), block);
  R(key_schedule + 8, (char *)(key_schedule + 0x50), block);
  R(key_schedule + 0x10, (char *)(key_schedule + 0x58), block);
  R(key_schedule + 0x18, (char *)(key_schedule + 0x60), block);
  R(key_schedule + 0x20, (char *)(key_schedule + 0x68), block);
  R(key_schedule + 0x28, (char *)(key_schedule + 0x70), block);
  R(key_schedule + 0x30, (char *)(key_schedule + 0x78), block);
  R(key_schedule + 0x38, (char *)(key_schedule + 0x80), block);

  block[0] = key_schedule[0x40] ^ block[0];
  block[1] = key_schedule[0x41] + block[1];
  block[2] = key_schedule[0x42] + block[2];
  block[3] = key_schedule[0x43] ^ block[3];
  block[4] = key_schedule[0x44] ^ block[4];
  block[5] = key_schedule[0x45] + block[5];
  block[6] = key_schedule[0x46] + block[6];
  block[7] = key_schedule[0x47] ^ block[7];

  for (int i = 0; i < 8; ++i) {
    *(byte *)((uintptr_t)param_2 + i) = block[i];
  }
  return 0;
}

// Function: best_decode
undefined4 best_decode(int param_1, int param_2) {
  byte block[8];
  uint8_t *key_schedule = *(uint8_t **)((uintptr_t)param_1 + 4);

  for (int i = 0; i < 8; ++i) {
    block[i] = *(byte *)((uintptr_t)param_2 + i);
  }

  block[0] = key_schedule[0x40] ^ block[0];
  block[1] = block[1] - key_schedule[0x41];
  block[2] = block[2] - key_schedule[0x42];
  block[3] = key_schedule[0x43] ^ block[3];
  block[4] = key_schedule[0x44] ^ block[4];
  block[5] = block[5] - key_schedule[0x45];
  block[6] = block[6] - key_schedule[0x46];
  block[7] = key_schedule[0x47] ^ block[7];

  Rd(key_schedule + 0x38, (char *)(key_schedule + 0x80), block);
  Rd(key_schedule + 0x30, (char *)(key_schedule + 0x78), block);
  Rd(key_schedule + 0x28, (char *)(key_schedule + 0x70), block);
  Rd(key_schedule + 0x20, (char *)(key_schedule + 0x68), block);
  Rd(key_schedule + 0x18, (char *)(key_schedule + 0x60), block);
  Rd(key_schedule + 0x10, (char *)(key_schedule + 0x58), block);
  Rd(key_schedule + 8, (char *)(key_schedule + 0x50), block);
  Rd(key_schedule + 0, (char *)(key_schedule + 0x48), block);

  for (int i = 0; i < 8; ++i) {
    *(byte *)((uintptr_t)param_2 + i) = block[i];
  }
  return 0;
}