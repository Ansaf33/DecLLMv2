{
    "file": "readlink",
    "decompiled_code": {
        "readlink.c": [
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\"Usage: %s [OPTION]... FILE...\\n\");\n    printf(pcVar3,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"Print value of a symbolic link or canonical file name\\n\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -f, --canonicalize            canonicalize by following every symlink in\\n                                every component of the given name recursively;\\n                                all but the last component must exist\\n  -e, --canonicalize-existing   canonicalize by following every symlink in\\n                                every component of the given name recursively,\\n                                all components must exist\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -m, --canonicalize-missing    canonicalize by following every symlink in\\n                                every component of the given name recursively,\\n                                without requirements on components existence\\n  -n, --no-newline              do not output the trailing delimiter\\n  -q, --quiet\\n  -s, --silent                  suppress most error messages (on by default\\n                                if POSIXLY_CORRECT is not set)\\n  -v, --verbose                 report error messages (on by default if\\n                                POSIXLY_CORRECT is set)\\n  -z, --zero                    end each output line with NUL, not newline\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_ancillary_info(\"readlink\");\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "messages"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "fputs_unlocked",
                        "messages",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "readlink_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "undefined4 main(int param_1,undefined8 *param_2)",
                "decompiled_code": "undefined4 main(int param_1,undefined8 *param_2) {\n  bool bVar1;\n  int iVar2;\n  undefined8 uVar3;\n  char *pcVar4;\n  int *piVar5;\n  int local_64;\n  undefined4 local_60;\n  \n  local_64 = -1;\n  local_60 = 0;\n  bVar1 = false;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit((__func *)&close_stdout);\n  do {\n    while( true ) {\n      iVar2 = getopt_long(param_1,param_2,\"efmnqsvz\",longopts,0);\n      if (iVar2 == -1) {\n        if (param_1 <= _optind) {\n          uVar3 = gettext(\"missing operand\");\n          error(0,0,uVar3);\n          usage(1);\n        }\n        if (1 < param_1 - _optind) {\n          if (no_newline != '\\0') {\n            uVar3 = gettext(\"ignoring --no-newline with multiple arguments\");\n            error(0,0,uVar3);\n          }\n          no_newline = '\\0';\n        }\n        pcVar4 = getenv(\"POSIXLY_CORRECT\");\n        if (pcVar4 != (char *)0x0) {\n          verbose = '\\x01';\n        }\n        for (; _optind < param_1; _optind = _optind + 1) {\n          uVar3 = param_2[_optind];\n          if (local_64 == -1) {\n            pcVar4 = (char *)areadlink_with_size(uVar3,0x3f);\n          }\n          else {\n            pcVar4 = (char *)canonicalize_filename_mode(uVar3,local_64);\n          }\n          if (pcVar4 == (char *)0x0) {\n            local_60 = 1;\n            if (verbose != '\\0') {\n              uVar3 = quotearg_n_style_colon(0,3,uVar3);\n              piVar5 = __errno_location();\n              error(0,*piVar5,&DAT_00100ee6,uVar3);\n            }\n          }\n          else {\n            fputs_unlocked(pcVar4,_stdout);\n            if (no_newline != '\\x01') {\n              if (bVar1) {\n                iVar2 = 0;\n              }\n              else {\n                iVar2 = 10;\n              }\n              putchar_unlocked(iVar2);\n            }\n            free(pcVar4);\n          }\n        }\n        return local_60;\n      }\n      if (iVar2 < 0x7b) break;\nswitchD_0010047d_caseD_67:\n      usage(1);\n    }\n    if (iVar2 < 0x65) {\n      if (iVar2 == -0x83) {\nLAB_001004d2:\n        uVar3 = proper_name_lite(\"Dmitry V. Levin\",\"Dmitry V. Levin\");\n        version_etc(_stdout,\"readlink\",\"GNU coreutils\",_Version,uVar3,0);\n                    /* WARNING: Subroutine does not return */\n        exit(0);\n      }\n      if (iVar2 == -0x82) {\n        usage(0);\n        goto LAB_001004d2;\n      }\n      goto switchD_0010047d_caseD_67;\n    }\n    switch(iVar2) {\n    case 0x65:\n      local_64 = 0;\n      break;\n    case 0x66:\n      local_64 = 1;\n      break;\n    default:\n      goto switchD_0010047d_caseD_67;\n    case 0x6d:\n      local_64 = 2;\n      break;\n    case 0x6e:\n      no_newline = '\\x01';\n      break;\n    case 0x71:\n    case 0x73:\n      verbose = '\\0';\n      break;\n    case 0x76:\n      verbose = '\\x01';\n      break;\n    case 0x7a:\n      bVar1 = true;\n    }\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "getopt_long",
                        "gettext",
                        "error",
                        "usage",
                        "getenv",
                        "areadlink_with_size",
                        "canonicalize_filename_mode",
                        "quotearg_n_style_colon",
                        "__errno_location",
                        "fputs_unlocked",
                        "putchar_unlocked",
                        "free",
                        "proper_name_lite",
                        "version_etc",
                        "exit"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "readlink_decompiled.c"
                }
            }
        ]
    }
}