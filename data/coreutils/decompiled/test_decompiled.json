{
    "file": "test",
    "decompiled_code": {
        "test.c": [
            {
                "func_name": "test_syntax_error",
                "func_c_signature": "void test_syntax_error(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                      undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                      undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12\n                      ,undefined8 param_13,undefined8 param_14)",
                "decompiled_code": "void test_syntax_error(undefined4 param_1,undefined4 param_2,undefined4 param_3,undefined4 param_4,\n                      undefined4 param_5,undefined4 param_6,undefined4 param_7,undefined4 param_8,\n                      undefined8 param_9,undefined8 param_10,undefined8 param_11,undefined8 param_12\n                      ,undefined8 param_13,undefined8 param_14) {\n  char in_AL;\n  long in_FS_OFFSET;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined8 local_c0;\n  undefined local_b8 [8];\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined4 local_88;\n  undefined4 local_78;\n  undefined4 local_68;\n  undefined4 local_58;\n  undefined4 local_48;\n  undefined4 local_38;\n  undefined4 local_28;\n  undefined4 local_18;\n  \n  if (in_AL != '\\0') {\n    local_88 = param_1;\n    local_78 = param_2;\n    local_68 = param_3;\n    local_58 = param_4;\n    local_48 = param_5;\n    local_38 = param_6;\n    local_28 = param_7;\n    local_18 = param_8;\n  }\n  local_c0 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  local_d8 = 8;\n  local_d4 = 0x30;\n  local_d0 = &stack0x00000008;\n  local_c8 = local_b8;\n  local_b0 = param_10;\n  local_a8 = param_11;\n  local_a0 = param_12;\n  local_98 = param_13;\n  local_90 = param_14;\n  verror(0,0,param_9,&local_d8);\n                    /* WARNING: Subroutine does not return */\n  exit(2);\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "test_syntax_error",
                        "verror",
                        "exit"
                    ],
                    "calling_functions": [
                        "test_syntax_error",
                        "beyond",
                        "find_int",
                        "term",
                        "binary_operator",
                        "unary_operator",
                        "three_arguments",
                        "main"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "advance",
                "func_c_signature": "void advance(char param_1)",
                "decompiled_code": "void advance(char param_1) {\n  pos = pos + 1;\n  if ((param_1 != '\\0') && (argc <= pos)) {\n    beyond();\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "advance",
                        "beyond"
                    ],
                    "calling_functions": [
                        "advance",
                        "unary_advance",
                        "term",
                        "binary_operator",
                        "and",
                        "or",
                        "two_arguments",
                        "three_arguments",
                        "posixtest"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "unary_advance",
                "func_c_signature": "void unary_advance(void)",
                "decompiled_code": "void unary_advance(void) {\n  advance(1);\n  pos = pos + 1;\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "unary_advance",
                        "advance"
                    ],
                    "calling_functions": [
                        "unary_advance",
                        "unary_operator"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "beyond",
                "func_c_signature": "void beyond(void)",
                "decompiled_code": "void beyond(void) {\n  undefined8 uVar1;\n  undefined8 uVar2;\n  \n  uVar1 = quote(*(undefined8 *)(argv + (long)argc * 8 + -8));\n  uVar2 = gettext(\"missing argument after %s\");\n                    /* WARNING: Subroutine does not return */\n  test_syntax_error(uVar2,uVar1);\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "beyond",
                        "quote",
                        "gettext",
                        "test_syntax_error"
                    ],
                    "calling_functions": [
                        "advance",
                        "beyond",
                        "term",
                        "expr",
                        "two_arguments"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "find_int",
                "func_c_signature": "char * find_int(char *param_1)",
                "decompiled_code": "char * find_int(char *param_1) {\n  ushort *puVar1;\n  byte bVar2;\n  char cVar3;\n  ushort **ppuVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  char *local_28;\n  char *local_20;\n  \n  local_28 = param_1;\n  while( true ) {\n    ppuVar4 = __ctype_b_loc();\n    puVar1 = *ppuVar4;\n    bVar2 = to_uchar((int)*local_28);\n    if ((puVar1[bVar2] & 0x2000) == 0) break;\n    local_28 = local_28 + 1;\n  }\n  if (*local_28 == '+') {\n    local_28 = local_28 + 1;\n    local_20 = local_28;\n  }\n  else {\n    local_20 = local_28;\n    local_28 = local_28 + (*local_28 == '-');\n  }\n  cVar3 = c_isdigit((int)*local_28);\n  if (cVar3 != '\\0') {\n    do {\n      local_28 = local_28 + 1;\n      cVar3 = c_isdigit((int)*local_28);\n    } while (cVar3 != '\\0');\n    while( true ) {\n      ppuVar4 = __ctype_b_loc();\n      puVar1 = *ppuVar4;\n      bVar2 = to_uchar((int)*local_28);\n      if ((puVar1[bVar2] & 0x2000) == 0) break;\n      local_28 = local_28 + 1;\n    }\n    if (*local_28 == '\\0') {\n      return local_20;\n    }\n  }\n  uVar5 = quote(param_1);\n  uVar6 = gettext(\"invalid integer %s\");\n                    /* WARNING: Subroutine does not return */\n  test_syntax_error(uVar6,uVar5);\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "find_int",
                        "__ctype_b_loc",
                        "to_uchar",
                        "c_isdigit",
                        "quote",
                        "gettext",
                        "test_syntax_error"
                    ],
                    "calling_functions": [
                        "find_int",
                        "binary_operator",
                        "unary_operator"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "get_mtime",
                "func_c_signature": "void get_mtime(char *param_1)",
                "decompiled_code": "void get_mtime(char *param_1) {\n  int iVar1;\n  long in_FS_OFFSET;\n  stat local_a8;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  iVar1 = stat(param_1,&local_a8);\n  if (iVar1 < 0) {\n    make_timespec(0x8000000000000000,0xffffffffffffffff);\n  }\n  else {\n    get_stat_mtime(&local_a8);\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "get_mtime",
                        "stat",
                        "make_timespec",
                        "get_stat_mtime",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "get_mtime",
                        "binary_operator"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "binop",
                "func_c_signature": "undefined8 binop(undefined8 param_1)",
                "decompiled_code": "undefined8 binop(undefined8 param_1) {\n  char cVar1;\n  undefined8 uVar2;\n  \n  cVar1 = streq(param_1,&DAT_00102530);\n  if (cVar1 == '\\0') {\n    cVar1 = streq(param_1,&DAT_00102532);\n    if (cVar1 == '\\0') {\n      cVar1 = streq(param_1,&DAT_00102535);\n      if (cVar1 == '\\0') {\n        cVar1 = streq(param_1,&DAT_00102538);\n        if (cVar1 == '\\0') {\n          cVar1 = streq(param_1,&DAT_0010253a);\n          if (cVar1 == '\\0') {\n            cVar1 = streq(param_1,&DAT_0010253c);\n            if (cVar1 == '\\0') {\n              cVar1 = streq(param_1,&DAT_00102540);\n              if (cVar1 == '\\0') {\n                cVar1 = streq(param_1,&DAT_00102544);\n                if (cVar1 == '\\0') {\n                  cVar1 = streq(param_1,&DAT_00102548);\n                  if (cVar1 == '\\0') {\n                    cVar1 = streq(param_1,&DAT_0010254c);\n                    if (cVar1 == '\\0') {\n                      cVar1 = streq(param_1,&DAT_00102550);\n                      if (cVar1 == '\\0') {\n                        cVar1 = streq(param_1,&DAT_00102554);\n                        if (cVar1 == '\\0') {\n                          cVar1 = streq(param_1,&DAT_00102558);\n                          if (cVar1 == '\\0') {\n                            cVar1 = streq(param_1,&DAT_0010255c);\n                            if (cVar1 == '\\0') {\n                              uVar2 = 0xffffffff;\n                            }\n                            else {\n                              uVar2 = 10;\n                            }\n                          }\n                          else {\n                            uVar2 = 0xb;\n                          }\n                        }\n                        else {\n                          uVar2 = 0xc;\n                        }\n                      }\n                      else {\n                        uVar2 = 5;\n                      }\n                    }\n                    else {\n                      uVar2 = 6;\n                    }\n                  }\n                  else {\n                    uVar2 = 7;\n                  }\n                }\n                else {\n                  uVar2 = 8;\n                }\n              }\n              else {\n                uVar2 = 9;\n              }\n            }\n            else {\n              uVar2 = 4;\n            }\n          }\n          else {\n            uVar2 = 2;\n          }\n        }\n        else {\n          uVar2 = 1;\n        }\n      }\n      else {\n        uVar2 = 3;\n      }\n    }\n    else {\n      uVar2 = 0;\n    }\n  }\n  else {\n    uVar2 = 0;\n  }\n  return uVar2;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "binop",
                        "streq"
                    ],
                    "calling_functions": [
                        "binop",
                        "term",
                        "three_arguments"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "term",
                "func_c_signature": "bool term(void)",
                "decompiled_code": "bool term(void) {\n  char cVar1;\n  int iVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  char local_22;\n  bool local_21;\n  int local_20;\n  \n  local_21 = false;\n  while (((pos < argc && (**(char **)(argv + (long)pos * 8) == '!')) &&\n         (*(char *)(*(long *)(argv + (long)pos * 8) + 1) == '\\0'))) {\n    advance(1);\n    local_21 = local_21 == false;\n  }\n  if (argc <= pos) {\n    beyond();\n  }\n  if ((**(char **)(argv + (long)pos * 8) == '(') &&\n     (*(char *)(*(long *)(argv + (long)pos * 8) + 1) == '\\0')) {\n    advance(1);\n    for (local_20 = 1; pos + local_20 < argc; local_20 = local_20 + 1) {\n      cVar1 = streq(*(undefined8 *)(argv + (long)(local_20 + pos) * 8),&DAT_00102560);\n      if (cVar1 == '\\x01') break;\n      if (local_20 == 4) {\n        local_20 = argc - pos;\n        break;\n      }\n    }\n    local_22 = posixtest(local_20);\n    if (*(long *)(argv + (long)pos * 8) == 0) {\n      uVar3 = quote(&DAT_00102560);\n      uVar4 = gettext(\"%s expected\");\n                    /* WARNING: Subroutine does not return */\n      test_syntax_error(uVar4,uVar3);\n    }\n    if ((**(char **)(argv + (long)pos * 8) != ')') ||\n       (*(char *)(*(long *)(argv + (long)pos * 8) + 1) != '\\0')) {\n      uVar3 = quote_n(1,*(undefined8 *)(argv + (long)pos * 8));\n      uVar4 = quote_n(0,&DAT_00102560);\n      uVar5 = gettext(\"%s expected, found %s\");\n                    /* WARNING: Subroutine does not return */\n      test_syntax_error(uVar5,uVar4,uVar3);\n    }\n    advance(0);\n  }\n  else {\n    if (3 < argc - pos) {\n      cVar1 = streq(*(undefined8 *)(argv + (long)pos * 8),&DAT_00102584);\n      if (cVar1 != '\\0') {\n        iVar2 = binop(*(undefined8 *)(argv + ((long)pos + 2) * 8));\n        if (-1 < iVar2) {\n          local_22 = binary_operator(1,iVar2);\n          goto LAB_00100be6;\n        }\n      }\n    }\n    if (2 < argc - pos) {\n      iVar2 = binop(*(undefined8 *)(argv + ((long)pos + 1) * 8));\n      if (-1 < iVar2) {\n        local_22 = binary_operator(0,iVar2);\n        goto LAB_00100be6;\n      }\n    }\n    if (((**(char **)(argv + (long)pos * 8) == '-') &&\n        (*(char *)(*(long *)(argv + (long)pos * 8) + 1) != '\\0')) &&\n       (*(char *)(*(long *)(argv + (long)pos * 8) + 2) == '\\0')) {\n      local_22 = unary_operator();\n    }\n    else {\n      local_22 = **(char **)(argv + (long)pos * 8) != '\\0';\n      advance(0);\n    }\n  }\nLAB_00100be6:\n  return local_21 != (bool)local_22;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "term",
                        "advance",
                        "beyond",
                        "streq",
                        "posixtest",
                        "quote",
                        "gettext",
                        "test_syntax_error",
                        "quote_n",
                        "binop",
                        "binary_operator",
                        "unary_operator"
                    ],
                    "calling_functions": [
                        "term",
                        "and"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "binary_operator",
                "func_c_signature": "uint binary_operator(byte param_1,int param_2)",
                "decompiled_code": "uint binary_operator(byte param_1,int param_2) {\n  char cVar1;\n  byte bVar2;\n  int iVar3;\n  uint uVar4;\n  int iVar5;\n  size_t sVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  long in_FS_OFFSET;\n  undefined auVar9 [16];\n  undefined auVar10 [16];\n  stat local_188;\n  stat local_f8;\n  undefined local_68 [32];\n  undefined local_48 [24];\n  long local_30;\n  \n  local_30 = *(long *)(in_FS_OFFSET + 0x28);\n  if (param_1 != 0) {\n    advance(0);\n  }\n  iVar3 = pos + 1;\n  if ((iVar3 < argc + -2) &&\n     (cVar1 = streq(*(undefined8 *)(argv + ((long)iVar3 + 1) * 8),&DAT_00102584), cVar1 != '\\0')) {\n    bVar2 = 1;\n  }\n  else {\n    bVar2 = 0;\n  }\n  if (bVar2 != 0) {\n    advance(0);\n  }\n  pos = pos + 3;\n  switch(param_2) {\n  case 0:\n  case 3:\n    cVar1 = streq(*(undefined8 *)(argv + (long)iVar3 * 8 + -8),\n                  *(undefined8 *)(argv + ((long)iVar3 + 1) * 8));\n    uVar4 = (uint)((bool)cVar1 == (param_2 == 0));\n    break;\n  case 1:\n  case 2:\n    uVar4 = strcoll(*(char **)(argv + (long)iVar3 * 8 + -8),*(char **)(argv + ((long)iVar3 + 1) * 8)\n                   );\n    if (param_2 == 2) {\n      uVar4 = uVar4 >> 0x1f;\n    }\n    else {\n      uVar4 = (uint)(0 < (int)uVar4);\n    }\n    break;\n  case 4:\n  case 5:\n  case 6:\n  case 7:\n  case 8:\n  case 9:\n    if (param_1 == 0) {\n      uVar8 = find_int(*(undefined8 *)(argv + (long)iVar3 * 8 + -8));\n    }\n    else {\n      sVar6 = strlen(*(char **)(argv + (long)iVar3 * 8 + -8));\n      uVar8 = umaxtostr(sVar6,local_68);\n    }\n    if (bVar2 == 0) {\n      uVar7 = find_int(*(undefined8 *)(argv + ((long)iVar3 + 1) * 8));\n    }\n    else {\n      sVar6 = strlen(*(char **)(argv + ((long)iVar3 + 2) * 8));\n      uVar7 = umaxtostr(sVar6,local_48);\n    }\n    strintcmp(uVar8,uVar7);\n                    /* WARNING: Could not recover jumptable at 0x00100e2d. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n    uVar4 = (*(code *)(&DAT_0010263c + *(int *)(&DAT_0010263c + (ulong)(param_2 - 4) * 4)))();\n    return uVar4;\n  case 10:\n    if ((param_1 | bVar2) != 0) {\n      uVar8 = gettext(\"-ef does not accept -l\");\n                    /* WARNING: Subroutine does not return */\n      test_syntax_error(uVar8);\n    }\n    iVar5 = stat(*(char **)(argv + (long)iVar3 * 8 + -8),&local_188);\n    if (((iVar5 == 0) &&\n        (iVar3 = stat(*(char **)(argv + ((long)iVar3 + 1) * 8),&local_f8), iVar3 == 0)) &&\n       (cVar1 = psame_inode(&local_188,&local_f8), cVar1 != '\\0')) {\n      uVar4 = 1;\n    }\n    else {\n      uVar4 = 0;\n    }\n    break;\n  case 0xb:\n  case 0xc:\n    if ((param_1 | bVar2) != 0) {\n      uVar8 = *(undefined8 *)(argv + (long)iVar3 * 8);\n      uVar7 = gettext(\"%s does not accept -l\");\n                    /* WARNING: Subroutine does not return */\n      test_syntax_error(uVar7,uVar8);\n    }\n    auVar9 = get_mtime(*(undefined8 *)(argv + ((long)iVar3 + 1) * 8));\n    auVar10 = get_mtime(*(undefined8 *)(argv + (long)iVar3 * 8 + -8));\n    uVar4 = timespec_cmp(auVar10._0_8_,auVar10._8_8_,auVar9._0_8_,auVar9._8_8_);\n    if (param_2 == 0xc) {\n      uVar4 = uVar4 >> 0x1f;\n    }\n    else {\n      uVar4 = (uint)(0 < (int)uVar4);\n    }\n    break;\n  default:\n                    /* WARNING: Subroutine does not return */\n    __assert_fail(\"0\",\n                  \"/workspace/home/aiclub1/B220032CS_Jaefar/fyp/repos/ansaf/coreutils/src/test.c\",\n                  0x16b,\"binary_operator\");\n  }\n  if (local_30 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar4;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "binary_operator",
                        "advance",
                        "streq",
                        "strcoll",
                        "find_int",
                        "strlen",
                        "umaxtostr",
                        "strintcmp",
                        "gettext",
                        "test_syntax_error",
                        "stat",
                        "psame_inode",
                        "get_mtime",
                        "timespec_cmp",
                        "__assert_fail",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "term",
                        "binary_operator",
                        "three_arguments"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "unary_operator",
                "func_c_signature": "bool unary_operator(void)",
                "decompiled_code": "bool unary_operator(void) {\n  int iVar1;\n  __uid_t _Var2;\n  __gid_t _Var3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  long lVar7;\n  long in_FS_OFFSET;\n  bool bVar8;\n  undefined auVar9 [16];\n  undefined auVar10 [16];\n  stat local_b8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  switch(*(undefined *)(*(long *)(argv + (long)pos * 8) + 1)) {\n  case 0x47:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    if (iVar1 == 0) {\n      piVar6 = __errno_location();\n      *piVar6 = 0;\n      _Var3 = getegid();\n      if (((_Var3 == 0xffffffff) && (piVar6 = __errno_location(), *piVar6 != 0)) ||\n         (_Var3 != local_b8.st_gid)) {\n        bVar8 = false;\n      }\n      else {\n        bVar8 = true;\n      }\n    }\n    else {\n      bVar8 = false;\n    }\n    break;\n  default:\n    uVar4 = quote(*(undefined8 *)(argv + (long)pos * 8));\n    uVar5 = gettext(\"%s: unary operator expected\");\n                    /* WARNING: Subroutine does not return */\n    test_syntax_error(uVar5,uVar4);\n  case 0x4c:\n  case 0x68:\n    unary_advance();\n    iVar1 = issymlink(*(undefined8 *)(argv + (long)pos * 8 + -8));\n    bVar8 = iVar1 == 1;\n    break;\n  case 0x4e:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    if (iVar1 == 0) {\n      auVar9 = get_stat_atime(&local_b8);\n      auVar10 = get_stat_mtime(&local_b8);\n      iVar1 = timespec_cmp(auVar10._0_8_,auVar10._8_8_,auVar9._0_8_,auVar9._8_8_);\n      bVar8 = 0 < iVar1;\n    }\n    else {\n      bVar8 = false;\n    }\n    break;\n  case 0x4f:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    if (iVar1 == 0) {\n      piVar6 = __errno_location();\n      *piVar6 = 0;\n      _Var2 = geteuid();\n      if (((_Var2 == 0xffffffff) && (piVar6 = __errno_location(), *piVar6 != 0)) ||\n         (_Var2 != local_b8.st_uid)) {\n        bVar8 = false;\n      }\n      else {\n        bVar8 = true;\n      }\n    }\n    else {\n      bVar8 = false;\n    }\n    break;\n  case 0x53:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    if ((iVar1 == 0) && ((local_b8.st_mode & 0xf000) == 0xc000)) {\n      bVar8 = true;\n    }\n    else {\n      bVar8 = false;\n    }\n    break;\n  case 0x62:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    if ((iVar1 == 0) && ((local_b8.st_mode & 0xf000) == 0x6000)) {\n      bVar8 = true;\n    }\n    else {\n      bVar8 = false;\n    }\n    break;\n  case 99:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    if ((iVar1 == 0) && ((local_b8.st_mode & 0xf000) == 0x2000)) {\n      bVar8 = true;\n    }\n    else {\n      bVar8 = false;\n    }\n    break;\n  case 100:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    if ((iVar1 == 0) && ((local_b8.st_mode & 0xf000) == 0x4000)) {\n      bVar8 = true;\n    }\n    else {\n      bVar8 = false;\n    }\n    break;\n  case 0x65:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    bVar8 = iVar1 == 0;\n    break;\n  case 0x66:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    if ((iVar1 == 0) && ((local_b8.st_mode & 0xf000) == 0x8000)) {\n      bVar8 = true;\n    }\n    else {\n      bVar8 = false;\n    }\n    break;\n  case 0x67:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    if ((iVar1 == 0) && ((local_b8.st_mode & 0x400) != 0)) {\n      bVar8 = true;\n    }\n    else {\n      bVar8 = false;\n    }\n    break;\n  case 0x6b:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    if ((iVar1 == 0) && ((local_b8.st_mode & 0x200) != 0)) {\n      bVar8 = true;\n    }\n    else {\n      bVar8 = false;\n    }\n    break;\n  case 0x6e:\n    unary_advance();\n    bVar8 = **(char **)(argv + (long)pos * 8 + -8) != '\\0';\n    break;\n  case 0x70:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    if ((iVar1 == 0) && ((local_b8.st_mode & 0xf000) == 0x1000)) {\n      bVar8 = true;\n    }\n    else {\n      bVar8 = false;\n    }\n    break;\n  case 0x72:\n    unary_advance();\n    iVar1 = euidaccess(*(char **)(argv + (long)pos * 8 + -8),4);\n    bVar8 = iVar1 == 0;\n    break;\n  case 0x73:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    if ((iVar1 == 0) && (0 < local_b8.st_size)) {\n      bVar8 = true;\n    }\n    else {\n      bVar8 = false;\n    }\n    break;\n  case 0x74:\n    unary_advance();\n    uVar4 = find_int(*(undefined8 *)(argv + (long)pos * 8 + -8));\n    piVar6 = __errno_location();\n    *piVar6 = 0;\n    lVar7 = __isoc23_strtol(uVar4,0,10);\n    piVar6 = __errno_location();\n    if ((((*piVar6 == 0x22) || (lVar7 < 0)) || (0x7fffffff < lVar7)) ||\n       (iVar1 = isatty((int)lVar7), iVar1 == 0)) {\n      bVar8 = false;\n    }\n    else {\n      bVar8 = true;\n    }\n    break;\n  case 0x75:\n    unary_advance();\n    iVar1 = stat(*(char **)(argv + (long)pos * 8 + -8),&local_b8);\n    if ((iVar1 == 0) && ((local_b8.st_mode & 0x800) != 0)) {\n      bVar8 = true;\n    }\n    else {\n      bVar8 = false;\n    }\n    break;\n  case 0x77:\n    unary_advance();\n    iVar1 = euidaccess(*(char **)(argv + (long)pos * 8 + -8),2);\n    bVar8 = iVar1 == 0;\n    break;\n  case 0x78:\n    unary_advance();\n    iVar1 = euidaccess(*(char **)(argv + (long)pos * 8 + -8),1);\n    bVar8 = iVar1 == 0;\n    break;\n  case 0x7a:\n    unary_advance();\n    bVar8 = **(char **)(argv + (long)pos * 8 + -8) == '\\0';\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return bVar8;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "unary_operator",
                        "unary_advance",
                        "stat",
                        "__errno_location",
                        "getegid",
                        "quote",
                        "gettext",
                        "test_syntax_error",
                        "issymlink",
                        "get_stat_atime",
                        "get_stat_mtime",
                        "timespec_cmp",
                        "geteuid",
                        "euidaccess",
                        "find_int",
                        "__isoc23_strtol",
                        "isatty",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "term",
                        "unary_operator",
                        "two_arguments"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "and",
                "func_c_signature": "bool and(void)",
                "decompiled_code": "bool and(void) {\n  byte bVar1;\n  char cVar2;\n  bool local_9;\n  \n  local_9 = true;\n  while( true ) {\n    bVar1 = term();\n    local_9 = (bVar1 & local_9) != 0;\n    if (argc <= pos) {\n      return local_9;\n    }\n    cVar2 = streq(*(undefined8 *)(argv + (long)pos * 8),&DAT_00102740);\n    if (cVar2 != '\\x01') break;\n    advance(0);\n  }\n  return local_9;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "and",
                        "term",
                        "streq",
                        "advance"
                    ],
                    "calling_functions": [
                        "and",
                        "or"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "or",
                "func_c_signature": "bool or(void)",
                "decompiled_code": "bool or(void) {\n  byte bVar1;\n  char cVar2;\n  bool local_9;\n  \n  local_9 = false;\n  while( true ) {\n    bVar1 = and();\n    local_9 = (bVar1 | local_9) != 0;\n    if (argc <= pos) {\n      return local_9;\n    }\n    cVar2 = streq(*(undefined8 *)(argv + (long)pos * 8),&DAT_00102743);\n    if (cVar2 != '\\x01') break;\n    advance(0);\n  }\n  return local_9;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "or",
                        "and",
                        "streq",
                        "advance"
                    ],
                    "calling_functions": [
                        "or",
                        "expr"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "expr",
                "func_c_signature": "void expr(void)",
                "decompiled_code": "void expr(void) {\n  if (argc <= pos) {\n    beyond();\n  }\n  or();\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "expr",
                        "beyond",
                        "or"
                    ],
                    "calling_functions": [
                        "expr",
                        "three_arguments",
                        "posixtest"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "one_argument",
                "func_c_signature": "bool one_argument(void)",
                "decompiled_code": "bool one_argument(void) {\n  int iVar1;\n  \n  iVar1 = pos;\n  pos = pos + 1;\n  return **(char **)((long)iVar1 * 8 + argv) != '\\0';\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "one_argument"
                    ],
                    "calling_functions": [
                        "one_argument",
                        "two_arguments",
                        "three_arguments",
                        "posixtest"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "two_arguments",
                "func_c_signature": "undefined two_arguments(void)",
                "decompiled_code": "undefined two_arguments(void) {\n  char cVar1;\n  undefined local_9;\n  \n  cVar1 = streq(*(undefined8 *)(argv + (long)pos * 8),&DAT_00102746);\n  if (cVar1 == '\\0') {\n    if (((**(char **)(argv + (long)pos * 8) == '-') &&\n        (*(char *)(*(long *)(argv + (long)pos * 8) + 1) != '\\0')) &&\n       (*(char *)(*(long *)(argv + (long)pos * 8) + 2) == '\\0')) {\n      local_9 = unary_operator();\n    }\n    else {\n      beyond();\n    }\n  }\n  else {\n    advance(0);\n    cVar1 = one_argument();\n    local_9 = cVar1 == '\\0';\n  }\n  return local_9;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "two_arguments",
                        "streq",
                        "unary_operator",
                        "beyond",
                        "advance",
                        "one_argument"
                    ],
                    "calling_functions": [
                        "two_arguments",
                        "three_arguments",
                        "posixtest"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "three_arguments",
                "func_c_signature": "undefined three_arguments(void)",
                "decompiled_code": "undefined three_arguments(void) {\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined local_1d;\n  \n  iVar3 = binop(*(undefined8 *)(argv + ((long)pos + 1) * 8));\n  if (iVar3 < 0) {\n    cVar1 = streq(*(undefined8 *)(argv + (long)pos * 8),&DAT_00102746);\n    if (cVar1 == '\\0') {\n      cVar1 = streq(*(undefined8 *)(argv + (long)pos * 8),&DAT_00102748);\n      if ((cVar1 != '\\0') &&\n         (cVar1 = streq(*(undefined8 *)(argv + ((long)pos + 2) * 8),&DAT_00102560), cVar1 != '\\0'))\n      {\n        advance(0);\n        uVar2 = one_argument();\n        advance(0);\n        return uVar2;\n      }\n      cVar1 = streq(*(undefined8 *)(argv + ((long)pos + 1) * 8),&DAT_00102740);\n      if ((((cVar1 == '\\0') &&\n           (cVar1 = streq(*(undefined8 *)(argv + ((long)pos + 1) * 8),&DAT_00102743), cVar1 == '\\0')\n           ) && (cVar1 = streq(*(undefined8 *)(argv + ((long)pos + 1) * 8),&DAT_00102538),\n                cVar1 == '\\0')) &&\n         (cVar1 = streq(*(undefined8 *)(argv + ((long)pos + 1) * 8),&DAT_0010253a), cVar1 == '\\0'))\n      {\n        uVar4 = quote(*(undefined8 *)(argv + ((long)pos + 1) * 8));\n        uVar5 = gettext(\"%s: binary operator expected\");\n                    /* WARNING: Subroutine does not return */\n        test_syntax_error(uVar5,uVar4);\n      }\n      local_1d = expr();\n    }\n    else {\n      advance(1);\n      cVar1 = two_arguments();\n      local_1d = cVar1 == '\\0';\n    }\n  }\n  else {\n    local_1d = binary_operator(0,iVar3);\n  }\n  return local_1d;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "three_arguments",
                        "binop",
                        "streq",
                        "advance",
                        "one_argument",
                        "quote",
                        "gettext",
                        "test_syntax_error",
                        "expr",
                        "two_arguments",
                        "binary_operator"
                    ],
                    "calling_functions": [
                        "three_arguments",
                        "posixtest"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "posixtest",
                "func_c_signature": "undefined posixtest(int param_1)",
                "decompiled_code": "undefined posixtest(int param_1) {\n  char cVar1;\n  undefined uVar2;\n  \n  if (param_1 == 4) {\n    cVar1 = streq(*(undefined8 *)(argv + (long)pos * 8),&DAT_00102746);\n    if (cVar1 != '\\0') {\n      advance(1);\n      cVar1 = three_arguments();\n      return cVar1 == '\\0';\n    }\n    cVar1 = streq(*(undefined8 *)(argv + (long)pos * 8),&DAT_00102748);\n    if ((cVar1 != '\\0') &&\n       (cVar1 = streq(*(undefined8 *)(argv + ((long)pos + 3) * 8),&DAT_00102560), cVar1 != '\\0')) {\n      advance(0);\n      uVar2 = two_arguments();\n      advance(0);\n      return uVar2;\n    }\n  }\n  else if (param_1 < 5) {\n    if (param_1 == 3) {\n      uVar2 = three_arguments();\n      return uVar2;\n    }\n    if (param_1 < 4) {\n      if (param_1 == 1) {\n        uVar2 = one_argument();\n        return uVar2;\n      }\n      if (param_1 == 2) {\n        uVar2 = two_arguments();\n        return uVar2;\n      }\n    }\n  }\n  if (0 < param_1) {\n    uVar2 = expr();\n    return uVar2;\n  }\n                    /* WARNING: Subroutine does not return */\n  __assert_fail(\"0 < nargs\",\n                \"/workspace/home/aiclub1/B220032CS_Jaefar/fyp/repos/ansaf/coreutils/src/test.c\",\n                0x28c,\"posixtest\");\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "posixtest",
                        "streq",
                        "advance",
                        "three_arguments",
                        "two_arguments",
                        "one_argument",
                        "expr",
                        "__assert_fail"
                    ],
                    "calling_functions": [
                        "term",
                        "posixtest",
                        "main"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  \n  uVar3 = _program_name;\n  pFVar1 = _stdout;\n  if (param_1 == 0) {\n    pcVar2 = (char *)gettext(\n                            \"Usage: test EXPRESSION\\n  or:  test\\n  or:  [ EXPRESSION ]\\n  or:  [ ]\\n  or:  [ OPTION\\n\"\n                            );\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\"Exit with the status determined by EXPRESSION.\\n\\n\");\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\n                            \"\\nAn omitted EXPRESSION defaults to false.  Otherwise,\\nEXPRESSION is true or false and sets exit status.  It is one of:\\n\"\n                            );\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\n                            \"\\n  ( EXPRESSION )               EXPRESSION is true\\n  ! EXPRESSION                 EXPRESSION is false\\n  EXPRESSION1 -a EXPRESSION2   both EXPRESSION1 and EXPRESSION2 are true\\n  EXPRESSION1 -o EXPRESSION2   either EXPRESSION1 or EXPRESSION2 is true\\n\"\n                            );\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\n                            \"\\n  -n STRING            the length of STRING is nonzero\\n  STRING               equivalent to -n STRING\\n  -z STRING            the length of STRING is zero\\n  STRING1 = STRING2    the strings are equal\\n  STRING1 != STRING2   the strings are not equal\\n  STRING1 > STRING2    STRING1 is greater than STRING2 in the current locale\\n  STRING1 < STRING2    STRING1 is less than STRING2 in the current locale\\n\"\n                            );\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\n                            \"\\n  INTEGER1 -eq INTEGER2   INTEGER1 is equal to INTEGER2\\n  INTEGER1 -ge INTEGER2   INTEGER1 is greater than or equal to INTEGER2\\n  INTEGER1 -gt INTEGER2   INTEGER1 is greater than INTEGER2\\n  INTEGER1 -le INTEGER2   INTEGER1 is less than or equal to INTEGER2\\n  INTEGER1 -lt INTEGER2   INTEGER1 is less than INTEGER2\\n  INTEGER1 -ne INTEGER2   INTEGER1 is not equal to INTEGER2\\n\"\n                            );\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\n                            \"\\n  FILE1 -ef FILE2   FILE1 and FILE2 have the same device and inode numbers\\n  FILE1 -nt FILE2   FILE1 is newer (modification date) than FILE2\\n  FILE1 -ot FILE2   FILE1 is older than FILE2\\n\"\n                            );\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\n                            \"\\n  -b FILE     FILE exists and is block special\\n  -c FILE     FILE exists and is character special\\n  -d FILE     FILE exists and is a directory\\n  -e FILE     FILE exists\\n\"\n                            );\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\n                            \"  -f FILE     FILE exists and is a regular file\\n  -g FILE     FILE exists and is set-group-ID\\n  -G FILE     FILE exists and is owned by the effective group ID\\n  -h FILE     FILE exists and is a symbolic link (same as -L)\\n  -k FILE     FILE exists and has its sticky bit set\\n\"\n                            );\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\n                            \"  -L FILE     FILE exists and is a symbolic link (same as -h)\\n  -N FILE     FILE exists and has been modified since it was last read\\n  -O FILE     FILE exists and is owned by the effective user ID\\n  -p FILE     FILE exists and is a named pipe\\n  -r FILE     FILE exists and the user has read access\\n  -s FILE     FILE exists and has a size greater than zero\\n\"\n                            );\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\n                            \"  -S FILE     FILE exists and is a socket\\n  -t FD       file descriptor FD is opened on a terminal\\n  -u FILE     FILE exists and its set-user-ID bit is set\\n  -w FILE     FILE exists and the user has write access\\n  -x FILE     FILE exists and the user has execute (or search) access\\n\"\n                            );\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\n                            \"\\nExcept for -h and -L, all FILE-related tests dereference symbolic links.\\nBeware that parentheses need to be escaped (e.g., by backslashes) for shells.\\nINTEGER may also be -l STRING, which evaluates to the length of STRING.\\n\"\n                            );\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\n                            \"\\nBinary -a and -o are ambiguous.  Use \\'test EXPR1 && test EXPR2\\'\\nor \\'test EXPR1 || test EXPR2\\' instead.\\n\"\n                            );\n    fputs_unlocked(pcVar2,pFVar1);\n    pFVar1 = _stdout;\n    pcVar2 = (char *)gettext(\n                            \"\\n\\'[\\' honors --help and --version, but \\'test\\' treats them as STRINGs.\\n\"\n                            );\n    fputs_unlocked(pcVar2,pFVar1);\n    uVar3 = gettext(\"test and/or [\");\n    pcVar2 = (char *)gettext(\n                            \"\\nYour shell may have its own version of %s, which usually supersedes\\nthe version described here.  Please refer to your shell\\'s documentation\\nfor details about the options it supports.\\n\"\n                            );\n    printf(pcVar2,uVar3);\n    emit_ancillary_info(&DAT_00102477);\n  }\n  else {\n    pcVar2 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar2,uVar3);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "n",
                    "newer",
                    "link",
                    "execute",
                    "escaped"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "fputs_unlocked",
                        "n",
                        "newer",
                        "link",
                        "execute",
                        "escaped",
                        "printf",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "byte main(int param_1,undefined8 *param_2)",
                "decompiled_code": "byte main(int param_1,undefined8 *param_2) {\n  byte bVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  \n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  initialize_exit_failure(2);\n  atexit((__func *)&close_stdout);\n  pos = 1;\n  argc = param_1;\n  argv = param_2;\n  if (param_1 < 2) {\n    bVar1 = 1;\n  }\n  else {\n    bVar1 = posixtest(param_1 + -1);\n    if (pos != argc) {\n      uVar2 = quote(argv[pos]);\n      uVar3 = gettext(\"extra argument %s\");\n                    /* WARNING: Subroutine does not return */\n      test_syntax_error(uVar3,uVar2);\n    }\n    bVar1 = bVar1 ^ 1;\n  }\n  return bVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "initialize_exit_failure",
                        "atexit",
                        "posixtest",
                        "quote",
                        "gettext",
                        "test_syntax_error"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "test_decompiled.c"
                }
            }
        ]
    }
}