#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h> // For uint32_t, uint64_t, intptr_t
#include <time.h>   // For srandom() if used, not explicitly in snippet's logic

// --- External declarations for missing functions and global variables ---
// These are assumed to be defined elsewhere in the project or are mock implementations for compilation.

// Function declarations
extern int recvdgram(void);
extern void create_resp_pkt(char *pkt, const char *msg);
extern int senddgram(void);
extern int sendline(void); // Used in getrand error path
extern int streq(const char *s1, const char *s2); // Likely equivalent to !strcmp(s1, s2)
extern uint32_t str2uint(const char *s); // Likely equivalent to atoi or strtoul
extern int startswith(const char *s, const char *prefix);

// Global variables
extern char *curpkt; // Used as char* for string ops and sometimes cast to uint32_t* for header access
extern const char DAT_00013000[]; // A string literal or data block address for error messages

// --- Custom types from snippet (mapped to standard C types) ---
// These types are often generated by disassemblers.
typedef uint32_t undefined4;
typedef uint64_t undefined8;
typedef char undefined; // Represents a byte in memory
typedef unsigned int uint; // Assuming 32-bit unsigned int for 'uint'

// --- Global data store for do_put/do_get/do_rand ---
#define MAX_QSS_ENTRIES 0x800
#define QSS_KEY_SIZE 0x80
#define QSS_VALUE_SIZE 0x100
#define QSS_ENTRY_SIZE (QSS_KEY_SIZE + QSS_VALUE_SIZE) // Total size of one key-value pair

char qss[MAX_QSS_ENTRIES * QSS_ENTRY_SIZE];
int numentries = 0; // Current number of entries stored in qss

// DAT_000150a0 is interpreted as the base address for the value parts of the qss entries.
// It points to the value part of the first entry (qss[0] + QSS_KEY_SIZE).
char *DAT_000150a0 = &qss[QSS_KEY_SIZE]; // Points to the value part of the first entry

// --- Helper function for termination ---
// Replaces _terminate() calls from the original snippet.
void _terminate(void) {
    exit(1);
}

// Function: do_put
int do_put(void) {
    if (numentries >= MAX_QSS_ENTRIES) {
        return 0; // Max entries reached, cannot add more
    }

    char *key_ptr = curpkt + 8; // Key starts at offset 8 in curpkt
    size_t key_len = strlen(key_ptr);

    if (key_len >= QSS_KEY_SIZE) { // Key too long
        return 0;
    }

    char *value_ptr = key_ptr + key_len + 1; // Value starts after key and its null terminator
    size_t value_len = strlen(value_ptr);

    if (value_len >= QSS_VALUE_SIZE) { // Value too long
        return 0;
    }

    // Check for existing entry with the same key
    for (unsigned int i = 0; i < numentries; ++i) {
        if (streq(key_ptr, qss + i * QSS_ENTRY_SIZE)) {
            return 0; // Key already exists, cannot add duplicate
        }
    }

    // Add new entry
    strcpy(qss + numentries * QSS_ENTRY_SIZE, key_ptr);
    strcpy(qss + numentries * QSS_ENTRY_SIZE + QSS_KEY_SIZE, value_ptr);
    numentries++;

    create_resp_pkt(curpkt, "Information upload complete.");
    return (int)(intptr_t)curpkt; // Return curpkt address as a success indicator (non-zero)
}

// Function: easteregg
int easteregg(void) {
    char *p = curpkt + 7;

    // Find the first 'B' or the end of the string
    while (*p != 'B' && *p != '\0') {
        p++;
    }

    // If a 'B' was found, skip all subsequent 'B's in the sequence
    if (*p == 'B') {
        while (*p == 'B' && *p != '\0') {
            p++;
        }
    }
    
    // Write the easter egg message starting from the position 'p'
    strcpy(p, "If you do things right, people won't be sure that you've done anything at all...");
    return (int)(intptr_t)curpkt; // Return curpkt address as a success indicator (non-zero)
}

// Function: getrand
undefined8 getrand(undefined4 param_1) { // param_1 is uint32_t
    // The original logic terminates if random() is non-zero.
    // This implies that random() == 0 is the "success" path for this specific function.
    if (random() != 0) {
        // The original snippet had a sendline() call as part of an error/termination sequence.
        _terminate(); 
    }

    // If random() returns 0, the function proceeds to calculate a fixed value.
    // The variables local_28, local_24, local_14 from the snippet are used.
    // They are either fixed values or from uninitialized stack locations in the original code.
    // For compilability and deterministic behavior, we use explicit initializations.
    uint32_t local_28_val = 1; // Assumed from context (local_20 = 1, often copied or default)
    uint32_t local_14_val = 4; // Explicitly initialized in snippet
    uint32_t local_24_val = 0; // Uninitialized in snippet, assumed 0 for safety

    // CONCAT44(high, low) means ( (uint64_t)high << 32 ) | low
    // CARRY4(a, b) indicates if (uint32_t)a + (uint32_t)b would produce a carry.
    uint32_t low_part = local_28_val + local_14_val;
    uint32_t carry_flag = (local_28_val > (UINT32_MAX - local_14_val)) ? 1 : 0;
    uint32_t high_part = local_24_val + carry_flag;

    return ((uint64_t)high_part << 32) | low_part;
}

// Function: do_rand
int do_rand(void) {
    uint32_t rand_param = 4; // Default value from local_10 initialization in snippet

    if (numentries == 0) {
        return 0; // No entries to operate on
    }

    // If curpkt + 8 contains a non-empty string, convert it to a uint
    if (*(curpkt + 8) != '\0') {
        rand_param = str2uint(curpkt + 8);
    }

    if (rand_param >= 9) {
        return 0; // Parameter out of expected range
    }

    uint64_t lVar2 = getrand(rand_param);

    // Check for the easter egg condition
    if (lVar2 == 0x3127a1b73ULL && startswith(curpkt + 10, "0101010101010101")) {
        return easteregg();
    } else {
        // As interpreted, DAT_000150a0 points to the value part of the first entry.
        // The original expression (0U % numentries) * 0x180 + 0x150a0
        // simplifies to 0 * QSS_ENTRY_SIZE + DAT_000150a0 (if numentries > 0).
        // This means it always returns the value of the first entry.
        create_resp_pkt(curpkt, DAT_000150a0);
        return (int)(intptr_t)curpkt; // Return curpkt address as a success indicator (non-zero)
    }
}

// Function: do_get
int do_get(void) {
    unsigned int i = 0;

    while (i < numentries) {
        // Compare key from curpkt with the key stored in qss
        if (streq(curpkt + 8, qss + i * QSS_ENTRY_SIZE)) {
            // Key found, return the corresponding value.
            // DAT_000150a0 is the base for values, so add offset for the specific entry.
            create_resp_pkt(curpkt, DAT_000150a0 + i * QSS_ENTRY_SIZE);
            return (int)(intptr_t)curpkt; // Return curpkt address as a success indicator (non-zero)
        }
        i++;
    }

    create_resp_pkt(curpkt, "Not found.");
    return (int)(intptr_t)curpkt; // Return curpkt address as a success indicator (non-zero)
}

// Function: process_next_dgram
undefined4 process_next_dgram(void) { // Returns uint32_t
    int recv_status;
    uint32_t *operation_result = NULL; // Pointer to the result of do_put/get/rand

    recv_status = recvdgram();
    if (recv_status < 0) {
        // If receive fails, attempt to create and send a response, then terminate.
        create_resp_pkt(curpkt, DAT_00013000);
        recv_status = senddgram();
        if (recv_status < 0) {
            _terminate(); // Terminate if sending response also fails
        }
        _terminate(); // Always terminate after initial recvdgram failure path
    }

    // Assuming curpkt is a char* that can be cast to uint32_t* to access header fields.
    uint32_t packet_type = ((uint32_t*)curpkt)[1];

    if (packet_type == 2) {
        operation_result = (uint32_t *)do_rand();
    } else if (packet_type == 0) {
        operation_result = (uint32_t *)do_put();
    } else if (packet_type == 1) {
        operation_result = (uint32_t *)do_get();
    } else {
        return 0xffffffff; // Invalid packet type
    }

    if (operation_result == NULL) { // Operation failed (e.g., do_put/get/rand returned 0)
        return 0xfffffffe;
    } else { // Operation successful
        // The original snippet had specific stack writes here,
        // which are decompilation artifacts and not needed for standard C.
        recv_status = senddgram();
        if (recv_status < 0) {
            _terminate(); // Terminate if sending data fails
        }
        return 0; // Success
    }
}

// --- Minimal main function ---
// This main function is provided to make the code a complete, compilable unit.
// It does not implement any specific logic from the original context,
// but sets up a basic environment.
int main() {
    // Seed the random number generator if `random()` is expected to be truly random.
    // For deterministic behavior as implied by `getrand` in the snippet, this might be omitted.
    // srandom(time(NULL)); 
    
    // Example usage would go here, requiring mock implementations of external functions
    // and initialization of `curpkt`.
    // e.g.:
    // char dummy_packet_buffer[1024] = {0};
    // curpkt = dummy_packet_buffer;
    // // Set up dummy packet data for testing process_next_dgram
    // ((uint32_t*)curpkt)[1] = 0; // Set packet type to 0 (for do_put)
    // strcpy(curpkt + 8, "test_key");
    // strcpy(curpkt + 8 + strlen("test_key") + 1, "test_value");
    // process_next_dgram();

    return 0;
}