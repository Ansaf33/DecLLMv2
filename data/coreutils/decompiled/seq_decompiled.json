{
    "file": "seq",
    "decompiled_code": {
        "seq.c": [
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\n                            \"Usage: %s [OPTION]... LAST\\n  or:  %s [OPTION]... FIRST LAST\\n  or:  %s [OPTION]... FIRST INCREMENT LAST\\n\"\n                            );\n    printf(pcVar3,uVar2,uVar2,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"Print numbers from FIRST to LAST, in steps of INCREMENT.\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_mandatory_arg_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -f, --format=FORMAT      use printf style floating-point FORMAT\\n  -s, --separator=STRING   use STRING to separate numbers (default: \\\\n)\\n  -w, --equal-width        equalize width by padding with leading zeroes\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nIf FIRST or INCREMENT is omitted, it defaults to 1.  That is, an\\nomitted INCREMENT defaults to 1 even when LAST is smaller than FIRST.\\nThe sequence of numbers ends when the sum of the current number and\\nINCREMENT would become greater than LAST.\\nFIRST, INCREMENT, and LAST are interpreted as floating point values.\\nINCREMENT is usually positive if FIRST is smaller than LAST, and\\nINCREMENT is usually negative if FIRST is greater than LAST.\\nINCREMENT must not be 0; none of FIRST, INCREMENT and LAST may be NaN.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"FORMAT must be suitable for printing one argument of type \\'double\\';\\nit defaults to %.PRECf if FIRST, INCREMENT, and LAST are all fixed point\\ndecimal numbers with maximum precision PREC, and to %g otherwise.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_ancillary_info(&DAT_00102a58);\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "numbers"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "fputs_unlocked",
                        "emit_mandatory_arg_note",
                        "numbers",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "scan_arg",
                        "main"
                    ],
                    "defined_in_file": "seq_decompiled.c"
                }
            },
            {
                "func_name": "scan_arg",
                "func_c_signature": "undefined8 * scan_arg(undefined8 *param_1,char *param_2)",
                "decompiled_code": "undefined8 * scan_arg(undefined8 *param_1,char *param_2) {\n  ushort *puVar1;\n  char cVar2;\n  byte bVar3;\n  int iVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  ushort **ppuVar8;\n  char *pcVar9;\n  char *pcVar10;\n  size_t sVar11;\n  long lVar12;\n  ulong uVar13;\n  ulong uVar14;\n  long in_FS_OFFSET;\n  char *local_98;\n  ulong local_78;\n  char *local_70;\n  long local_68;\n  undefined8 local_48;\n  undefined2 uStack_40;\n  undefined6 uStack_3e;\n  char *local_38;\n  int local_30;\n  undefined4 uStack_2c;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  cVar2 = xstrtold(param_2,0,&local_48,&cl_strtold);\n  if (cVar2 != '\\x01') {\n    uVar5 = quote(param_2);\n    uVar6 = gettext(\"invalid floating point argument: %s\");\n    error(0,0,uVar6,uVar5);\n    usage(1);\n  }\n  local_98 = param_2;\n  if (NAN((longdouble)CONCAT28(uStack_40,local_48)) || NAN((longdouble)CONCAT28(uStack_40,local_48))\n     ) {\n    uVar5 = quote_n(1,param_2);\n    uVar6 = quote_n(0,\"not-a-number\");\n    uVar7 = gettext(\"invalid %s argument: %s\");\n    error(0,0,uVar7,uVar6,uVar5);\n    usage(1);\n    goto LAB_001005cd;\n  }\n  while( true ) {\n    ppuVar8 = __ctype_b_loc();\n    puVar1 = *ppuVar8;\n    bVar3 = to_uchar((int)*local_98);\n    if (((puVar1[bVar3] & 0x2000) == 0) && (*local_98 != '+')) break;\nLAB_001005cd:\n    local_98 = local_98 + 1;\n  }\n  local_38 = (char *)0x0;\n  local_30 = 0x7fffffff;\n  pcVar9 = strchr(local_98,0x2e);\n  if ((pcVar9 == (char *)0x0) && (pcVar10 = strchr(local_98,0x70), pcVar10 == (char *)0x0)) {\n    local_30 = 0;\n  }\n  sVar11 = strcspn(local_98,\"xX\");\n  if ((local_98[sVar11] == '\\0') &&\n     ((longdouble)0 == (longdouble)0 * (longdouble)CONCAT28(uStack_40,local_48))) {\n    local_78 = 0;\n    local_38 = (char *)strlen(local_98);\n    if (pcVar9 != (char *)0x0) {\n      local_78 = strcspn(pcVar9 + 1,\"eE\");\n      if (local_78 < 0x80000000) {\n        local_30 = (int)local_78;\n      }\n      if (local_78 == 0) {\n        iVar4 = -1;\n      }\n      else if ((pcVar9 == local_98) || (cVar2 = c_isdigit((int)pcVar9[-1]), cVar2 != '\\x01')) {\n        iVar4 = 1;\n      }\n      else {\n        iVar4 = 0;\n      }\n      local_38 = local_38 + iVar4;\n    }\n    local_70 = strchr(local_98,0x65);\n    if (local_70 == (char *)0x0) {\n      local_70 = strchr(local_98,0x45);\n    }\n    if (local_70 != (char *)0x0) {\n      lVar12 = __isoc23_strtol(local_70 + 1,0,10);\n      if (lVar12 < -0x7ffffffffffffffe) {\n        uVar13 = 0x8000000000000001;\n      }\n      else {\n        uVar13 = __isoc23_strtol(local_70 + 1,0,10);\n      }\n      pcVar10 = local_38;\n      if ((long)uVar13 < 0) {\n        iVar4 = (int)uVar13;\n      }\n      else {\n        uVar14 = uVar13;\n        if ((long)local_30 <= (long)uVar13) {\n          uVar14 = (long)local_30;\n        }\n        iVar4 = (int)uVar14;\n      }\n      local_30 = local_30 - iVar4;\n      sVar11 = strlen(local_98);\n      local_38 = local_70 + (long)(pcVar10 + (-sVar11 - (long)local_98));\n      if ((long)uVar13 < 0) {\n        if (pcVar9 == (char *)0x0) {\n          local_38 = local_38 + 1;\n        }\n        else if (local_70 == pcVar9 + 1) {\n          local_38 = local_38 + 1;\n        }\n        local_68 = -uVar13;\n      }\n      else {\n        if (((pcVar9 != (char *)0x0) && (local_30 == 0)) && (local_78 != 0)) {\n          local_38 = local_38 + -1;\n        }\n        if (uVar13 <= local_78) {\n          local_78 = uVar13;\n        }\n        local_68 = uVar13 - local_78;\n      }\n      local_38 = local_38 + local_68;\n    }\n  }\n  *param_1 = local_48;\n  param_1[1] = CONCAT62(uStack_3e,uStack_40);\n  param_1[2] = local_38;\n  param_1[3] = CONCAT44(uStack_2c,local_30);\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return param_1;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [
                    "NAN",
                    "CONCAT28",
                    "CONCAT62",
                    "CONCAT44"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "scan_arg",
                        "xstrtold",
                        "quote",
                        "gettext",
                        "error",
                        "usage",
                        "NAN",
                        "CONCAT28",
                        "quote_n",
                        "__ctype_b_loc",
                        "to_uchar",
                        "strchr",
                        "strcspn",
                        "strlen",
                        "c_isdigit",
                        "__isoc23_strtol",
                        "CONCAT62",
                        "CONCAT44",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "scan_arg",
                        "main"
                    ],
                    "defined_in_file": "seq_decompiled.c"
                }
            },
            {
                "func_name": "long_double_format",
                "func_c_signature": "void * long_double_format(void *param_1,long *param_2)",
                "decompiled_code": "void * long_double_format(void *param_1,long *param_2) {\n  char cVar1;\n  size_t sVar2;\n  undefined8 uVar3;\n  undefined8 uVar4;\n  char *pcVar5;\n  void *__dest;\n  long lVar6;\n  bool bVar7;\n  size_t local_68;\n  long local_60;\n  long local_58;\n  \n  local_60 = 0;\n  local_58 = 0;\n  for (local_68 = 0;\n      (*(char *)(local_68 + (long)param_1) != '%' ||\n      (*(char *)((long)param_1 + local_68 + 1) == '%')); local_68 = local_68 + lVar6) {\n    if (*(char *)(local_68 + (long)param_1) == '\\0') {\n      uVar3 = quote(param_1);\n      uVar4 = gettext(\"format %s has no %% directive\");\n      error(1,0,uVar4,uVar3);\n    }\n    local_60 = local_60 + 1;\n    if (*(char *)(local_68 + (long)param_1) == '%') {\n      lVar6 = 2;\n    }\n    else {\n      lVar6 = 1;\n    }\n  }\n  sVar2 = strspn((char *)(local_68 + 1 + (long)param_1),\"-+#0 \\'\");\n  lVar6 = local_68 + 1 + sVar2;\n  local_68 = strspn((char *)(lVar6 + (long)param_1),\"0123456789\");\n  local_68 = lVar6 + local_68;\n  if (*(char *)(local_68 + (long)param_1) == '.') {\n    sVar2 = strspn((char *)(local_68 + 1 + (long)param_1),\"0123456789\");\n    local_68 = local_68 + 1 + sVar2;\n  }\n  sVar2 = local_68;\n  bVar7 = *(char *)(local_68 + (long)param_1) == 'L';\n  lVar6 = local_68 + bVar7;\n  if (*(char *)(lVar6 + (long)param_1) == '\\0') {\n    uVar3 = quote(param_1);\n    uVar4 = gettext(\"format %s ends in %%\");\n    error(1,0,uVar4,uVar3);\n  }\n  pcVar5 = strchr(\"efgaEFGA\",(int)*(char *)(lVar6 + (long)param_1));\n  if (pcVar5 == (char *)0x0) {\n    cVar1 = *(char *)(lVar6 + (long)param_1);\n    uVar3 = quote(param_1);\n    uVar4 = gettext(\"format %s has unknown %%%c directive\");\n    error(1,0,uVar4,uVar3,(int)cVar1);\n  }\n  local_68 = lVar6 + 1;\n  while( true ) {\n    if ((*(char *)(local_68 + (long)param_1) == '%') &&\n       (*(char *)((long)param_1 + local_68 + 1) != '%')) {\n      uVar3 = quote(param_1);\n      uVar4 = gettext(\"format %s has too many %% directives\");\n      error(1,0,uVar4,uVar3);\n    }\n    if (*(char *)(local_68 + (long)param_1) == '\\0') break;\n    local_58 = local_58 + 1;\n    if (*(char *)(local_68 + (long)param_1) == '%') {\n      lVar6 = 2;\n    }\n    else {\n      lVar6 = 1;\n    }\n    local_68 = local_68 + lVar6;\n  }\n  __dest = (void *)xmalloc(local_68 + 2);\n  memcpy(__dest,param_1,sVar2);\n  *(undefined *)(sVar2 + (long)__dest) = 0x4c;\n  strcpy((char *)((long)__dest + sVar2 + 1),(char *)(bVar7 + sVar2 + (long)param_1));\n  *param_2 = local_60;\n  param_2[1] = local_58;\n  return __dest;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "long_double_format",
                        "quote",
                        "gettext",
                        "error",
                        "strspn",
                        "strchr",
                        "xmalloc",
                        "memcpy",
                        "strcpy"
                    ],
                    "calling_functions": [
                        "long_double_format",
                        "main"
                    ],
                    "defined_in_file": "seq_decompiled.c"
                }
            },
            {
                "func_name": "print_numbers",
                "func_c_signature": "void print_numbers(char *param_1,long param_2,long param_3)",
                "decompiled_code": "void print_numbers(char *param_1,long param_2,long param_3) {\n  bool bVar1;\n  char cVar2;\n  int iVar3;\n  long in_FS_OFFSET;\n  bool bVar4;\n  longdouble lVar5;\n  longdouble param_7;\n  longdouble param_8;\n  longdouble param_9;\n  char *local_68;\n  char *local_60;\n  longdouble local_58;\n  undefined8 local_48;\n  undefined2 uStack_40;\n  longdouble local_38;\n  undefined8 local_28;\n  undefined2 uStack_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  if ((longdouble)0 <= param_8) {\n    bVar1 = param_9 < param_7;\n  }\n  else {\n    bVar1 = param_7 < param_9;\n  }\n  if (!bVar1) {\n    local_48 = SUB108(param_7,0);\n    uStack_40 = (undefined2)((unkuint10)param_7 >> 0x40);\n    local_38 = (longdouble)1;\n    while( true ) {\n      local_28 = local_48;\n      uStack_20 = uStack_40;\n      iVar3 = printf(param_1);\n      if (iVar3 < 0) {\n        write_error();\n      }\n      if (bVar1) break;\n      lVar5 = param_7 + param_8 * local_38;\n      local_48 = SUB108(lVar5,0);\n      uStack_40 = (undefined2)((unkuint10)lVar5 >> 0x40);\n      if ((longdouble)0 <= param_8) {\n        bVar1 = param_9 < lVar5;\n      }\n      else {\n        bVar1 = lVar5 < param_9;\n      }\n      if (bVar1) {\n        bVar4 = false;\n        if (locale_ok != '\\0') {\n          setlocale(1,\"C\");\n        }\n        iVar3 = asprintf(&local_68,param_1);\n        if (locale_ok != '\\0') {\n          setlocale(1,\"\");\n        }\n        if (iVar3 < 0) {\n          xalloc_die();\n        }\n        local_68[iVar3 - param_3] = '\\0';\n        cVar2 = xstrtold(local_68 + param_2,0,&local_58,&cl_strtold);\n        if ((cVar2 != '\\0') && (param_9 == local_58)) {\n          local_60 = (char *)0x0;\n          iVar3 = asprintf(&local_60,param_1);\n          if (iVar3 < 0) {\n            xalloc_die();\n          }\n          local_60[iVar3 - param_3] = '\\0';\n          cVar2 = streq(local_60,local_68);\n          bVar4 = cVar2 == '\\0';\n          free(local_60);\n        }\n        free(local_68);\n        if (!bVar4) break;\n      }\n      iVar3 = fputs_unlocked(separator,_stdout);\n      if (iVar3 == -1) {\n        write_error();\n      }\n      local_38 = (longdouble)1 + local_38;\n    }\n    iVar3 = fputs_unlocked((char *)&terminator,_stdout);\n    if (iVar3 == -1) {\n      write_error();\n    }\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}",
                "globals": [],
                "externs": [
                    "SUB108"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "print_numbers",
                        "SUB108",
                        "printf",
                        "write_error",
                        "setlocale",
                        "asprintf",
                        "xalloc_die",
                        "xstrtold",
                        "streq",
                        "free",
                        "fputs_unlocked",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "print_numbers",
                        "main"
                    ],
                    "defined_in_file": "seq_decompiled.c"
                }
            },
            {
                "func_name": "get_default_format",
                "func_c_signature": "undefined * get_default_format(void)",
                "decompiled_code": "undefined * get_default_format(void) {\n  uint uVar1;\n  long param_9;\n  uint param_10;\n  uint param_11;\n  long param_12;\n  int param_13;\n  ulong local_20;\n  ulong local_18;\n  \n  uVar1 = param_10;\n  if ((int)param_10 <= (int)param_11) {\n    uVar1 = param_11;\n  }\n  if ((uVar1 != 0x7fffffff) && (param_13 != 0x7fffffff)) {\n    if (equal_width == '\\0') {\n      sprintf(format_buf_0,\"%%.%dLf\",(ulong)uVar1);\n      return format_buf_0;\n    }\n    local_20 = (int)(uVar1 - param_10) + param_9;\n    local_18 = (int)(uVar1 - param_13) + param_12;\n    if ((param_13 != 0) && (uVar1 == 0)) {\n      local_18 = local_18 - 1;\n    }\n    if ((param_13 == 0) && (uVar1 != 0)) {\n      local_18 = local_18 + 1;\n    }\n    if ((param_10 == 0) && (uVar1 != 0)) {\n      local_20 = local_20 + 1;\n    }\n    if (local_20 <= local_18) {\n      local_20 = local_18;\n    }\n    if (local_20 < 0x80000000) {\n      sprintf(format_buf_0,\"%%0%d.%dLf\",local_20 & 0xffffffff,(ulong)uVar1);\n      return format_buf_0;\n    }\n  }\n  return &DAT_00102b62;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "get_default_format",
                        "sprintf"
                    ],
                    "calling_functions": [
                        "get_default_format",
                        "main"
                    ],
                    "defined_in_file": "seq_decompiled.c"
                }
            },
            {
                "func_name": "incr_grows",
                "func_c_signature": "undefined8 incr_grows(char *param_1,char *param_2)",
                "decompiled_code": "undefined8 incr_grows(char *param_1,char *param_2) {\n  char *local_18;\n  \n  local_18 = param_2;\n  do {\n    local_18 = local_18 + -1;\n    if (*local_18 < '9') {\n      *local_18 = *local_18 + '\\x01';\n      return 0;\n    }\n    *local_18 = '0';\n  } while (param_1 < local_18);\n  param_1[-1] = '1';\n  return 1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "incr_grows"
                    ],
                    "calling_functions": [
                        "incr_grows",
                        "seq_fast"
                    ],
                    "defined_in_file": "seq_decompiled.c"
                }
            },
            {
                "func_name": "cmp",
                "func_c_signature": "int cmp(void *param_1,void *param_2)",
                "decompiled_code": "int cmp(void *param_1,void *param_2) {\n  int iVar1;\n  void *in_RCX;\n  void *in_RDX;\n  \n  if (param_2 == in_RCX) {\n    iVar1 = memcmp(param_1,in_RDX,(size_t)param_2);\n  }\n  else {\n    iVar1 = (uint)((long)in_RCX < (long)param_2) - (uint)((long)param_2 < (long)in_RCX);\n  }\n  return iVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "cmp",
                        "memcmp"
                    ],
                    "calling_functions": [
                        "cmp",
                        "seq_fast"
                    ],
                    "defined_in_file": "seq_decompiled.c"
                }
            },
            {
                "func_name": "trim_leading_zeros",
                "func_c_signature": "char * trim_leading_zeros(char *param_1)",
                "decompiled_code": "char * trim_leading_zeros(char *param_1) {\n  char *local_20;\n  \n  for (local_20 = param_1; *local_20 == '0'; local_20 = local_20 + 1) {\n  }\n  if ((*local_20 == '\\0') && (local_20 != param_1)) {\n    local_20 = local_20 + -1;\n  }\n  return local_20;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "trim_leading_zeros"
                    ],
                    "calling_functions": [
                        "trim_leading_zeros",
                        "seq_fast"
                    ],
                    "defined_in_file": "seq_decompiled.c"
                }
            },
            {
                "func_name": "seq_fast",
                "func_c_signature": "void seq_fast(undefined8 param_1,undefined8 param_2,long param_3)",
                "decompiled_code": "void seq_fast(undefined8 param_1,undefined8 param_2,long param_3) {\n  bool bVar1;\n  char cVar2;\n  bool bVar3;\n  byte bVar4;\n  int iVar5;\n  char *__s;\n  char *__s_00;\n  undefined *puVar6;\n  long lVar7;\n  long in_FS_OFFSET;\n  size_t local_2080;\n  void *local_2078;\n  long local_2070;\n  void *local_2068;\n  undefined *local_2060;\n  void *local_2058;\n  long local_2050;\n  size_t local_2048;\n  size_t local_2040;\n  undefined *local_2038;\n  long local_2030;\n  void *local_2028;\n  size_t local_2020;\n  undefined local_2018 [8192];\n  undefined auStack_18 [8];\n  undefined8 local_10;\n  \n  local_10 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  __s = (char *)trim_leading_zeros(param_1);\n  __s_00 = (char *)trim_leading_zeros(param_2);\n  local_2048 = strlen(__s);\n  local_2040 = strlen(__s_00);\n  if ((local_2040 == 3) && (cVar2 = memeq(__s_00,&DAT_00102b66,4), cVar2 != '\\0')) {\n    bVar3 = true;\n  }\n  else {\n    bVar3 = false;\n  }\n  if ((long)local_2048 < (long)local_2040) {\n    bVar1 = 0x1f < (long)local_2040;\n  }\n  else {\n    bVar1 = 0x1e < (long)local_2048;\n  }\n  if (bVar1) {\n    local_2080 = local_2040;\n    if ((long)local_2040 <= (long)local_2048) {\n      local_2080 = local_2048 + 1;\n    }\n  }\n  else {\n    local_2080 = 0x1f;\n  }\n  local_2078 = (void *)xmalloc(local_2080);\n  local_2070 = (long)local_2078 + local_2080;\n  local_2068 = memcpy((void *)(local_2070 - local_2048),__s,local_2048);\n  local_2038 = auStack_18;\n  local_2060 = local_2018;\n  while ((bVar3 || (iVar5 = cmp(local_2068,(void *)(local_2070 - (long)local_2068)), iVar5 < 1))) {\n    local_2058 = local_2068;\n    while ((long)local_2038 - (long)local_2060 <= local_2070 - (long)local_2058) {\n      memcpy(local_2060,local_2058,(long)local_2038 - (long)local_2060);\n      local_2058 = (void *)((long)local_2058 + ((long)local_2038 - (long)local_2060));\n      lVar7 = full_write(1,local_2018,0x2000);\n      if (lVar7 != 0x2000) {\n        write_error();\n      }\n      local_2060 = local_2018;\n    }\n    puVar6 = (undefined *)mempcpy(local_2060,local_2058,local_2070 - (long)local_2058);\n    local_2060 = puVar6 + 1;\n    *puVar6 = *separator;\n    lVar7 = param_3;\n    if (local_2068 == local_2078) {\n      local_2028 = (void *)xpalloc(0,&local_2080,1,0xffffffffffffffff,1);\n      local_2020 = local_2070 - (long)local_2068;\n      local_2070 = (long)local_2028 + local_2080;\n      local_2068 = memcpy((void *)(local_2070 - local_2020),local_2078,local_2020);\n      free(local_2078);\n      local_2078 = local_2028;\n      lVar7 = param_3;\n    }\n    while (local_2050 = lVar7, local_2050 != 0) {\n      bVar4 = incr_grows(local_2068,local_2070);\n      local_2068 = (void *)((long)local_2068 - (ulong)bVar4);\n      lVar7 = local_2050 + -1;\n    }\n  }\n  local_2030 = (long)local_2060 - (long)local_2018;\n  if (local_2030 != 0) {\n    local_2060[-1] = 10;\n    lVar7 = full_write(1,local_2018,local_2030);\n    if (local_2030 != lVar7) {\n      write_error();\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(0);\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "seq_fast",
                        "trim_leading_zeros",
                        "strlen",
                        "memeq",
                        "xmalloc",
                        "memcpy",
                        "cmp",
                        "full_write",
                        "write_error",
                        "mempcpy",
                        "xpalloc",
                        "free",
                        "incr_grows",
                        "exit"
                    ],
                    "calling_functions": [
                        "seq_fast",
                        "main"
                    ],
                    "defined_in_file": "seq_decompiled.c"
                }
            },
            {
                "func_name": "all_digits_p",
                "func_c_signature": "undefined4 all_digits_p(char *param_1)",
                "decompiled_code": "undefined4 all_digits_p(char *param_1) {\n  char cVar1;\n  size_t sVar2;\n  size_t sVar3;\n  \n  sVar2 = strlen(param_1);\n  cVar1 = c_isdigit((int)*param_1);\n  if ((cVar1 != '\\0') && (sVar3 = strspn(param_1,\"0123456789\"), sVar2 == sVar3)) {\n    return 1;\n  }\n  return 0;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "all_digits_p",
                        "strlen",
                        "c_isdigit",
                        "strspn"
                    ],
                    "calling_functions": [
                        "all_digits_p",
                        "main"
                    ],
                    "defined_in_file": "seq_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "void main(int param_1,undefined8 *param_2)",
                "decompiled_code": "void main(int param_1,undefined8 *param_2) {\n  longdouble lVar1;\n  char cVar2;\n  int iVar3;\n  char *pcVar4;\n  undefined8 uVar5;\n  size_t sVar6;\n  long lVar7;\n  ulong uVar8;\n  long in_FS_OFFSET;\n  ushort in_FPUControlWord;\n  undefined8 local_148;\n  undefined8 local_140;\n  undefined8 local_138;\n  ulong local_130;\n  undefined8 *local_128;\n  ushort local_120;\n  int local_11c;\n  char local_111;\n  int local_110;\n  int local_10c;\n  undefined4 local_108;\n  undefined4 local_104;\n  undefined4 local_100;\n  undefined4 local_fc;\n  undefined4 local_f8;\n  undefined4 local_f4;\n  undefined4 local_f0;\n  undefined4 local_ec;\n  char *local_e8;\n  char *local_e0;\n  char *local_d8;\n  undefined *local_d0;\n  undefined *local_c8;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  undefined8 local_a8;\n  undefined8 local_a0;\n  undefined8 local_98;\n  undefined8 local_90;\n  undefined8 local_88;\n  undefined2 uStack_80;\n  undefined8 local_78;\n  ulong local_70;\n  undefined8 local_68;\n  undefined2 uStack_60;\n  undefined6 uStack_5e;\n  undefined8 local_58;\n  ulong local_50;\n  undefined8 local_48;\n  undefined2 uStack_40;\n  undefined6 uStack_3e;\n  undefined8 local_38;\n  ulong local_30;\n  undefined8 local_20;\n  \n  local_20 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  local_88 = SUB108((longdouble)1,0);\n  uStack_80 = (undefined2)((unkuint10)(longdouble)1 >> 0x40);\n  local_78 = 1;\n  local_70 = local_70 & 0xffffffff00000000;\n  local_68 = SUB108((longdouble)1,0);\n  uStack_60 = (undefined2)((unkuint10)(longdouble)1 >> 0x40);\n  local_58 = 1;\n  local_50 = local_50 & 0xffffffff00000000;\n  local_98 = 0;\n  local_90 = 0;\n  local_d8 = (char *)0x0;\n  local_128 = param_2;\n  local_11c = param_1;\n  set_program_name(*param_2);\n  pcVar4 = setlocale(6,\"\");\n  locale_ok = pcVar4 != (char *)0x0;\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit((__func *)&close_stdout);\n  equal_width = '\\0';\n  separator = \"\\n\";\nLAB_001019e0:\n  while( true ) {\n    if (((local_11c <= _optind) ||\n        ((*(char *)local_128[_optind] == '-' &&\n         ((local_110 = (int)*(char *)(local_128[_optind] + 1), local_110 == 0x2e ||\n          (cVar2 = c_isdigit(local_110), cVar2 != '\\0')))))) ||\n       (local_110 = getopt_long(local_11c,local_128,\"+f:s:w\",long_options,0), local_110 == -1)) {\n      local_10c = local_11c - _optind;\n      if (local_10c < 1) {\n        local_b8 = gettext(\"missing operand\");\n        local_108 = 0;\n        local_104 = 0;\n        error(0,0,local_b8);\n        usage(1);\n      }\n      if (3 < local_10c) {\n        uVar5 = quote(local_128[(long)_optind + 3]);\n        local_b0 = gettext(\"extra operand %s\");\n        local_100 = 0;\n        local_fc = 0;\n        error(0,0,local_b0,uVar5);\n        usage(1);\n      }\n      if (local_d8 != (char *)0x0) {\n        local_d8 = (char *)long_double_format(local_d8,&local_98);\n      }\n      if ((local_d8 != (char *)0x0) && (equal_width != '\\0')) {\n        local_a8 = gettext(\"format string may not be specified when printing equal width strings\");\n        local_f8 = 0;\n        local_f4 = 0;\n        error(0,0,local_a8);\n        usage(1);\n      }\n      if (local_10c == 1) {\n        local_d0 = &DAT_00102c15;\n      }\n      else {\n        local_d0 = (undefined *)local_128[_optind];\n      }\n      local_111 = '\\0';\n      if ((local_10c != 3) ||\n         ((((cVar2 = all_digits_p(local_128[(long)_optind + 1]), cVar2 != '\\0' &&\n            (cVar2 = xstrtold(local_128[(long)_optind + 1],0,&local_68,&cl_strtold), cVar2 != '\\0'))\n           && ((longdouble)0 < (longdouble)CONCAT28(uStack_60,local_68))) &&\n          ((longdouble)CONCAT28(uStack_60,local_68) <= _DAT_00102c40)))) {\n        local_111 = '\\x01';\n      }\n      cVar2 = all_digits_p(local_128[_optind]);\n      if ((((cVar2 != '\\0') &&\n           ((local_10c == 1 || (cVar2 = all_digits_p(local_128[(long)_optind + 1]), cVar2 != '\\0')))\n           ) && ((local_10c < 3 ||\n                 ((local_111 != '\\0' &&\n                  (cVar2 = all_digits_p(local_128[(long)_optind + 2]), cVar2 != '\\0')))))) &&\n         ((equal_width != '\\x01' &&\n          ((local_d8 == (char *)0x0 && (sVar6 = strlen(separator), sVar6 == 1)))))) {\n        local_c8 = local_d0;\n        local_c0 = local_128[_optind + local_10c + -1];\n        lVar1 = (longdouble)CONCAT28(uStack_60,local_68);\n        if (_DAT_00102c50 <= lVar1) {\n          uVar8 = (long)ROUND(lVar1 - _DAT_00102c50) ^ 0x8000000000000000;\n        }\n        else {\n          uVar8 = (ulong)ROUND(lVar1);\n        }\n        local_120 = in_FPUControlWord | 0xc00;\n        seq_fast(local_d0,local_c0,uVar8);\n      }\n      lVar7 = (long)_optind;\n      _optind = _optind + 1;\n      scan_arg(&local_48,local_128[lVar7]);\n      if (_optind < local_11c) {\n        local_88 = local_48;\n        uStack_80 = uStack_40;\n        local_78 = local_38;\n        local_70 = local_30;\n        lVar7 = (long)_optind;\n        _optind = _optind + 1;\n        scan_arg(&local_148,local_128[lVar7]);\n        local_48 = local_148;\n        uStack_40 = (undefined2)local_140;\n        uStack_3e = (undefined6)((ulong)local_140 >> 0x10);\n        local_38 = local_138;\n        local_30 = local_130;\n        if (_optind < local_11c) {\n          local_68 = local_148;\n          local_58 = local_138;\n          local_50 = local_130;\n          uStack_60 = uStack_40;\n          uStack_5e = uStack_3e;\n          if ((longdouble)0 == (longdouble)CONCAT28(uStack_40,local_148)) {\n            uVar5 = quote(local_128[(long)_optind + -1]);\n            local_a0 = gettext(\"invalid Zero increment value: %s\");\n            local_f0 = 0;\n            local_ec = 0;\n            error(0,0,local_a0,uVar5);\n            usage(1);\n          }\n          lVar7 = (long)_optind;\n          _optind = _optind + 1;\n          scan_arg(&local_148,local_128[lVar7]);\n          local_48 = local_148;\n          uStack_40 = (undefined2)local_140;\n          uStack_3e = (undefined6)((ulong)local_140 >> 0x10);\n          local_38 = local_138;\n          local_30 = local_130;\n        }\n      }\n      if (((((((int)local_70 == 0) && ((int)local_50 == 0)) && ((int)local_30 == 0)) &&\n           ((((longdouble)0 == (longdouble)0 * (longdouble)CONCAT28(uStack_80,local_88) &&\n             ((longdouble)0 <= (longdouble)CONCAT28(uStack_80,local_88))) &&\n            (((longdouble)0 <= (longdouble)CONCAT28(uStack_40,local_48) &&\n             (((longdouble)0 < (longdouble)CONCAT28(uStack_60,local_68) &&\n              ((longdouble)CONCAT28(uStack_60,local_68) <= _DAT_00102c40)))))))) &&\n          (equal_width != '\\x01')) &&\n         ((local_d8 == (char *)0x0 && (sVar6 = strlen(separator), sVar6 == 1)))) {\n        cVar2 = all_digits_p(local_d0);\n        if (cVar2 == '\\0') {\n          iVar3 = asprintf(&local_e8,\"%0.Lf\");\n          if (iVar3 < 0) {\n            xalloc_die();\n          }\n        }\n        else {\n          local_e8 = (char *)xstrdup(local_d0);\n        }\n        if ((longdouble)0 == (longdouble)0 * (longdouble)CONCAT28(uStack_40,local_48)) {\n          iVar3 = asprintf(&local_e0,\"%0.Lf\");\n          if (iVar3 < 0) {\n            xalloc_die();\n          }\n        }\n        else {\n          local_e0 = (char *)xstrdup(&DAT_00102b66);\n        }\n        if ((*local_e8 != '-') && (*local_e0 != '-')) {\n          lVar1 = (longdouble)CONCAT28(uStack_60,local_68);\n          if (_DAT_00102c50 <= lVar1) {\n            uVar8 = (long)ROUND(lVar1 - _DAT_00102c50) ^ 0x8000000000000000;\n          }\n          else {\n            uVar8 = (ulong)ROUND(lVar1);\n          }\n          local_120 = in_FPUControlWord | 0xc00;\n          seq_fast(local_e8,local_e0,uVar8);\n        }\n        free(local_e8);\n        free(local_e0);\n      }\n      if (local_d8 == (char *)0x0) {\n        local_d8 = (char *)get_default_format();\n      }\n      print_numbers(local_d8,local_98,local_90);\n                    /* WARNING: Subroutine does not return */\n      exit(0);\n    }\n    if (local_110 != 0x77) break;\n    equal_width = '\\x01';\n  }\n  if (local_110 < 0x78) {\n    if (local_110 == 0x73) {\n      separator = _optarg;\n      goto LAB_001019e0;\n    }\n    if (local_110 < 0x74) {\n      if (local_110 != 0x66) {\n        if (local_110 < 0x67) {\n          if (local_110 == -0x83) {\nLAB_0010197b:\n            uVar5 = proper_name_lite(\"Ulrich Drepper\",\"Ulrich Drepper\");\n            version_etc(_stdout,&DAT_00102a58,\"GNU coreutils\",_Version,uVar5,0);\n                    /* WARNING: Subroutine does not return */\n            exit(0);\n          }\n          if (local_110 == -0x82) {\n            usage(0);\n            goto LAB_0010197b;\n          }\n        }\n        goto LAB_001019d6;\n      }\n      local_d8 = _optarg;\n      goto LAB_001019e0;\n    }\n  }\nLAB_001019d6:\n  usage(1);\n  goto LAB_001019e0;\n}",
                "globals": [],
                "externs": [
                    "SUB108",
                    "CONCAT28",
                    "ROUND"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "SUB108",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "c_isdigit",
                        "getopt_long",
                        "gettext",
                        "error",
                        "usage",
                        "quote",
                        "long_double_format",
                        "all_digits_p",
                        "xstrtold",
                        "CONCAT28",
                        "strlen",
                        "ROUND",
                        "seq_fast",
                        "scan_arg",
                        "asprintf",
                        "xalloc_die",
                        "xstrdup",
                        "free",
                        "get_default_format",
                        "print_numbers",
                        "exit",
                        "proper_name_lite",
                        "version_etc"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "seq_decompiled.c"
                }
            }
        ]
    }
}