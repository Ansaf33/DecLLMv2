{
    "file": "printf",
    "decompiled_code": {
        "printf.c": [
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\"Usage: %s FORMAT [ARGUMENT]...\\n  or:  %s OPTION\\n\");\n    printf(pcVar3,uVar2,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"Print ARGUMENT(s) according to FORMAT, or execute according to OPTION:\\n\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nFORMAT controls the output as in C printf.  Interpreted sequences are:\\n\\n  \\\\\\\"      double quote\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  \\\\\\\\      backslash\\n  \\\\a      alert (BEL)\\n  \\\\b      backspace\\n  \\\\c      produce no further output\\n  \\\\e      escape\\n  \\\\f      form feed\\n  \\\\n      new line\\n  \\\\r      carriage return\\n  \\\\t      horizontal tab\\n  \\\\v      vertical tab\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  \\\\NNN    byte with octal value NNN (1 to 3 digits)\\n  \\\\xHH    byte with hexadecimal value HH (1 to 2 digits)\\n  \\\\uHHHH  Unicode (ISO/IEC 10646) character with hex value HHHH (4 digits)\\n  \\\\UHHHHHHHH  Unicode character with hex value HHHHHHHH (8 digits)\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  %%      a single %\\n  %b      ARGUMENT as a string with \\'\\\\\\' escapes interpreted,\\n          except that octal escapes should have a leading 0 like \\\\0NNN\\n  %q      ARGUMENT is printed in a format that can be reused as shell input,\\n          escaping non-printable characters with the POSIX $\\'\\' syntax\\n\\nand all C format specifications ending with one of diouxXfeEgGcs, with\\nARGUMENTs converted to proper type first.  Variable widths are handled.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pcVar3 = (char *)gettext(\n                            \"\\nYour shell may have its own version of %s, which usually supersedes\\nthe version described here.  Please refer to your shell\\'s documentation\\nfor details about the options it supports.\\n\"\n                            );\n    printf(pcVar3,\"printf\");\n    emit_ancillary_info(\"printf\");\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "ARGUMENT",
                    "alert",
                    "NNN",
                    "HH",
                    "Unicode",
                    "HHHH",
                    "HHHHHHHH"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "ARGUMENT",
                        "fputs_unlocked",
                        "alert",
                        "NNN",
                        "HH",
                        "Unicode",
                        "HHHH",
                        "HHHHHHHH",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "printf_decompiled.c"
                }
            },
            {
                "func_name": "verify_numeric",
                "func_c_signature": "void verify_numeric(char *param_1,char *param_2)",
                "decompiled_code": "void verify_numeric(char *param_1,char *param_2) {\n  undefined8 uVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  \n  if (param_1 == param_2) {\n    uVar1 = quote(param_1);\n    uVar2 = gettext(\"%s: expected a numeric value\");\n    error(0,0,uVar2,uVar1);\n    exit_status = 1;\n  }\n  else {\n    piVar3 = __errno_location();\n    if (*piVar3 == 0) {\n      if (*param_2 != '\\0') {\n        uVar1 = quote(param_1);\n        uVar2 = gettext(\"%s: value not completely converted\");\n        error(0,0,uVar2,uVar1);\n        exit_status = 1;\n      }\n    }\n    else {\n      uVar1 = quote(param_1);\n      piVar3 = __errno_location();\n      error(0,*piVar3,&DAT_00102b2d,uVar1);\n      exit_status = 1;\n    }\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "verify_numeric",
                        "quote",
                        "gettext",
                        "error",
                        "__errno_location"
                    ],
                    "calling_functions": [
                        "verify_numeric",
                        "vstrtoimax",
                        "vstrtoumax",
                        "vstrtold"
                    ],
                    "defined_in_file": "printf_decompiled.c"
                }
            },
            {
                "func_name": "print_esc_char",
                "func_c_signature": "void print_esc_char(char param_1)",
                "decompiled_code": "void print_esc_char(char param_1) {\n  switch(param_1) {\n  case 'a':\n    putchar_unlocked(7);\n    break;\n  case 'b':\n    putchar_unlocked(8);\n    break;\n  case 'c':\n                    /* WARNING: Subroutine does not return */\n    exit(0);\n  default:\n    putchar_unlocked((int)param_1);\n    break;\n  case 'e':\n    putchar_unlocked(0x1b);\n    break;\n  case 'f':\n    putchar_unlocked(0xc);\n    break;\n  case 'n':\n    putchar_unlocked(10);\n    break;\n  case 'r':\n    putchar_unlocked(0xd);\n    break;\n  case 't':\n    putchar_unlocked(9);\n    break;\n  case 'v':\n    putchar_unlocked(0xb);\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "print_esc_char",
                        "putchar_unlocked",
                        "exit"
                    ],
                    "calling_functions": [
                        "print_esc_char",
                        "print_esc"
                    ],
                    "defined_in_file": "printf_decompiled.c"
                }
            },
            {
                "func_name": "print_esc",
                "func_c_signature": "int print_esc(long param_1,char param_2)",
                "decompiled_code": "int print_esc(long param_1,char param_2) {\n  char cVar1;\n  char cVar2;\n  int iVar3;\n  undefined8 uVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  int local_5c;\n  int local_58;\n  uint local_54;\n  char *local_38;\n  \n  local_38 = (char *)(param_1 + 1);\n  local_5c = 0;\n  if (*local_38 == 'x') {\n    local_38 = (char *)(param_1 + 2);\n    for (local_58 = 0; local_58 < 2; local_58 = local_58 + 1) {\n      cVar1 = c_isxdigit((int)*local_38);\n      if (cVar1 == '\\0') break;\n      if ((*local_38 < 'a') || ('f' < *local_38)) {\n        if ((*local_38 < 'A') || ('F' < *local_38)) {\n          iVar3 = *local_38 + -0x30;\n        }\n        else {\n          iVar3 = *local_38 + -0x37;\n        }\n      }\n      else {\n        iVar3 = *local_38 + -0x57;\n      }\n      local_5c = iVar3 + local_5c * 0x10;\n      local_38 = local_38 + 1;\n    }\n    if (local_58 == 0) {\n      uVar4 = gettext(\"missing hexadecimal number in escape\");\n      error(1,0,uVar4);\n    }\n    putchar_unlocked(local_5c);\n  }\n  else if ((*local_38 < '0') || ('7' < *local_38)) {\n    if (*local_38 != '\\0') {\n      pcVar5 = strchr(\"\\\"\\\\abcefnrtv\",(int)*local_38);\n      if (pcVar5 != (char *)0x0) {\n        print_esc_char((int)*local_38);\n        local_38 = (char *)(param_1 + 2);\n        goto LAB_00100e67;\n      }\n    }\n    if ((*local_38 == 'u') || (*local_38 == 'U')) {\n      cVar1 = *local_38;\n      local_54 = 0;\n      if (cVar1 == 'u') {\n        local_58 = 4;\n      }\n      else {\n        local_58 = 8;\n      }\n      local_38 = (char *)(param_1 + 2);\n      for (; 0 < local_58; local_58 = local_58 + -1) {\n        cVar2 = c_isxdigit((int)*local_38);\n        if (cVar2 != '\\x01') {\n          uVar4 = gettext(\"missing hexadecimal number in escape\");\n          error(1,0,uVar4);\n        }\n        if ((*local_38 < 'a') || ('f' < *local_38)) {\n          if ((*local_38 < 'A') || ('F' < *local_38)) {\n            iVar3 = *local_38 + -0x30;\n          }\n          else {\n            iVar3 = *local_38 + -0x37;\n          }\n        }\n        else {\n          iVar3 = *local_38 + -0x57;\n        }\n        local_54 = iVar3 + local_54 * 0x10;\n        local_38 = local_38 + 1;\n      }\n      if ((0xd7ff < local_54) && (local_54 < 0xe000)) {\n        if (cVar1 == 'u') {\n          uVar4 = 4;\n        }\n        else {\n          uVar4 = 8;\n        }\n        uVar6 = gettext(\"invalid universal character name \\\\%c%0*x\");\n        error(1,0,uVar6,(int)cVar1,uVar4,local_54);\n      }\n      print_unicode_char(_stdout,local_54,0);\n    }\n    else {\n      putchar_unlocked(0x5c);\n      if (*local_38 != '\\0') {\n        putchar_unlocked((int)*local_38);\n        local_38 = (char *)(param_1 + 2);\n      }\n    }\n  }\n  else {\n    local_58 = 0;\n    if ((param_2 == '\\0') || (*local_38 != '0')) {\n      iVar3 = 0;\n    }\n    else {\n      iVar3 = 1;\n    }\n    for (local_38 = local_38 + iVar3; ((local_58 < 3 && ('/' < *local_38)) && (*local_38 < '8'));\n        local_38 = local_38 + 1) {\n      local_5c = *local_38 + -0x30 + local_5c * 8;\n      local_58 = local_58 + 1;\n    }\n    putchar_unlocked(local_5c);\n  }\nLAB_00100e67:\n  return ((int)local_38 - (int)param_1) + -1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "print_esc",
                        "c_isxdigit",
                        "gettext",
                        "error",
                        "putchar_unlocked",
                        "strchr",
                        "print_esc_char",
                        "print_unicode_char"
                    ],
                    "calling_functions": [
                        "print_esc",
                        "print_esc_string",
                        "print_formatted"
                    ],
                    "defined_in_file": "printf_decompiled.c"
                }
            },
            {
                "func_name": "print_esc_string",
                "func_c_signature": "void print_esc_string(char *param_1)",
                "decompiled_code": "void print_esc_string(char *param_1) {\n  int iVar1;\n  char *local_10;\n  \n  for (local_10 = param_1; *local_10 != '\\0'; local_10 = local_10 + 1) {\n    if (*local_10 == '\\\\') {\n      iVar1 = print_esc(local_10,1);\n      local_10 = local_10 + iVar1;\n    }\n    else {\n      putchar_unlocked((int)*local_10);\n    }\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "print_esc_string",
                        "print_esc",
                        "putchar_unlocked"
                    ],
                    "calling_functions": [
                        "print_esc_string",
                        "print_formatted"
                    ],
                    "defined_in_file": "printf_decompiled.c"
                }
            },
            {
                "func_name": "print_direc",
                "func_c_signature": "void print_direc(char *param_1,char param_2,char param_3,undefined4 param_4,char param_5,\n                undefined4 param_6,char *param_7)",
                "decompiled_code": "void print_direc(char *param_1,char param_2,char param_3,undefined4 param_4,char param_5,\n                undefined4 param_6,char *param_7) {\n  char cVar1;\n  size_t __n;\n  void *__dest;\n  void *__dest_00;\n  char *pcVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  char *local_50;\n  size_t local_48;\n  \n  if ((int)param_2 - 0x41U < 0x38) {\n    uVar4 = 1L << ((byte)((int)param_2 - 0x41U) & 0x3f);\n    if ((uVar4 & 0x7100000071) != 0) {\n      local_50 = \"L\";\n      local_48 = 1;\n      goto LAB_00100f83;\n    }\n    if ((uVar4 & 0x90410800800000) != 0) {\n      local_50 = \"j\";\n      local_48 = 1;\n      goto LAB_00100f83;\n    }\n  }\n  local_48 = 0;\n  local_50 = param_1;\nLAB_00100f83:\n  __n = strlen(param_1);\n  __dest = (void *)xmalloc(local_48 + __n + 2);\n  __dest_00 = mempcpy(__dest,param_1,__n);\n  pcVar2 = (char *)mempcpy(__dest_00,local_50,local_48);\n  *pcVar2 = param_2;\n  pcVar2[1] = '\\0';\n  switch(param_2) {\n  case 'A':\n  case 'E':\n  case 'F':\n  case 'G':\n  case 'a':\n  case 'e':\n  case 'f':\n  case 'g':\n    if (param_7 != (char *)0x0) {\n      vstrtold(param_7);\n    }\n    if (param_3 == '\\x01') {\n      if (param_5 == '\\x01') {\n        xprintf(__dest,param_4,param_6);\n      }\n      else {\n        xprintf(__dest,param_4);\n      }\n    }\n    else if (param_5 == '\\x01') {\n      xprintf(__dest,param_6);\n    }\n    else {\n      xprintf(__dest);\n    }\n    break;\n  case 'X':\n  case 'o':\n  case 'u':\n  case 'x':\n    if (param_7 == (char *)0x0) {\n      uVar3 = 0;\n    }\n    else {\n      uVar3 = vstrtoumax(param_7);\n    }\n    if (param_3 == '\\x01') {\n      if (param_5 == '\\x01') {\n        xprintf(__dest,param_4,param_6,uVar3);\n      }\n      else {\n        xprintf(__dest,param_4,uVar3);\n      }\n    }\n    else if (param_5 == '\\x01') {\n      xprintf(__dest,param_6,uVar3);\n    }\n    else {\n      xprintf(__dest,uVar3);\n    }\n    break;\n  case 'c':\n    if (param_7 == (char *)0x0) {\n      cVar1 = '\\0';\n    }\n    else {\n      cVar1 = *param_7;\n    }\n    if (param_3 == '\\x01') {\n      xprintf(__dest,param_4,(int)cVar1);\n    }\n    else {\n      xprintf(__dest,(int)cVar1);\n    }\n    break;\n  case 'd':\n  case 'i':\n    if (param_7 == (char *)0x0) {\n      uVar3 = 0;\n    }\n    else {\n      uVar3 = vstrtoimax(param_7);\n    }\n    if (param_3 == '\\x01') {\n      if (param_5 == '\\x01') {\n        xprintf(__dest,param_4,param_6,uVar3);\n      }\n      else {\n        xprintf(__dest,param_4,uVar3);\n      }\n    }\n    else if (param_5 == '\\x01') {\n      xprintf(__dest,param_6,uVar3);\n    }\n    else {\n      xprintf(__dest,uVar3);\n    }\n    break;\n  case 's':\n    if (param_7 == (char *)0x0) {\n      param_7 = \"\";\n    }\n    if (param_3 == '\\x01') {\n      if (param_5 == '\\x01') {\n        xprintf(__dest,param_4,param_6,param_7);\n      }\n      else {\n        xprintf(__dest,param_4,param_7);\n      }\n    }\n    else if (param_5 == '\\x01') {\n      xprintf(__dest,param_6,param_7);\n    }\n    else {\n      xprintf(__dest,param_7);\n    }\n  }\n  free(__dest);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "print_direc",
                        "strlen",
                        "xmalloc",
                        "mempcpy",
                        "vstrtold",
                        "xprintf",
                        "vstrtoumax",
                        "vstrtoimax",
                        "free"
                    ],
                    "calling_functions": [
                        "print_direc",
                        "print_formatted"
                    ],
                    "defined_in_file": "printf_decompiled.c"
                }
            },
            {
                "func_name": "get_curr_arg",
                "func_c_signature": "char ** get_curr_arg(char **param_1,int param_2)",
                "decompiled_code": "char ** get_curr_arg(char **param_1,int param_2) {\n  long lVar1;\n  long lVar2;\n  char cVar3;\n  int iVar4;\n  long in_FS_OFFSET;\n  bool bVar5;\n  char *param_7;\n  int param_8;\n  int iStack0000000000000014;\n  int param_9;\n  int iStack000000000000001c;\n  int local_20;\n  int local_1c;\n  char *local_18;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_1c = 0;\n  local_18 = param_7;\n  if ((param_2 < 3) && (cVar3 = c_isdigit((int)*param_7), cVar3 != '\\0')) {\n    bVar5 = false;\n    local_18 = param_7 + 1;\n    local_20 = *param_7 + -0x30;\n    while (cVar3 = c_isdigit((int)*local_18), cVar3 != '\\0') {\n      lVar2 = (long)local_20;\n      iVar4 = (int)(lVar2 * 10);\n      local_20 = *local_18 + -0x30 + iVar4;\n      bVar5 = (byte)(SCARRY4(*local_18 + -0x30,iVar4) | (long)iVar4 != lVar2 * 10 | bVar5) != 0;\n      local_18 = local_18 + 1;\n    }\n    if ((*local_18 == '$') && (local_1c = local_20, bVar5)) {\n      local_1c = 0x7fffffff;\n    }\n  }\n  if (local_1c < 1) {\n    if (param_2 == 0) {\n      iStack000000000000001c = -1;\n      local_1c = -1;\n    }\n    else if ((param_2 < 3) || (local_1c = iStack000000000000001c, _param_9 < 0)) {\n      iStack0000000000000014 = iStack0000000000000014 + 1;\n      local_1c = iStack0000000000000014;\n    }\n  }\n  else {\n    local_1c = local_1c + -1;\n    param_7 = local_18 + 1;\n    if (param_2 == 0) {\n      iStack000000000000001c = local_1c;\n    }\n  }\n  iVar4 = param_9;\n  if ((-1 < local_1c) && (param_8 = local_1c, iVar4 = local_1c, local_1c <= param_9)) {\n    iVar4 = param_9;\n  }\n  param_9 = iVar4;\n  *param_1 = param_7;\n  param_1[1] = (char *)CONCAT44(iStack0000000000000014,param_8);\n  param_1[2] = (char *)CONCAT44(iStack000000000000001c,param_9);\n  if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return param_1;\n}",
                "globals": [],
                "externs": [
                    "SCARRY4",
                    "CONCAT44"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "get_curr_arg",
                        "c_isdigit",
                        "SCARRY4",
                        "CONCAT44",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "get_curr_arg",
                        "print_formatted"
                    ],
                    "defined_in_file": "printf_decompiled.c"
                }
            },
            {
                "func_name": "print_formatted",
                "func_c_signature": "int print_formatted(byte *param_1,int param_2,long param_3)",
                "decompiled_code": "int print_formatted(byte *param_1,int param_2,long param_3) {\n  byte *pbVar1;\n  FILE *__stream;\n  char cVar2;\n  int iVar3;\n  size_t sVar4;\n  long lVar5;\n  char *__s;\n  undefined8 uVar6;\n  byte *pbVar7;\n  long in_FS_OFFSET;\n  byte *local_1f8;\n  undefined8 local_1f0;\n  undefined8 local_1e8;\n  long local_1d0;\n  int local_1c4;\n  byte *local_1c0;\n  undefined local_1af;\n  undefined local_1ae;\n  byte local_1ad;\n  undefined4 local_1ac;\n  undefined4 local_1a8;\n  undefined4 local_1a4;\n  undefined4 local_1a0;\n  undefined4 local_19c;\n  undefined4 local_198;\n  undefined4 local_194;\n  undefined4 local_190;\n  undefined4 local_18c;\n  byte *local_188;\n  byte *local_180;\n  byte *local_178;\n  long local_170;\n  long local_168;\n  undefined8 local_160;\n  undefined8 local_158;\n  undefined8 local_150;\n  byte *local_148;\n  undefined8 local_140;\n  undefined8 local_138;\n  char local_128 [65];\n  undefined local_e7;\n  undefined local_e3;\n  undefined local_e2;\n  undefined local_e1;\n  undefined local_d0;\n  undefined local_c7;\n  undefined local_c5;\n  undefined local_c4;\n  undefined local_c3;\n  undefined local_c2;\n  undefined local_c1;\n  undefined local_bf;\n  undefined local_b9;\n  undefined local_b5;\n  undefined local_b3;\n  undefined local_b0;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_138 = 0xffffffffffffffff;\n  local_140 = 0xffffffffffffffff;\n  local_1ac = 0;\n  local_1a8 = 0;\n  local_1d0 = param_3;\n  local_1c4 = param_2;\n  local_1c0 = param_1;\n  sVar4 = strlen((char *)param_1);\n  local_180 = (byte *)xmalloc(sVar4 + 1);\n  local_148 = local_1c0;\nLAB_001020b6:\n  if (*local_148 == 0) {\n    free(local_180);\n    iVar3 = local_1c4;\n    if ((int)local_138 < local_1c4) {\n      iVar3 = (int)local_138 + 1;\n    }\n    if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    return iVar3;\n  }\n  if (*local_148 == 0x25) {\n    local_178 = local_148;\n    pbVar1 = local_148 + 1;\n    local_188 = local_180 + 1;\n    *local_180 = *local_148;\n    local_1ae = 0;\n    local_1af = 0;\n    local_148 = pbVar1;\n    if (*pbVar1 == 0x25) {\n      putchar_unlocked(0x25);\n      uVar6 = local_140;\n    }\n    else {\n      get_curr_arg(&local_148,0);\n      if (*local_148 == 0x62) {\n        get_curr_arg(&local_1f8,3);\n        local_148 = local_1f8;\n        local_140 = local_1f0;\n        uVar6 = local_140;\n        local_138 = local_1e8;\n        local_140._0_4_ = (int)local_1f0;\n        if ((int)local_140 < local_1c4) {\n          lVar5 = (long)(int)local_140;\n          local_140 = uVar6;\n          print_esc_string(*(undefined8 *)(local_1d0 + lVar5 * 8));\n          uVar6 = local_140;\n        }\n      }\n      else {\n        if (*local_148 != 0x71) {\n          memset(local_128,0,0x100);\n          local_d0 = 1;\n          local_b0 = 1;\n          local_b3 = 1;\n          local_b5 = 1;\n          local_b9 = 1;\n          local_bf = 1;\n          local_e1 = 1;\n          local_c1 = 1;\n          local_e2 = 1;\n          local_c2 = 1;\n          local_e3 = 1;\n          local_c3 = 1;\n          local_c4 = 1;\n          local_c5 = 1;\n          local_e7 = 1;\n          local_c7 = 1;\n          do {\n            switch(*local_148) {\n            case 0x20:\n            case 0x2b:\n            case 0x2d:\n              break;\n            default:\n              goto code_r0x00101a62;\n            case 0x23:\n              local_b3 = 0;\n              local_b5 = 0;\n              local_bf = 0;\n              local_c4 = 0;\n              local_c5 = 0;\n              break;\n            case 0x27:\n            case 0x49:\n              local_d0 = 0;\n              local_b0 = 0;\n              local_b5 = 0;\n              local_b9 = 0;\n              local_e3 = 0;\n              local_c3 = 0;\n              local_c5 = 0;\n              local_e7 = 0;\n              local_c7 = 0;\n              break;\n            case 0x30:\n              local_b5 = 0;\n              local_c5 = 0;\n            }\n            *local_188 = *local_148;\n            local_148 = local_148 + 1;\n            local_188 = local_188 + 1;\n          } while( true );\n        }\n        get_curr_arg(&local_1f8,3);\n        __stream = _stdout;\n        local_148 = local_1f8;\n        local_140 = local_1f0;\n        uVar6 = local_140;\n        local_138 = local_1e8;\n        local_140._0_4_ = (int)local_1f0;\n        if ((int)local_140 < local_1c4) {\n          lVar5 = (long)(int)local_140;\n          local_140 = uVar6;\n          __s = (char *)quotearg_style(3,*(undefined8 *)(local_1d0 + lVar5 * 8));\n          fputs_unlocked(__s,__stream);\n          uVar6 = local_140;\n        }\n      }\n    }\n  }\n  else if (*local_148 == 0x5c) {\n    iVar3 = print_esc(local_148,0);\n    local_148 = local_148 + iVar3;\n    uVar6 = local_140;\n  }\n  else {\n    putchar_unlocked((int)(char)*local_148);\n    uVar6 = local_140;\n  }\n  goto LAB_001020a4;\ncode_r0x00101a62:\n  if (*local_148 != 0x2a) {\n    while (cVar2 = c_isdigit((int)(char)*local_148), cVar2 != '\\0') {\n      *local_188 = *local_148;\n      local_188 = local_188 + 1;\n      local_148 = local_148 + 1;\n    }\n    goto LAB_00101c3e;\n  }\n  *local_188 = *local_148;\n  local_188 = local_188 + 1;\n  local_148 = local_148 + 1;\n  get_curr_arg(&local_1f8,1);\n  local_148 = local_1f8;\n  local_140 = local_1f0;\n  uVar6 = local_140;\n  local_138 = local_1e8;\n  local_140._0_4_ = (int)local_1f0;\n  if ((int)local_140 < local_1c4) {\n    lVar5 = (long)(int)local_140;\n    local_140 = uVar6;\n    local_170 = vstrtoimax(*(undefined8 *)(local_1d0 + lVar5 * 8));\n    if ((local_170 < -0x80000000) || (0x7fffffff < local_170)) {\n      uVar6 = quote(*(undefined8 *)(local_1d0 + (long)(int)local_140 * 8));\n      local_160 = gettext(\"invalid field width: %s\");\n      local_1a0 = 1;\n      local_19c = 0;\n      error(1,0,local_160,uVar6);\n      uVar6 = local_140;\n      goto LAB_00101bea;\n    }\n    local_1ac = (undefined4)local_170;\n  }\n  else {\nLAB_00101bea:\n    local_140 = uVar6;\n    local_1ac = 0;\n  }\n  local_1af = 1;\nLAB_00101c3e:\n  if (*local_148 == 0x2e) {\n    pbVar1 = local_148 + 1;\n    pbVar7 = local_188 + 1;\n    *local_188 = *local_148;\n    local_c5 = 0;\n    if (*pbVar1 == 0x2a) {\n      local_148 = local_148 + 2;\n      local_188 = local_188 + 2;\n      *pbVar7 = *pbVar1;\n      get_curr_arg(&local_1f8,2);\n      local_148 = local_1f8;\n      local_140 = local_1f0;\n      uVar6 = local_140;\n      local_138 = local_1e8;\n      local_140._0_4_ = (int)local_1f0;\n      local_140 = uVar6;\n      if ((int)local_140 < local_1c4) {\n        lVar5 = (long)(int)local_140;\n        local_168 = vstrtoimax(*(undefined8 *)(local_1d0 + lVar5 * 8));\n        if (local_168 < 0) {\n          local_1a8 = 0xffffffff;\n        }\n        else {\n          if (0x7fffffff < local_168) {\n            uVar6 = quote(*(undefined8 *)(local_1d0 + (long)(int)local_140 * 8));\n            local_158 = gettext(\"invalid precision: %s\");\n            local_198 = 1;\n            local_194 = 0;\n            error(1,0,local_158,uVar6);\n          }\n          local_1a8 = (undefined4)local_168;\n        }\n      }\n      else {\n        local_1a8 = 0;\n      }\n      local_1ae = 1;\n    }\n    else {\n      while (local_148 = pbVar1, local_188 = pbVar7, cVar2 = c_isdigit((int)(char)*local_148),\n            cVar2 != '\\0') {\n        *local_188 = *local_148;\n        pbVar7 = local_188 + 1;\n        pbVar1 = local_148 + 1;\n      }\n    }\n  }\n  pbVar1 = local_188 + 1;\n  *local_188 = 0;\n  for (; (((*local_148 == 0x6c || (*local_148 == 0x4c)) || (*local_148 == 0x68)) ||\n         (((*local_148 == 0x6a || (*local_148 == 0x74)) || (*local_148 == 0x7a))));\n      local_148 = local_148 + 1) {\n  }\n  local_1ad = *local_148;\n  pbVar7 = local_148 + (1 - (long)local_178);\n  if (0x7fffffff < (long)pbVar7) {\n    pbVar7 = (byte *)0x7fffffff;\n  }\n  local_1a4 = SUB84(pbVar7,0);\n  local_188 = pbVar1;\n  if (local_128[(int)(uint)local_1ad] == '\\0') {\n    local_150 = gettext(\"%.*s: invalid conversion specification\");\n    local_190 = 1;\n    local_18c = 0;\n    error(1,0,local_150,local_1a4,local_178);\n  }\n  get_curr_arg(&local_1f8,3);\n  local_148 = local_1f8;\n  local_140 = local_1f0;\n  local_138 = local_1e8;\n  print_direc(local_180,(int)(char)*local_1f8,local_1af,local_1ac,local_1ae,local_1a8);\n  uVar6 = local_140;\nLAB_001020a4:\n  local_140 = uVar6;\n  local_148 = local_148 + 1;\n  goto LAB_001020b6;\n}",
                "globals": [],
                "externs": [
                    "SUB84"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "print_formatted",
                        "strlen",
                        "xmalloc",
                        "free",
                        "__stack_chk_fail",
                        "putchar_unlocked",
                        "get_curr_arg",
                        "print_esc_string",
                        "memset",
                        "quotearg_style",
                        "fputs_unlocked",
                        "print_esc",
                        "c_isdigit",
                        "vstrtoimax",
                        "quote",
                        "gettext",
                        "error",
                        "SUB84",
                        "print_direc"
                    ],
                    "calling_functions": [
                        "print_formatted",
                        "main"
                    ],
                    "defined_in_file": "printf_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "undefined4 main(int param_1,undefined8 *param_2)",
                "decompiled_code": "undefined4 main(int param_1,undefined8 *param_2) {\n  char cVar1;\n  int iVar2;\n  char *pcVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  undefined8 *local_58;\n  int local_4c;\n  \n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit((__func *)&close_stdout);\n  exit_status = 0;\n  pcVar3 = getenv(\"POSIXLY_CORRECT\");\n  posixly_correct = pcVar3 != (char *)0x0;\n  if (param_1 == 2) {\n    cVar1 = streq(param_2[1],\"--help\");\n    if (cVar1 != '\\0') {\n      usage(0);\n    }\n    cVar1 = streq(param_2[1],\"--version\");\n    if (cVar1 != '\\0') {\n      uVar4 = proper_name_lite(\"David MacKenzie\",\"David MacKenzie\");\n      version_etc(_stdout,\"printf\",\"GNU coreutils\",_Version,uVar4,0);\n      return 0;\n    }\n  }\n  local_58 = param_2;\n  local_4c = param_1;\n  if ((1 < param_1) && (cVar1 = streq(param_2[1],&DAT_00102e4f), cVar1 != '\\0')) {\n    local_4c = param_1 + -1;\n    local_58 = param_2 + 1;\n  }\n  if (local_4c < 2) {\n    uVar4 = gettext(\"missing operand\");\n    error(0,0,uVar4);\n    usage(1);\n  }\n  uVar4 = local_58[1];\n  local_4c = local_4c + -2;\n  local_58 = local_58 + 2;\n  do {\n    iVar2 = print_formatted(uVar4,local_4c,local_58);\n    local_4c = local_4c - iVar2;\n    local_58 = local_58 + iVar2;\n    if (iVar2 < 1) break;\n  } while (0 < local_4c);\n  if (0 < local_4c) {\n    uVar4 = quote(*local_58);\n    uVar5 = gettext(\"warning: ignoring excess arguments, starting with %s\");\n    error(0,0,uVar5,uVar4);\n  }\n  return exit_status;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "getenv",
                        "streq",
                        "usage",
                        "proper_name_lite",
                        "version_etc",
                        "gettext",
                        "error",
                        "print_formatted",
                        "quote"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "printf_decompiled.c"
                }
            }
        ]
    }
}