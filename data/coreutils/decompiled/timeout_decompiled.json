{
    "file": "timeout",
    "decompiled_code": {
        "timeout.c": [
            {
                "func_name": "settimeout",
                "func_c_signature": "void settimeout(double param_1,char param_2)",
                "decompiled_code": "void settimeout(double param_1,char param_2) {\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  uint local_88;\n  timer_t local_70;\n  undefined8 local_68;\n  undefined8 local_60;\n  timespec local_58;\n  itimerspec local_48;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_48.it_value = (timespec)dtotimespec(param_1);\n  local_48.it_interval.tv_sec = 0;\n  local_48.it_interval.tv_nsec = 0;\n  local_58 = local_48.it_value;\n  iVar1 = timer_create(0,(sigevent *)0x0,&local_70);\n  if (iVar1 == 0) {\n    iVar1 = timer_settime(local_70,0,&local_48,(itimerspec *)0x0);\n    if (iVar1 == 0) goto LAB_00100480;\n    if (param_2 != '\\0') {\n      uVar2 = gettext(\"warning: timer_settime\");\n      piVar3 = __errno_location();\n      local_68 = uVar2;\n      error(0,*piVar3,uVar2);\n    }\n    timer_delete(local_70);\n  }\n  else if ((param_2 != '\\0') && (piVar3 = __errno_location(), *piVar3 != 0x26)) {\n    uVar2 = gettext(\"warning: timer_create\");\n    piVar3 = __errno_location();\n    local_60 = uVar2;\n    error(0,*piVar3,uVar2);\n  }\n  if (param_1 < _DAT_00102128) {\n    local_88 = (int)(long)param_1 + (uint)((double)((long)param_1 & 0xffffffff) < param_1);\n  }\n  else {\n    local_88 = 0xffffffff;\n  }\n  alarm(local_88);\nLAB_00100480:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "settimeout",
                        "dtotimespec",
                        "timer_create",
                        "timer_settime",
                        "gettext",
                        "__errno_location",
                        "error",
                        "timer_delete",
                        "alarm",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "settimeout",
                        "cleanup",
                        "main"
                    ],
                    "defined_in_file": "timeout_decompiled.c"
                }
            },
            {
                "func_name": "send_sig",
                "func_c_signature": "void send_sig(int param_1,int param_2)",
                "decompiled_code": "void send_sig(int param_1,int param_2) {\n  if (param_1 == 0) {\n    signal(param_2,(__sighandler_t)0x1);\n  }\n  kill(param_1,param_2);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "send_sig",
                        "signal",
                        "kill"
                    ],
                    "calling_functions": [
                        "send_sig",
                        "cleanup"
                    ],
                    "defined_in_file": "timeout_decompiled.c"
                }
            },
            {
                "func_name": "chld",
                "func_c_signature": "void chld(void)",
                "decompiled_code": "void chld(void) {\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "chld"
                    ],
                    "calling_functions": [
                        "chld"
                    ],
                    "defined_in_file": "timeout_decompiled.c"
                }
            },
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\"Usage: %s [OPTION]... DURATION COMMAND [ARG]...\\n\");\n    printf(pcVar3,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"Start COMMAND, and kill it if still running after DURATION.\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_mandatory_arg_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -f, --foreground\\n                 when not running timeout directly from a shell prompt,\\n                   allow COMMAND to read from the TTY and get TTY signals;\\n                   in this mode, children of COMMAND will not be timed out\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -k, --kill-after=DURATION\\n                 also send a KILL signal if COMMAND is still running\\n                   this long after the initial signal was sent\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -p, --preserve-status\\n                 exit with the same status as COMMAND,\\n                   even when the command times out\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -s, --signal=SIGNAL\\n                 specify the signal to be sent on timeout;\\n                   SIGNAL may be a name like \\'HUP\\' or a number;\\n                   see \\'kill -l\\' for a list of signals\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -v, --verbose  diagnose to standard error any signal sent upon timeout\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nDURATION is a floating point number with an optional suffix:\\n\\'s\\' for seconds (the default), \\'m\\' for minutes, \\'h\\' for hours or \\'d\\' for days.\\nA duration of 0 disables the associated timeout.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nUpon timeout, send the TERM signal to COMMAND, if no other SIGNAL specified.\\nThe TERM signal kills any process that does not block or catch that signal.\\nIt may be necessary to use the KILL signal, since this signal can\\'t be caught.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nExit status:\\n  124  if COMMAND times out, and --preserve-status is not specified\\n  125  if the timeout command itself fails\\n  126  if COMMAND is found but cannot be invoked\\n  127  if COMMAND cannot be found\\n  137  if COMMAND (or timeout itself) is sent the KILL (9) signal (128+9)\\n  -    the exit status of COMMAND otherwise\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_ancillary_info(\"timeout\");\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "seconds",
                    "COMMAND",
                    "KILL"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "fputs_unlocked",
                        "emit_mandatory_arg_note",
                        "seconds",
                        "COMMAND",
                        "KILL",
                        "signal",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "parse_duration",
                        "main"
                    ],
                    "defined_in_file": "timeout_decompiled.c"
                }
            },
            {
                "func_name": "apply_time_suffix",
                "func_c_signature": "undefined8 apply_time_suffix(double *param_1,char param_2)",
                "decompiled_code": "undefined8 apply_time_suffix(double *param_1,char param_2) {\n  undefined8 uVar1;\n  double dVar2;\n  int local_c;\n  \n  if (param_2 == 's') {\nLAB_001008e9:\n    local_c = 1;\nLAB_00100914:\n    dVar2 = (double)dtimespec_bound(*param_1 * (double)local_c,0);\n    *param_1 = dVar2;\n    uVar1 = 1;\n  }\n  else {\n    if (param_2 < 't') {\n      if (param_2 == 'm') {\n        local_c = 0x3c;\n        goto LAB_00100914;\n      }\n      if (param_2 < 'n') {\n        if (param_2 == 'h') {\n          local_c = 0xe10;\n          goto LAB_00100914;\n        }\n        if (param_2 < 'i') {\n          if (param_2 == '\\0') goto LAB_001008e9;\n          if (param_2 == 'd') {\n            local_c = 0x15180;\n            goto LAB_00100914;\n          }\n        }\n      }\n    }\n    uVar1 = 0;\n  }\n  return uVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "apply_time_suffix",
                        "dtimespec_bound"
                    ],
                    "calling_functions": [
                        "apply_time_suffix",
                        "parse_duration"
                    ],
                    "defined_in_file": "timeout_decompiled.c"
                }
            },
            {
                "func_name": "parse_duration",
                "func_c_signature": "double parse_duration(char *param_1)",
                "decompiled_code": "double parse_duration(char *param_1) {\n  char cVar1;\n  int *piVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  char *local_40;\n  double local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  piVar2 = __errno_location();\n  *piVar2 = 0;\n  local_30 = cl_strtod(param_1,&local_40);\n  piVar2 = __errno_location();\n  local_38 = (double)dtimespec_bound(local_30,*piVar2);\n  if (((param_1 != local_40) && (0.0 <= local_38)) && ((*local_40 == '\\0' || (local_40[1] == '\\0')))\n     ) {\n    cVar1 = apply_time_suffix(&local_38,(int)*local_40);\n    if (cVar1 == '\\x01') goto LAB_00100a65;\n  }\n  uVar3 = quote(param_1);\n  local_28 = gettext(\"invalid time interval %s\");\n  error(0,0,local_28,uVar3);\n  usage(0x7d);\nLAB_00100a65:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_38;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "parse_duration",
                        "__errno_location",
                        "cl_strtod",
                        "dtimespec_bound",
                        "apply_time_suffix",
                        "quote",
                        "gettext",
                        "error",
                        "usage",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "parse_duration",
                        "main"
                    ],
                    "defined_in_file": "timeout_decompiled.c"
                }
            },
            {
                "func_name": "unblock_signal",
                "func_c_signature": "void unblock_signal(int param_1)",
                "decompiled_code": "void unblock_signal(int param_1) {\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&local_a8);\n  sigaddset(&local_a8,param_1);\n  iVar1 = sigprocmask(1,&local_a8,(sigset_t *)0x0);\n  if (iVar1 != 0) {\n    uVar2 = gettext(\"warning: sigprocmask\");\n    piVar3 = __errno_location();\n    error(0,*piVar3,uVar2);\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "unblock_signal",
                        "sigemptyset",
                        "sigaddset",
                        "sigprocmask",
                        "gettext",
                        "__errno_location",
                        "error",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "unblock_signal",
                        "install_sigchld",
                        "main"
                    ],
                    "defined_in_file": "timeout_decompiled.c"
                }
            },
            {
                "func_name": "install_sigchld",
                "func_c_signature": "void install_sigchld(void)",
                "decompiled_code": "void install_sigchld(void) {\n  long in_FS_OFFSET;\n  sigaction local_a8;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&local_a8.sa_mask);\n  local_a8.__sigaction_handler.sa_handler = chld;\n  local_a8.sa_flags = 0x10000000;\n  sigaction(0x11,&local_a8,(sigaction *)0x0);\n  unblock_signal(0x11);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "install_sigchld",
                        "sigemptyset",
                        "sigaction",
                        "unblock_signal",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "install_sigchld",
                        "main"
                    ],
                    "defined_in_file": "timeout_decompiled.c"
                }
            },
            {
                "func_name": "install_cleanup",
                "func_c_signature": "void install_cleanup(int param_1)",
                "decompiled_code": "void install_cleanup(int param_1) {\n  long in_FS_OFFSET;\n  sigaction local_a8;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&local_a8.sa_mask);\n  local_a8.__sigaction_handler.sa_handler = cleanup;\n  local_a8.sa_flags = 0x10000000;\n  sigaction(0xe,&local_a8,(sigaction *)0x0);\n  sigaction(2,&local_a8,(sigaction *)0x0);\n  sigaction(3,&local_a8,(sigaction *)0x0);\n  sigaction(1,&local_a8,(sigaction *)0x0);\n  sigaction(0xf,&local_a8,(sigaction *)0x0);\n  sigaction(param_1,&local_a8,(sigaction *)0x0);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "install_cleanup",
                        "sigemptyset",
                        "sigaction",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "install_cleanup",
                        "main"
                    ],
                    "defined_in_file": "timeout_decompiled.c"
                }
            },
            {
                "func_name": "block_cleanup_and_chld",
                "func_c_signature": "void block_cleanup_and_chld(int param_1,sigset_t *param_2)",
                "decompiled_code": "void block_cleanup_and_chld(int param_1,sigset_t *param_2) {\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  long in_FS_OFFSET;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  sigemptyset(&local_a8);\n  sigaddset(&local_a8,0xe);\n  sigaddset(&local_a8,2);\n  sigaddset(&local_a8,3);\n  sigaddset(&local_a8,1);\n  sigaddset(&local_a8,0xf);\n  sigaddset(&local_a8,param_1);\n  sigaddset(&local_a8,0x11);\n  iVar1 = sigprocmask(0,&local_a8,param_2);\n  if (iVar1 != 0) {\n    uVar2 = gettext(\"warning: sigprocmask\");\n    piVar3 = __errno_location();\n    error(0,*piVar3,uVar2);\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "block_cleanup_and_chld",
                        "sigemptyset",
                        "sigaddset",
                        "sigprocmask",
                        "gettext",
                        "__errno_location",
                        "error",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "block_cleanup_and_chld",
                        "main"
                    ],
                    "defined_in_file": "timeout_decompiled.c"
                }
            },
            {
                "func_name": "disable_core_dumps",
                "func_c_signature": "bool disable_core_dumps(void)",
                "decompiled_code": "bool disable_core_dumps(void) {\n  int iVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  \n  iVar1 = prctl(4,0);\n  if (iVar1 != 0) {\n    uVar2 = gettext(\"warning: disabling core dumps failed\");\n    piVar3 = __errno_location();\n    error(0,*piVar3,uVar2);\n  }\n  return iVar1 == 0;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "disable_core_dumps",
                        "prctl",
                        "gettext",
                        "__errno_location",
                        "error"
                    ],
                    "calling_functions": [
                        "disable_core_dumps",
                        "main"
                    ],
                    "defined_in_file": "timeout_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "uint main(int param_1,undefined8 *param_2)",
                "decompiled_code": "uint main(int param_1,undefined8 *param_2) {\n  char **__argv;\n  char cVar1;\n  int iVar2;\n  uint uVar3;\n  long lVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  undefined8 uVar7;\n  long in_FS_OFFSET;\n  uint local_124;\n  int local_120;\n  __pid_t local_11c;\n  uint local_118;\n  uint local_114;\n  undefined4 local_110;\n  int local_10c;\n  undefined4 local_108;\n  int local_104;\n  undefined4 local_100;\n  int local_fc;\n  undefined4 local_f8;\n  int local_f4;\n  undefined4 local_f0;\n  undefined4 local_ec;\n  undefined4 local_e8;\n  undefined4 local_e4;\n  undefined8 local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined8 local_c8;\n  undefined8 local_c0;\n  undefined8 local_b8;\n  undefined8 local_b0;\n  sigset_t local_a8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  initialize_exit_failure(0x7d);\n  atexit((__func *)&close_stdout);\nLAB_0010108b:\n  do {\n    while( true ) {\n      local_120 = getopt_long(param_1,param_2,\"+fk:ps:v\",long_options,0);\n      if (local_120 == -1) {\n        if (param_1 - _optind < 2) {\n          usage(0x7d);\n        }\n        lVar4 = (long)_optind;\n        _optind = _optind + 1;\n        local_e0 = parse_duration(param_2[lVar4]);\n        __argv = (char **)(param_2 + _optind);\n        command = *__argv;\n        if (foreground != '\\x01') {\n          setpgid(0,0);\n        }\n        install_cleanup(term_signal);\n        signal(0x15,(__sighandler_t)0x1);\n        signal(0x16,(__sighandler_t)0x1);\n        install_sigchld();\n        unblock_signal(0xe);\n        block_cleanup_and_chld(term_signal,&local_a8);\n        monitored_pid = fork();\n        if (monitored_pid == -1) {\n          uVar5 = gettext(\"fork system call failed\");\n          piVar6 = __errno_location();\n          local_10c = *piVar6;\n          local_110 = 0;\n          local_d8 = uVar5;\n          error(0,local_10c,uVar5);\n          uVar3 = 0x7d;\n        }\n        else if (monitored_pid == 0) {\n          iVar2 = sigprocmask(2,&local_a8,(sigset_t *)0x0);\n          if (iVar2 == 0) {\n            signal(0x15,(__sighandler_t)0x0);\n            signal(0x16,(__sighandler_t)0x0);\n            execvp(*__argv,__argv);\n            piVar6 = __errno_location();\n            if (*piVar6 == 2) {\n              local_114 = 0x7f;\n            }\n            else {\n              local_114 = 0x7e;\n            }\n            uVar5 = quote(command);\n            uVar7 = gettext(\"failed to run command %s\");\n            piVar6 = __errno_location();\n            local_fc = *piVar6;\n            local_100 = 0;\n            local_c8 = uVar7;\n            error(0,local_fc,uVar7,uVar5);\n            uVar3 = local_114;\n          }\n          else {\n            uVar5 = gettext(\"child failed to reset signal mask\");\n            piVar6 = __errno_location();\n            local_104 = *piVar6;\n            local_108 = 0;\n            local_d0 = uVar5;\n            error(0,local_104,uVar5);\n            uVar3 = 0x7d;\n          }\n        }\n        else {\n          settimeout(local_e0,1);\n          while (local_11c = waitpid(monitored_pid,(int *)&local_124,1), local_11c == 0) {\n            sigsuspend(&local_a8);\n          }\n          if (local_11c < 0) {\n            uVar5 = gettext(\"error waiting for command\");\n            piVar6 = __errno_location();\n            local_f4 = *piVar6;\n            local_f8 = 0;\n            local_c0 = uVar5;\n            error(0,local_f4,uVar5);\n            local_124 = 0x7d;\n          }\n          else if ((local_124 & 0x7f) == 0) {\n            local_124 = (int)local_124 >> 8 & 0xff;\n          }\n          else if ((char)(((byte)local_124 & 0x7f) + 1) >> 1 < '\\x01') {\n            local_b0 = gettext(\"unknown status from command (%d)\");\n            local_e8 = 0;\n            local_e4 = 0;\n            error(0,0,local_b0,local_124);\n            local_124 = 1;\n          }\n          else {\n            local_118 = local_124 & 0x7f;\n            if ((local_124 & 0x80) != 0) {\n              local_b8 = gettext(\"the monitored command dumped core\");\n              local_f0 = 0;\n              local_ec = 0;\n              error(0,0,local_b8);\n            }\n            if ((timed_out == 0) && (cVar1 = disable_core_dumps(), cVar1 != '\\0')) {\n              signal(local_118,(__sighandler_t)0x0);\n              unblock_signal(local_118);\n              raise(local_118);\n            }\n            if ((timed_out != 0) && (local_118 == 9)) {\n              preserve_status = '\\x01';\n            }\n            local_124 = local_118 + 0x80;\n          }\n          uVar3 = local_124;\n          if ((timed_out != 0) && (preserve_status != '\\x01')) {\n            local_124 = 0x7c;\n            uVar3 = local_124;\n          }\n        }\n        if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n          __stack_chk_fail();\n        }\n        return uVar3;\n      }\n      if (local_120 < 0x77) break;\nswitchD_00100fa9_caseD_67:\n      usage(0x7d);\n    }\n    if (local_120 < 0x66) {\n      if (local_120 == -0x83) {\nLAB_00101025:\n        uVar5 = proper_name_lite(\"Padraig Brady\",&DAT_00101fed);\n        version_etc(_stdout,\"timeout\",\"GNU coreutils\",_Version,uVar5,0);\n                    /* WARNING: Subroutine does not return */\n        exit(0);\n      }\n      if (local_120 == -0x82) {\n        usage(0);\n        goto LAB_00101025;\n      }\n      goto switchD_00100fa9_caseD_67;\n    }\n    switch(local_120) {\n    case 0x66:\n      foreground = '\\x01';\n      break;\n    default:\n      goto switchD_00100fa9_caseD_67;\n    case 0x6b:\n      kill_after = parse_duration(_optarg);\n      break;\n    case 0x70:\n      preserve_status = '\\x01';\n      break;\n    case 0x73:\n      goto switchD_00100fa9_caseD_73;\n    case 0x76:\n      goto switchD_00100fa9_caseD_76;\n    }\n  } while( true );\nswitchD_00100fa9_caseD_73:\n  term_signal = operand2sig(_optarg);\n  if (term_signal == -1) {\n    usage(0x7d);\nswitchD_00100fa9_caseD_76:\n    verbose = 1;\n  }\n  goto LAB_0010108b;\n}",
                "globals": [],
                "externs": [
                    "command"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "initialize_exit_failure",
                        "atexit",
                        "getopt_long",
                        "usage",
                        "parse_duration",
                        "setpgid",
                        "install_cleanup",
                        "signal",
                        "install_sigchld",
                        "unblock_signal",
                        "block_cleanup_and_chld",
                        "fork",
                        "gettext",
                        "__errno_location",
                        "error",
                        "sigprocmask",
                        "execvp",
                        "quote",
                        "settimeout",
                        "waitpid",
                        "sigsuspend",
                        "command",
                        "disable_core_dumps",
                        "raise",
                        "__stack_chk_fail",
                        "proper_name_lite",
                        "version_etc",
                        "exit",
                        "operand2sig"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "timeout_decompiled.c"
                }
            }
        ]
    }
}