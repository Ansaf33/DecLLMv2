{
    "file": "cp",
    "decompiled_code": {
        "cp.c": [
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\n                            \"Usage: %s [OPTION]... [-T] SOURCE DEST\\n  or:  %s [OPTION]... SOURCE... DIRECTORY\\n  or:  %s [OPTION]... -t DIRECTORY SOURCE...\\n\"\n                            );\n    printf(pcVar3,uVar2,uVar2,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"Copy SOURCE to DEST, or multiple SOURCE(s) to DIRECTORY.\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_mandatory_arg_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -a, --archive                same as -dR --preserve=all\\n      --attributes-only        don\\'t copy the file data, just the attributes\\n      --backup[=CONTROL]       make a backup of each existing destination file\\n  -b                           like --backup but does not accept an argument\\n      --copy-contents          copy contents of special files when recursive\\n  -d                           same as --no-dereference --preserve=links\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"      --debug                  explain how a file is copied.  Implies -v\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -f, --force                  if an existing destination file cannot be\\n                                 opened, remove it and try again (this option\\n                                 is ignored when the -n option is also used)\\n  -i, --interactive            prompt before overwrite (overrides a previous -n\\n                                  option)\\n  -H                           follow command-line symbolic links in SOURCE\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -l, --link                   hard link files instead of copying\\n  -L, --dereference            always follow symbolic links in SOURCE\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -n, --no-clobber             (deprecated) silently skip existing files.\\n                                 See also --update\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -P, --no-dereference         never follow symbolic links in SOURCE\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -p                           same as --preserve=mode,ownership,timestamps\\n      --preserve[=ATTR_LIST]   preserve the specified attributes\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"      --no-preserve=ATTR_LIST  don\\'t preserve the specified attributes\\n      --parents                use full source file name under DIRECTORY\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -R, -r, --recursive          copy directories recursively\\n      --reflink[=WHEN]         control clone/CoW copies. See below\\n      --remove-destination     remove each existing destination file before\\n                                 attempting to open it (contrast with --force)\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"      --sparse=WHEN            control creation of sparse files. See below\\n      --strip-trailing-slashes  remove any trailing slashes from each SOURCE\\n                                 argument\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -s, --symbolic-link          make symbolic links instead of copying\\n  -S, --suffix=SUFFIX          override the usual backup suffix\\n  -t, --target-directory=DIRECTORY  copy all SOURCE arguments into DIRECTORY\\n  -T, --no-target-directory    treat DEST as a normal file\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"      --update[=UPDATE]        control which existing files are updated;\\n                                 UPDATE={all,none,none-fail,older(default)}\\n  -u                           equivalent to --update[=older].  See below\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"  -v, --verbose                explain what is being done\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"      --keep-directory-symlink  follow existing symlinks to directories\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"  -x, --one-file-system        stay on this file system\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -Z                           set SELinux security context of destination\\n                                 file to default type\\n      --context[=CTX]          like -Z, or if CTX is specified then set the\\n                                 SELinux or SMACK security context to CTX\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nATTR_LIST is a comma-separated list of attributes. Attributes are \\'mode\\' for\\npermissions (including any ACL and xattr permissions), \\'ownership\\' for user\\nand group, \\'timestamps\\' for file timestamps, \\'links\\' for hard links, \\'context\\'\\nfor security context, \\'xattr\\' for extended attributes, and \\'all\\' for all\\nattributes.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nBy default, sparse SOURCE files are detected by a crude heuristic and the\\ncorresponding DEST file is made sparse as well.  That is the behavior\\nselected by --sparse=auto.  Specify --sparse=always to create a sparse DEST\\nfile whenever the SOURCE file contains a long enough sequence of zero bytes.\\nUse --sparse=never to inhibit creation of sparse files.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_update_parameters_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nBy default or with --reflink=auto, cp will try a lightweight copy, where the\\ndata blocks are copied only when modified, falling back to a standard copy\\nif this is not possible.  With --reflink[=always] cp will fail if CoW is not\\nsupported, while --reflink=never ensures a standard copy is performed.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_backup_suffix_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nAs a special case, cp makes a backup of SOURCE when the force and backup\\noptions are given and SOURCE and DEST are the same name for an existing,\\nregular file.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_ancillary_info(&DAT_001048f2);\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "SOURCE",
                    "again",
                    "overwrite",
                    "clobber",
                    "it",
                    "older",
                    "npermissions"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "SOURCE",
                        "fputs_unlocked",
                        "emit_mandatory_arg_note",
                        "again",
                        "overwrite",
                        "clobber",
                        "it",
                        "older",
                        "npermissions",
                        "emit_update_parameters_note",
                        "emit_backup_suffix_note",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "do_copy",
                        "main"
                    ],
                    "defined_in_file": "cp_decompiled.c"
                }
            },
            {
                "func_name": "re_protect",
                "func_c_signature": "undefined8 re_protect(char *param_1,long param_2,int param_3,long param_4,long param_5,long param_6)",
                "decompiled_code": "undefined8 re_protect(char *param_1,long param_2,int param_3,long param_4,long param_5,long param_6) {\n  undefined4 uVar1;\n  undefined4 uVar2;\n  long lVar3;\n  long lVar4;\n  char *pcVar5;\n  void *pvVar6;\n  char cVar7;\n  int iVar8;\n  size_t sVar9;\n  ulong uVar10;\n  undefined8 uVar11;\n  int *piVar12;\n  undefined8 uVar13;\n  long *plVar14;\n  long in_FS_OFFSET;\n  timespec tVar15;\n  undefined auVar16 [16];\n  long local_e8;\n  long local_e0;\n  long local_d8;\n  int local_cc;\n  long local_c8;\n  char *local_c0;\n  undefined4 local_b4;\n  undefined4 local_b0;\n  int local_ac;\n  undefined4 local_a8;\n  int local_a4;\n  undefined4 local_a0;\n  int local_9c;\n  long local_98;\n  char *local_90;\n  size_t local_88;\n  void *local_80;\n  void *local_78;\n  long local_70;\n  char *local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined8 local_50;\n  timespec local_48;\n  undefined local_38 [24];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_e8 = param_6;\n  local_e0 = param_5;\n  local_d8 = param_4;\n  local_cc = param_3;\n  local_c8 = param_2;\n  local_c0 = param_1;\n  local_90 = param_1;\n  sVar9 = strlen(param_1);\n  local_88 = sVar9 + 1;\n  uVar10 = ((sVar9 + 0x18) / 0x10) * 0x10;\n  for (plVar14 = &local_e8; plVar14 != (long *)((long)&local_e8 - (uVar10 & 0xfffffffffffff000));\n      plVar14 = (long *)((long)plVar14 + -0x1000)) {\n    *(undefined8 *)((long)plVar14 + -8) = *(undefined8 *)((long)plVar14 + -8);\n  }\n  lVar3 = -(ulong)((uint)uVar10 & 0xfff);\n  if ((uVar10 & 0xfff) != 0) {\n    *(undefined8 *)((long)plVar14 + ((ulong)((uint)uVar10 & 0xfff) - 8) + lVar3) =\n         *(undefined8 *)((long)plVar14 + ((ulong)((uint)uVar10 & 0xfff) - 8) + lVar3);\n  }\n  sVar9 = local_88;\n  pcVar5 = local_90;\n  local_80 = (void *)((ulong)((long)plVar14 + lVar3 + 0xf) & 0xfffffffffffffff0);\n  *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x1007dd;\n  local_78 = memcpy((void *)((ulong)((long)plVar14 + lVar3 + 0xf) & 0xfffffffffffffff0),pcVar5,sVar9\n                   );\n  local_70 = (long)local_78 + (local_c8 - (long)local_c0);\n  local_68 = (char *)((long)local_78 + (local_d8 - (long)local_c0));\n  local_98 = local_e0;\n  do {\n    lVar4 = local_98;\n    if (local_98 == 0) {\n      uVar13 = 1;\nLAB_00100b1f:\n      if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x100b33;\n        __stack_chk_fail();\n      }\n      return uVar13;\n    }\n    *(undefined *)((long)local_78 + *(long *)(local_98 + 0x98)) = 0;\n    if (*(char *)(local_e8 + 0x21) != '\\0') {\n      *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x100866;\n      tVar15 = (timespec)get_stat_atime(lVar4);\n      lVar4 = local_98;\n      local_48 = tVar15;\n      *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x10087d;\n      auVar16 = get_stat_mtime(lVar4);\n      pcVar5 = local_68;\n      iVar8 = local_cc;\n      local_38._0_16_ = auVar16;\n      *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x10089f;\n      iVar8 = utimensat(iVar8,pcVar5,&local_48,0);\n      pvVar6 = local_78;\n      if (iVar8 != 0) {\n        *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x1008b4;\n        uVar13 = quotearg_style(4,pvVar6);\n        *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x1008c6;\n        uVar11 = gettext(\"failed to preserve times for %s\");\n        *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x1008ce;\n        piVar12 = __errno_location();\n        iVar8 = *piVar12;\n        local_b0 = 0;\n        local_ac = iVar8;\n        local_60 = uVar11;\n        *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x100903;\n        error(0,iVar8,uVar11,uVar13);\n        uVar13 = 0;\n        goto LAB_00100b1f;\n      }\n    }\n    pcVar5 = local_68;\n    iVar8 = local_cc;\n    if (*(char *)(local_e8 + 0x1f) != '\\0') {\n      uVar1 = *(undefined4 *)(local_98 + 0x20);\n      uVar2 = *(undefined4 *)(local_98 + 0x1c);\n      *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x100946;\n      iVar8 = lchownat(iVar8,pcVar5,uVar2,uVar1);\n      lVar4 = local_e8;\n      if (iVar8 != 0) {\n        *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x10095d;\n        cVar7 = chown_failure_ok(lVar4);\n        pcVar5 = local_68;\n        pvVar6 = local_78;\n        iVar8 = local_cc;\n        if (cVar7 != '\\x01') {\n          *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x100975;\n          uVar13 = quotearg_style(4,pvVar6);\n          *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x100987;\n          uVar11 = gettext(\"failed to preserve ownership for %s\");\n          *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x10098f;\n          piVar12 = __errno_location();\n          iVar8 = *piVar12;\n          local_a8 = 0;\n          local_a4 = iVar8;\n          local_58 = uVar11;\n          *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x1009c4;\n          error(0,iVar8,uVar11,uVar13);\n          uVar13 = 0;\n          goto LAB_00100b1f;\n        }\n        uVar1 = *(undefined4 *)(local_98 + 0x20);\n        *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x1009f1;\n        local_b4 = lchownat(iVar8,pcVar5,0xffffffff,uVar1);\n      }\n    }\n    pcVar5 = local_68;\n    lVar4 = local_70;\n    pvVar6 = local_78;\n    iVar8 = local_cc;\n    if (*(char *)(local_e8 + 0x20) == '\\0') {\n      if (*(char *)(local_98 + 0x90) != '\\0') {\n        uVar1 = *(undefined4 *)(local_98 + 0x18);\n        *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x100a73;\n        iVar8 = lchmodat(iVar8,pcVar5,uVar1);\n        pvVar6 = local_78;\n        if (iVar8 != 0) {\n          *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x100a88;\n          uVar13 = quotearg_style(4,pvVar6);\n          *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x100a9a;\n          uVar11 = gettext(\"failed to preserve permissions for %s\");\n          *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x100aa2;\n          piVar12 = __errno_location();\n          iVar8 = *piVar12;\n          local_a0 = 0;\n          local_9c = iVar8;\n          local_50 = uVar11;\n          *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x100ad7;\n          error(0,iVar8,uVar11,uVar13);\n          uVar13 = 0;\n          goto LAB_00100b1f;\n        }\n      }\n    }\n    else {\n      uVar1 = *(undefined4 *)(local_98 + 0x18);\n      *(undefined8 *)((long)plVar14 + lVar3 + -8) = 0x100a2d;\n      iVar8 = xcopy_acl(lVar4,0xffffffff,pvVar6,0xffffffff,uVar1);\n      if (iVar8 != 0) {\n        uVar13 = 0;\n        goto LAB_00100b1f;\n      }\n    }\n    *(undefined *)((long)local_78 + *(long *)(local_98 + 0x98)) = 0x2f;\n    local_98 = *(long *)(local_98 + 0xa0);\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "re_protect",
                        "strlen",
                        "memcpy",
                        "__stack_chk_fail",
                        "get_stat_atime",
                        "get_stat_mtime",
                        "utimensat",
                        "quotearg_style",
                        "gettext",
                        "__errno_location",
                        "error",
                        "lchownat",
                        "chown_failure_ok",
                        "lchmodat",
                        "xcopy_acl"
                    ],
                    "calling_functions": [
                        "re_protect",
                        "do_copy"
                    ],
                    "defined_in_file": "cp_decompiled.c"
                }
            },
            {
                "func_name": "make_dir_parents_private",
                "func_c_signature": "undefined8\nmake_dir_parents_private\n          (char *param_1,ulong param_2,int param_3,char *param_4,__dev_t **param_5,char *param_6,\n          long param_7)",
                "decompiled_code": "undefined8\nmake_dir_parents_private\n          (char *param_1,ulong param_2,int param_3,char *param_4,__dev_t **param_5,char *param_6,\n          long param_7) {\n  long lVar1;\n  long lVar2;\n  char *pcVar3;\n  void *pvVar4;\n  char *pcVar5;\n  char cVar6;\n  int iVar7;\n  undefined4 uVar8;\n  uint uVar9;\n  undefined8 uVar10;\n  size_t sVar11;\n  ulong uVar12;\n  int *piVar13;\n  undefined8 uVar14;\n  undefined *puVar15;\n  undefined *puVar16;\n  undefined *puVar17;\n  long in_FS_OFFSET;\n  undefined auStack_258 [8];\n  long local_250;\n  char *local_248;\n  __dev_t **local_240;\n  char *local_238;\n  int local_22c;\n  ulong local_228;\n  char *local_220;\n  char local_20d;\n  uint local_20c;\n  int local_208;\n  uint local_204;\n  uint local_200;\n  uint local_1fc;\n  undefined4 local_1f8;\n  int local_1f4;\n  undefined4 local_1f0;\n  int local_1ec;\n  undefined4 local_1e8;\n  int local_1e4;\n  undefined4 local_1e0;\n  int local_1dc;\n  undefined4 local_1d8;\n  undefined4 local_1d4;\n  undefined4 local_1d0;\n  undefined4 local_1cc;\n  char *local_1c8;\n  char *local_1c0;\n  __dev_t *local_1b8;\n  ulong local_1b0;\n  char *local_1a8;\n  size_t local_1a0;\n  void *local_198;\n  void *local_190;\n  char *local_188;\n  void *local_180;\n  undefined8 local_178;\n  undefined8 local_170;\n  undefined8 local_168;\n  undefined8 local_160;\n  undefined8 local_158;\n  undefined8 local_150;\n  stat local_148;\n  stat local_b8;\n  long local_20;\n  \n  puVar15 = auStack_258;\n  local_250 = param_7;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_248 = param_6;\n  local_240 = param_5;\n  local_238 = param_4;\n  local_22c = param_3;\n  local_228 = param_2;\n  local_220 = param_1;\n  local_1b0 = dir_len(param_1);\n  *local_240 = (__dev_t *)0x0;\n  if (local_228 < local_1b0) {\n    local_1a8 = local_220;\n    sVar11 = strlen(local_220);\n    local_1a0 = sVar11 + 1;\n    uVar12 = ((sVar11 + 0x18) / 0x10) * 0x10;\n    for (; puVar15 != auStack_258 + -(uVar12 & 0xfffffffffffff000); puVar15 = puVar15 + -0x1000) {\n      *(undefined8 *)(puVar15 + -8) = *(undefined8 *)(puVar15 + -8);\n    }\n    lVar1 = -(ulong)((uint)uVar12 & 0xfff);\n    puVar16 = puVar15 + lVar1;\n    if ((uVar12 & 0xfff) != 0) {\n      *(undefined8 *)(puVar15 + ((ulong)((uint)uVar12 & 0xfff) - 8) + lVar1) =\n           *(undefined8 *)(puVar15 + ((ulong)((uint)uVar12 & 0xfff) - 8) + lVar1);\n    }\n    sVar11 = local_1a0;\n    pcVar3 = local_1a8;\n    local_198 = (void *)((ulong)(puVar15 + lVar1 + 0xf) & 0xfffffffffffffff0);\n    *(undefined8 *)(puVar15 + lVar1 + -8) = 0x100ca6;\n    local_190 = memcpy((void *)((ulong)(puVar15 + lVar1 + 0xf) & 0xfffffffffffffff0),pcVar3,sVar11);\n    local_188 = (char *)(local_228 + (long)local_190);\n    uVar12 = ((local_1b0 + 0x18) / 0x10) * 0x10;\n    for (; puVar16 != puVar15 + (lVar1 - (uVar12 & 0xfffffffffffff000)); puVar16 = puVar16 + -0x1000\n        ) {\n      *(undefined8 *)(puVar16 + -8) = *(undefined8 *)(puVar16 + -8);\n    }\n    lVar1 = -(ulong)((uint)uVar12 & 0xfff);\n    puVar17 = puVar16 + lVar1;\n    if ((uVar12 & 0xfff) != 0) {\n      *(undefined8 *)(puVar16 + ((ulong)((uint)uVar12 & 0xfff) - 8) + lVar1) =\n           *(undefined8 *)(puVar16 + ((ulong)((uint)uVar12 & 0xfff) - 8) + lVar1);\n    }\n    pvVar4 = local_190;\n    sVar11 = local_1b0;\n    local_180 = (void *)((ulong)(puVar16 + lVar1 + 0xf) & 0xfffffffffffffff0);\n    *(undefined8 *)(puVar16 + lVar1 + -8) = 0x100d78;\n    memcpy((void *)((ulong)(puVar16 + lVar1 + 0xf) & 0xfffffffffffffff0),pvVar4,sVar11);\n    iVar7 = local_22c;\n    *(undefined *)((long)local_180 + local_1b0) = 0;\n    for (local_1c8 = (char *)(local_228 + (long)local_180); pcVar3 = local_1c8, *local_1c8 == '/';\n        local_1c8 = local_1c8 + 1) {\n    }\n    *(undefined8 *)(puVar16 + lVar1 + -8) = 0x100ddc;\n    iVar7 = fstatat(iVar7,pcVar3,&local_148,0);\n    pvVar4 = local_180;\n    if (iVar7 == 0) {\n      if ((local_148.st_mode & 0xf000) != 0x4000) {\n        *(undefined8 *)(puVar16 + lVar1 + -8) = 0x101562;\n        uVar10 = quotearg_style(4,pvVar4);\n        *(undefined8 *)(puVar16 + lVar1 + -8) = 0x101574;\n        uVar14 = gettext(\"%s exists but is not a directory\");\n        local_1d0 = 0;\n        local_1cc = 0;\n        local_150 = uVar14;\n        *(undefined8 *)(puVar16 + lVar1 + -8) = 0x1015b1;\n        error(0,0,uVar14,uVar10);\n        uVar10 = 0;\n        goto LAB_001015c8;\n      }\n      *local_248 = '\\0';\n    }\n    else {\n      for (local_1c0 = local_188; *local_1c0 == '/'; local_1c0 = local_1c0 + 1) {\n      }\n      local_1c8 = local_1c0;\n      while( true ) {\n        pcVar3 = local_1c0;\n        *(undefined8 *)(puVar16 + lVar1 + -8) = 0x101522;\n        local_1c0 = strchr(pcVar3,0x2f);\n        pcVar3 = local_1c8;\n        iVar7 = local_22c;\n        if (local_1c0 == (char *)0x0) break;\n        *local_1c0 = '\\0';\n        *(undefined8 *)(puVar16 + lVar1 + -8) = 0x100e47;\n        iVar7 = fstatat(iVar7,pcVar3,&local_148,0);\n        pcVar3 = local_188;\n        local_20d = iVar7 != 0;\n        if (((((bool)local_20d) || (*(char *)(local_250 + 0x1f) != '\\0')) ||\n            (*(char *)(local_250 + 0x20) != '\\0')) || (*(char *)(local_250 + 0x21) != '\\0')) {\n          *(undefined8 *)(puVar16 + lVar1 + -8) = 0x100ea5;\n          iVar7 = stat(pcVar3,&local_b8);\n          if (iVar7 == 0) {\n            if ((local_b8.st_mode & 0xf000) == 0x4000) {\n              local_208 = 0;\n            }\n            else {\n              local_208 = 0x14;\n            }\n          }\n          else {\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x100eae;\n            piVar13 = __errno_location();\n            local_208 = *piVar13;\n          }\n          pcVar3 = local_188;\n          if (local_208 != 0) {\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x100ef3;\n            uVar10 = quotearg_style(4,pcVar3);\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x100f05;\n            uVar14 = gettext(\"failed to get attributes of %s\");\n            iVar7 = local_208;\n            local_1f8 = 0;\n            local_1f4 = local_208;\n            local_178 = uVar14;\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x100f44;\n            error(0,iVar7,uVar14,uVar10);\n            uVar10 = 0;\n            puVar17 = puVar16 + lVar1;\n            goto LAB_001015c8;\n          }\n          *(undefined8 *)(puVar16 + lVar1 + -8) = 0x100f59;\n          local_1b8 = (__dev_t *)xmalloc(0xa8);\n          *local_1b8 = local_b8.st_dev;\n          local_1b8[1] = local_b8.st_ino;\n          local_1b8[2] = local_b8.st_nlink;\n          local_1b8[3] = CONCAT44(local_b8.st_uid,local_b8.st_mode);\n          local_1b8[4] = local_b8._32_8_;\n          local_1b8[5] = local_b8.st_rdev;\n          local_1b8[6] = local_b8.st_size;\n          local_1b8[7] = local_b8.st_blksize;\n          local_1b8[8] = local_b8.st_blocks;\n          local_1b8[9] = local_b8.st_atim.tv_sec;\n          local_1b8[10] = local_b8.st_atim.tv_nsec;\n          local_1b8[0xb] = local_b8.st_mtim.tv_sec;\n          local_1b8[0xc] = local_b8.st_mtim.tv_nsec;\n          local_1b8[0xd] = local_b8.st_ctim.tv_sec;\n          local_1b8[0xe] = local_b8.st_ctim.tv_nsec;\n          local_1b8[0xf] = local_b8.__unused[0];\n          local_1b8[0x10] = local_b8.__unused[1];\n          local_1b8[0x11] = local_b8.__unused[2];\n          local_1b8[0x13] = (long)local_1c0 - (long)local_190;\n          *(undefined *)(local_1b8 + 0x12) = 0;\n          local_1b8[0x14] = (__dev_t)*local_240;\n          *local_240 = local_1b8;\n        }\n        pcVar3 = local_188;\n        pvVar4 = local_190;\n        cVar6 = local_20d;\n        lVar2 = local_250;\n        if (local_20d == '\\0') {\n          uVar8 = 0;\n        }\n        else {\n          uVar8 = *(undefined4 *)(local_1b8 + 3);\n        }\n        *(undefined8 *)(puVar16 + lVar1 + -8) = 0x1010a6;\n        cVar6 = set_process_security_ctx(pcVar3,pvVar4,uVar8,cVar6,lVar2);\n        pvVar4 = local_190;\n        pcVar3 = local_1c8;\n        iVar7 = local_22c;\n        if (cVar6 != '\\x01') {\n          uVar10 = 0;\n          puVar17 = puVar16 + lVar1;\n          goto LAB_001015c8;\n        }\n        if (local_20d == '\\0') {\n          if ((local_148.st_mode & 0xf000) != 0x4000) {\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x101412;\n            uVar10 = quotearg_style(4,pvVar4);\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x101424;\n            uVar14 = gettext(\"%s exists but is not a directory\");\n            local_1d8 = 0;\n            local_1d4 = 0;\n            local_158 = uVar14;\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x101461;\n            error(0,0,uVar14,uVar10);\n            uVar10 = 0;\n            puVar17 = puVar16 + lVar1;\n            goto LAB_001015c8;\n          }\n          *local_248 = '\\0';\n        }\n        else {\n          *local_248 = '\\x01';\n          local_204 = *(uint *)(local_1b8 + 3);\n          if (*(char *)(local_250 + 0x1f) == '\\x01') {\n            local_20c = 0x3f;\n          }\n          else if (*(char *)(local_250 + 0x20) == '\\0') {\n            local_20c = 0;\n          }\n          else {\n            local_20c = 0x12;\n          }\n          local_20c = local_20c & local_204;\n          uVar9 = local_204;\n          if (*(char *)(local_250 + 0x22) != '\\0') {\n            uVar9 = 0x1ff;\n          }\n          uVar9 = ~local_20c & uVar9 & 0xfff;\n          local_200 = uVar9;\n          *(undefined8 *)(puVar16 + lVar1 + -8) = 0x101176;\n          iVar7 = mkdirat(iVar7,pcVar3,uVar9);\n          pcVar5 = local_188;\n          pvVar4 = local_190;\n          pcVar3 = local_238;\n          if (iVar7 != 0) {\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x10118e;\n            uVar10 = quotearg_style(4,pvVar4);\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x1011a0;\n            uVar14 = gettext(\"cannot make directory %s\");\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x1011a8;\n            piVar13 = __errno_location();\n            iVar7 = *piVar13;\n            local_1f0 = 0;\n            local_1ec = iVar7;\n            local_170 = uVar14;\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x1011e3;\n            error(0,iVar7,uVar14,uVar10);\n            uVar10 = 0;\n            puVar17 = puVar16 + lVar1;\n            goto LAB_001015c8;\n          }\n          if (local_238 != (char *)0x0) {\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x10121d;\n            printf(pcVar3,pcVar5,pvVar4);\n          }\n          pcVar3 = local_1c8;\n          iVar7 = local_22c;\n          *(undefined8 *)(puVar16 + lVar1 + -8) = 0x10123d;\n          iVar7 = fstatat(iVar7,pcVar3,&local_148,0x100);\n          pvVar4 = local_190;\n          if (iVar7 != 0) {\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x101255;\n            uVar10 = quotearg_style(4,pvVar4);\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x101267;\n            uVar14 = gettext(\"failed to get attributes of %s\");\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x10126f;\n            piVar13 = __errno_location();\n            iVar7 = *piVar13;\n            local_1e8 = 0;\n            local_1e4 = iVar7;\n            local_168 = uVar14;\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x1012aa;\n            error(0,iVar7,uVar14,uVar10);\n            uVar10 = 0;\n            puVar17 = puVar16 + lVar1;\n            goto LAB_001015c8;\n          }\n          if (*(char *)(local_250 + 0x20) != '\\x01') {\n            if ((~local_148.st_mode & local_20c) != 0) {\n              *(undefined8 *)(puVar16 + lVar1 + -8) = 0x1012de;\n              uVar9 = cached_umask();\n              local_20c = local_20c & ~uVar9;\n            }\n            if (((~local_148.st_mode & local_20c) != 0) || ((local_148.st_mode & 0x1c0) != 0x1c0)) {\n              *(__mode_t *)(local_1b8 + 3) = local_148.st_mode | local_20c;\n              *(undefined *)(local_1b8 + 0x12) = 1;\n            }\n          }\n          pcVar3 = local_1c8;\n          iVar7 = local_22c;\n          uVar9 = local_148.st_mode | 0x1c0;\n          local_1fc = uVar9;\n          if (uVar9 != local_148.st_mode) {\n            *(undefined8 *)(puVar16 + lVar1 + -8) = 0x101370;\n            iVar7 = lchmodat(iVar7,pcVar3,uVar9);\n            pvVar4 = local_190;\n            if (iVar7 != 0) {\n              *(undefined8 *)(puVar16 + lVar1 + -8) = 0x10138c;\n              uVar10 = quotearg_style(4,pvVar4);\n              *(undefined8 *)(puVar16 + lVar1 + -8) = 0x10139e;\n              uVar14 = gettext(\"setting permissions for %s\");\n              *(undefined8 *)(puVar16 + lVar1 + -8) = 0x1013a6;\n              piVar13 = __errno_location();\n              iVar7 = *piVar13;\n              local_1e0 = 0;\n              local_1dc = iVar7;\n              local_160 = uVar14;\n              *(undefined8 *)(puVar16 + lVar1 + -8) = 0x1013e1;\n              error(0,iVar7,uVar14,uVar10);\n              uVar10 = 0;\n              puVar17 = puVar16 + lVar1;\n              goto LAB_001015c8;\n            }\n          }\n        }\n        pvVar4 = local_190;\n        lVar2 = local_250;\n        if ((*local_248 != '\\x01') &&\n           ((*(long *)(local_250 + 0x28) != 0 || (*(char *)(local_250 + 0x33) != '\\0')))) {\n          *(undefined8 *)(puVar16 + lVar1 + -8) = 0x1014c1;\n          cVar6 = set_file_security_ctx(pvVar4,0,lVar2);\n          if ((cVar6 != '\\x01') && (*(char *)(local_250 + 0x34) != '\\0')) {\n            uVar10 = 0;\n            puVar17 = puVar16 + lVar1;\n            goto LAB_001015c8;\n          }\n        }\n        *local_1c0 = '/';\n        do {\n          local_1c0 = local_1c0 + 1;\n        } while (*local_1c0 == '/');\n      }\n    }\n    uVar10 = 1;\n    puVar17 = puVar16 + lVar1;\n  }\n  else {\n    uVar10 = 1;\n    puVar17 = auStack_258;\n  }\nLAB_001015c8:\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar10;\n  }\n                    /* WARNING: Subroutine does not return */\n  *(undefined8 *)(puVar17 + -8) = 0x1015dc;\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [
                    "CONCAT44"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "make_dir_parents_private",
                        "dir_len",
                        "strlen",
                        "memcpy",
                        "fstatat",
                        "quotearg_style",
                        "gettext",
                        "error",
                        "strchr",
                        "stat",
                        "__errno_location",
                        "xmalloc",
                        "CONCAT44",
                        "set_process_security_ctx",
                        "mkdirat",
                        "printf",
                        "cached_umask",
                        "lchmodat",
                        "set_file_security_ctx",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "make_dir_parents_private",
                        "do_copy"
                    ],
                    "defined_in_file": "cp_decompiled.c"
                }
            },
            {
                "func_name": "do_copy",
                "func_c_signature": "byte do_copy(int param_1,EVP_PKEY_CTX **param_2,EVP_PKEY_CTX *param_3,char param_4,ulong *param_5)",
                "decompiled_code": "byte do_copy(int param_1,EVP_PKEY_CTX **param_2,EVP_PKEY_CTX *param_3,char param_4,ulong *param_5) {\n  long lVar1;\n  ulong *puVar2;\n  undefined4 uVar3;\n  char *pcVar4;\n  EVP_PKEY_CTX *dst;\n  char cVar5;\n  byte bVar6;\n  uint uVar7;\n  int iVar8;\n  undefined8 uVar9;\n  undefined8 uVar10;\n  int *piVar11;\n  size_t sVar12;\n  ulong uVar13;\n  void *pvVar14;\n  EVP_PKEY_CTX *pEVar15;\n  long lVar16;\n  char *pcVar17;\n  undefined *puVar18;\n  ulong **ppuVar19;\n  long in_FS_OFFSET;\n  ulong *local_1e8;\n  EVP_PKEY_CTX *local_1e0;\n  EVP_PKEY_CTX **local_1d8;\n  char local_1d0;\n  int local_1cc;\n  char local_1c4;\n  undefined local_1c3;\n  byte local_1c2;\n  char local_1c1;\n  undefined4 local_1c0;\n  int local_1bc;\n  undefined4 local_1b8;\n  int local_1b4;\n  undefined4 local_1b0;\n  undefined4 local_1ac;\n  undefined4 local_1a8;\n  undefined4 local_1a4;\n  undefined4 local_1a0;\n  undefined4 local_19c;\n  undefined4 local_198;\n  undefined4 local_194;\n  undefined4 local_190;\n  int local_18c;\n  undefined4 local_188;\n  int local_184;\n  undefined4 local_180;\n  undefined4 local_17c;\n  void *local_178;\n  char *local_170;\n  EVP_PKEY_CTX *local_168;\n  char *local_160;\n  EVP_PKEY_CTX *local_158;\n  EVP_PKEY_CTX *local_150;\n  EVP_PKEY_CTX *local_148;\n  EVP_PKEY_CTX *local_140;\n  char *local_138;\n  size_t local_130;\n  void *local_128;\n  void *local_120;\n  EVP_PKEY_CTX *local_118;\n  size_t local_110;\n  void *local_108;\n  void *local_100;\n  void *local_f8;\n  undefined8 local_f0;\n  undefined8 local_e8;\n  undefined8 local_e0;\n  undefined8 local_d8;\n  undefined8 local_d0;\n  undefined8 local_c8;\n  undefined8 local_c0;\n  stat local_b8;\n  long local_20;\n  \n  ppuVar19 = &local_1e8;\n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_1c4 = '\\0';\n  local_1c2 = 1;\n  local_1e8 = param_5;\n  local_1e0 = param_3;\n  local_1d8 = param_2;\n  local_1d0 = param_4;\n  local_1cc = param_1;\n  if (param_1 <= (int)(uint)(param_3 == (EVP_PKEY_CTX *)0x0)) {\n    if (param_1 < 1) {\n      local_f0 = gettext(\"missing file operand\");\n      local_1b0 = 0;\n      local_1ac = 0;\n      error(0,0,local_f0);\n    }\n    else {\n      uVar9 = quotearg_style(4,*param_2);\n      local_e8 = gettext(\"missing destination file operand after %s\");\n      local_1a8 = 0;\n      local_1a4 = 0;\n      error(0,0,local_e8,uVar9);\n    }\n    usage(1);\n  }\n  local_b8.st_mode = 0;\n  local_1c0 = 0xffffff9c;\n  if (local_1d0 != '\\0') {\n    if (local_1e0 != (EVP_PKEY_CTX *)0x0) {\n      local_e0 = gettext(\"cannot combine --target-directory (-t) and --no-target-directory (-T)\");\n      local_1a0 = 1;\n      local_19c = 0;\n      error(1,0,local_e0);\n    }\n    if (local_1cc < 3) goto LAB_001019c6;\n    uVar9 = quotearg_style(4,local_1d8[2]);\n    local_d8 = gettext(\"extra operand %s\");\n    local_198 = 0;\n    local_194 = 0;\n    error(0,0,local_d8,uVar9);\n    usage(1);\n  }\n  if (local_1e0 != (EVP_PKEY_CTX *)0x0) {\n    local_1c0 = target_directory_operand(local_1e0,&local_b8);\n    cVar5 = target_dirfd_valid(local_1c0);\n    if (cVar5 == '\\x01') goto LAB_001019c6;\n    uVar9 = quotearg_style(4,local_1e0);\n    uVar10 = gettext(\"target directory %s\");\n    piVar11 = __errno_location();\n    local_18c = *piVar11;\n    local_190 = 1;\n    local_d0 = uVar10;\n    error(1,local_18c,uVar10,uVar9);\n  }\n  local_150 = local_1d8[(long)local_1cc + -1];\n  local_1b8 = target_directory_operand(local_150,&local_b8);\n  cVar5 = target_dirfd_valid(local_1b8);\n  if (cVar5 == '\\0') {\n    piVar11 = __errno_location();\n    local_1b4 = *piVar11;\n    if (local_1b4 == 2) {\n      local_1c4 = '\\x01';\n    }\n    if (2 < local_1cc) {\n      uVar9 = quotearg_style(4,local_150);\n      local_c8 = gettext(\"target %s\");\n      local_188 = 1;\n      local_184 = local_1b4;\n      error(1,local_1b4,local_c8,uVar9);\n    }\n  }\n  else {\n    local_1c0 = local_1b8;\n    local_1e0 = local_150;\n    local_1cc = local_1cc + -1;\n  }\nLAB_001019c6:\n  if (local_1e0 == (EVP_PKEY_CTX *)0x0) {\n    local_148 = *local_1d8;\n    local_158 = local_1d8[1];\n    if (parents_option != '\\0') {\n      local_c0 = gettext(\"with --parents, the destination must be a directory\");\n      local_180 = 0;\n      local_17c = 0;\n      error(0,0,local_c0);\n      usage(1);\n    }\n    if (((((*(char *)((long)local_1e8 + 0x16) != '\\0') && (*(int *)local_1e8 != 0)) &&\n         (cVar5 = streq(local_148,local_158), cVar5 != '\\0')) &&\n        ((local_1c4 != '\\x01' &&\n         ((local_b8.st_mode != 0 || (iVar8 = stat((char *)local_158,&local_b8), iVar8 == 0)))))) &&\n       ((local_b8.st_mode & 0xf000) == 0x8000)) {\n      local_158 = (EVP_PKEY_CTX *)find_backup_file_name(0xffffff9c,local_158,*(int *)local_1e8);\n      x_tmp_3._8_8_ = local_1e8[1];\n      x_tmp_3._16_8_ = local_1e8[2];\n      x_tmp_3._24_8_ = local_1e8[3];\n      x_tmp_3._32_8_ = local_1e8[4];\n      x_tmp_3._40_8_ = local_1e8[5];\n      x_tmp_3._48_8_ = local_1e8[6];\n      x_tmp_3._56_8_ = local_1e8[7];\n      x_tmp_3._64_8_ = local_1e8[8];\n      x_tmp_3._72_8_ = local_1e8[9];\n      x_tmp_3._88_8_ = local_1e8[0xb];\n      x_tmp_3._80_8_ = local_1e8[10];\n      x_tmp_3._0_8_ = *local_1e8 & 0xffffffff00000000;\n      local_1e8 = (ulong *)x_tmp_3;\n    }\n    iVar8 = copy(local_148,local_158);\n    local_1c2 = (byte)iVar8;\n    ppuVar19 = &local_1e8;\n  }\n  else {\n    if (1 < local_1cc) {\n      dest_info_init(local_1e8);\n      src_info_init(local_1e8);\n    }\n    for (local_1bc = 0; local_1bc < local_1cc; local_1bc = local_1bc + 1) {\n      local_1c1 = '\\x01';\n      pEVar15 = local_1d8[local_1bc];\n      local_140 = pEVar15;\n      if (remove_trailing_slashes != '\\0') {\n        *(undefined8 *)((long)ppuVar19 + -8) = 0x101a4f;\n        strip_trailing_slashes(pEVar15);\n      }\n      pEVar15 = local_140;\n      if (parents_option == '\\0') {\n        *(undefined8 *)((long)ppuVar19 + -8) = 0x101bf4;\n        pcVar17 = (char *)last_component(pEVar15);\n        local_138 = pcVar17;\n        *(undefined8 *)((long)ppuVar19 + -8) = 0x101c0a;\n        sVar12 = strlen(pcVar17);\n        local_130 = sVar12 + 1;\n        uVar13 = ((sVar12 + 0x18) / 0x10) * 0x10;\n        for (puVar18 = (undefined *)ppuVar19;\n            puVar18 != (undefined *)((long)ppuVar19 + -(uVar13 & 0xfffffffffffff000));\n            puVar18 = puVar18 + -0x1000) {\n          *(undefined8 *)(puVar18 + -8) = *(undefined8 *)(puVar18 + -8);\n        }\n        lVar1 = -(ulong)((uint)uVar13 & 0xfff);\n        ppuVar19 = (ulong **)(puVar18 + lVar1);\n        if ((uVar13 & 0xfff) != 0) {\n          *(undefined8 *)(puVar18 + ((ulong)((uint)uVar13 & 0xfff) - 8) + lVar1) =\n               *(undefined8 *)(puVar18 + ((ulong)((uint)uVar13 & 0xfff) - 8) + lVar1);\n        }\n        sVar12 = local_130;\n        pcVar17 = local_138;\n        local_128 = (void *)((ulong)(puVar18 + lVar1 + 0xf) & 0xfffffffffffffff0);\n        *(undefined8 *)(puVar18 + lVar1 + -8) = 0x101cc4;\n        pvVar14 = memcpy((void *)((ulong)(puVar18 + lVar1 + 0xf) & 0xfffffffffffffff0),pcVar17,\n                         sVar12);\n        local_120 = pvVar14;\n        *(undefined8 *)(puVar18 + lVar1 + -8) = 0x101cda;\n        strip_trailing_slashes(pvVar14);\n        pvVar14 = local_120;\n        *(undefined8 *)(puVar18 + lVar1 + -8) = 0x101cf3;\n        bVar6 = streq(pvVar14,&DAT_00104aa7);\n        pEVar15 = local_1e0;\n        lVar16 = (long)local_120 + (ulong)bVar6;\n        local_120 = (void *)lVar16;\n        *(undefined8 *)(puVar18 + lVar1 + -8) = 0x101d1d;\n        local_168 = (EVP_PKEY_CTX *)file_name_concat(pEVar15,lVar16,&local_170);\n      }\n      else {\n        local_118 = local_140;\n        *(undefined8 *)((long)ppuVar19 + -8) = 0x101a7b;\n        sVar12 = strlen((char *)pEVar15);\n        local_110 = sVar12 + 1;\n        uVar13 = ((sVar12 + 0x18) / 0x10) * 0x10;\n        for (puVar18 = (undefined *)ppuVar19;\n            puVar18 != (undefined *)((long)ppuVar19 + -(uVar13 & 0xfffffffffffff000));\n            puVar18 = puVar18 + -0x1000) {\n          *(undefined8 *)(puVar18 + -8) = *(undefined8 *)(puVar18 + -8);\n        }\n        lVar1 = -(ulong)((uint)uVar13 & 0xfff);\n        ppuVar19 = (ulong **)(puVar18 + lVar1);\n        if ((uVar13 & 0xfff) != 0) {\n          *(undefined8 *)(puVar18 + ((ulong)((uint)uVar13 & 0xfff) - 8) + lVar1) =\n               *(undefined8 *)(puVar18 + ((ulong)((uint)uVar13 & 0xfff) - 8) + lVar1);\n        }\n        sVar12 = local_110;\n        pEVar15 = local_118;\n        local_108 = (void *)((ulong)(puVar18 + lVar1 + 0xf) & 0xfffffffffffffff0);\n        *(undefined8 *)(puVar18 + lVar1 + -8) = 0x101b35;\n        pvVar14 = memcpy((void *)((ulong)(puVar18 + lVar1 + 0xf) & 0xfffffffffffffff0),pEVar15,\n                         sVar12);\n        local_100 = pvVar14;\n        *(undefined8 *)(puVar18 + lVar1 + -8) = 0x101b4b;\n        strip_trailing_slashes(pvVar14);\n        pvVar14 = local_100;\n        pEVar15 = local_1e0;\n        *(undefined8 *)(puVar18 + lVar1 + -8) = 0x101b6b;\n        pEVar15 = (EVP_PKEY_CTX *)file_name_concat(pEVar15,pvVar14,&local_170);\n        uVar3 = local_1c0;\n        if (*(char *)(local_1e8 + 8) == '\\0') {\n          pcVar17 = (char *)0x0;\n        }\n        else {\n          pcVar17 = \"%s -> %s\\n\";\n        }\n        lVar16 = (long)local_170 - (long)pEVar15;\n        local_168 = pEVar15;\n        *(ulong **)(puVar18 + lVar1 + -0x10) = local_1e8;\n        *(undefined8 *)(puVar18 + lVar1 + -0x18) = 0x101bd6;\n        local_1c1 = make_dir_parents_private(pEVar15,lVar16,uVar3,pcVar17,&local_178,&local_1c4);\n      }\n      dst = local_140;\n      pEVar15 = local_168;\n      if (local_1c1 == '\\x01') {\n        for (local_160 = local_170; *local_160 == '/'; local_160 = local_160 + 1) {\n        }\n        *(undefined8 *)((long)ppuVar19 + -8) = 0;\n        *(undefined **)((long)ppuVar19 + -0x10) = &local_1c3;\n        *(undefined8 *)((long)ppuVar19 + -0x18) = 0x101da3;\n        uVar7 = copy(dst,pEVar15);\n        pcVar4 = local_160;\n        pEVar15 = local_168;\n        pcVar17 = local_170;\n        pvVar14 = local_178;\n        uVar3 = local_1c0;\n        puVar2 = local_1e8;\n        local_1c2 = (uVar7 & 0xff & (uint)local_1c2) != 0;\n        if (parents_option != '\\0') {\n          *(undefined8 *)((long)ppuVar19 + -8) = 0x101e00;\n          bVar6 = re_protect(pEVar15,pcVar17,uVar3,pcVar4,pvVar14,puVar2);\n          local_1c2 = (bVar6 & local_1c2) != 0;\n        }\n      }\n      else {\n        local_1c2 = false;\n      }\n      if (parents_option != '\\0') {\n        while (pvVar14 = local_178, local_178 != (void *)0x0) {\n          local_f8 = local_178;\n          local_178 = *(void **)((long)local_178 + 0xa0);\n          *(undefined8 *)((long)ppuVar19 + -8) = 0x101e56;\n          free(pvVar14);\n        }\n      }\n      pEVar15 = local_168;\n      *(undefined8 *)((long)ppuVar19 + -8) = 0x101e71;\n      free(pEVar15);\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_1c2;\n  }\n                    /* WARNING: Subroutine does not return */\n  *(undefined8 *)((long)ppuVar19 + -8) = 0x1020de;\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [
                    "directory"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "do_copy",
                        "gettext",
                        "error",
                        "quotearg_style",
                        "usage",
                        "directory",
                        "target_directory_operand",
                        "target_dirfd_valid",
                        "__errno_location",
                        "streq",
                        "stat",
                        "find_backup_file_name",
                        "copy",
                        "dest_info_init",
                        "src_info_init",
                        "strip_trailing_slashes",
                        "last_component",
                        "strlen",
                        "memcpy",
                        "file_name_concat",
                        "make_dir_parents_private",
                        "re_protect",
                        "free",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "do_copy",
                        "main"
                    ],
                    "defined_in_file": "cp_decompiled.c"
                }
            },
            {
                "func_name": "cp_option_init",
                "func_c_signature": "void cp_option_init(long param_1)",
                "decompiled_code": "void cp_option_init(long param_1) {\n  char *pcVar1;\n  \n  cp_options_default(param_1);\n  *(undefined *)(param_1 + 0x14) = 1;\n  *(undefined4 *)(param_1 + 4) = 1;\n  *(undefined *)(param_1 + 0x15) = 0;\n  *(undefined *)(param_1 + 0x16) = 0;\n  *(undefined *)(param_1 + 0x17) = 0;\n  *(undefined4 *)(param_1 + 8) = 0;\n  *(undefined *)(param_1 + 0x18) = 0;\n  *(undefined *)(param_1 + 0x1b) = 0;\n  *(undefined *)(param_1 + 0x1e) = 0;\n  *(undefined4 *)(param_1 + 0x4c) = 1;\n  *(undefined *)(param_1 + 0x1f) = 0;\n  *(undefined *)(param_1 + 0x30) = 0;\n  *(undefined *)(param_1 + 0x20) = 0;\n  *(undefined *)(param_1 + 0x21) = 0;\n  *(undefined *)(param_1 + 0x22) = 0;\n  *(undefined *)(param_1 + 0x33) = 0;\n  *(undefined *)(param_1 + 0x34) = 0;\n  *(undefined8 *)(param_1 + 0x28) = 0;\n  *(undefined *)(param_1 + 0x35) = 0;\n  *(undefined *)(param_1 + 0x37) = 0;\n  *(undefined *)(param_1 + 0x36) = 0;\n  *(undefined *)(param_1 + 0x31) = 1;\n  *(undefined *)(param_1 + 0x32) = 0;\n  *(undefined *)(param_1 + 0x38) = 0;\n  *(undefined4 *)(param_1 + 0xc) = 2;\n  *(undefined *)(param_1 + 0x3a) = 0;\n  *(undefined *)(param_1 + 0x39) = 0;\n  *(undefined4 *)(param_1 + 0x10) = 0;\n  *(undefined *)(param_1 + 0x43) = 0;\n  *(undefined4 *)(param_1 + 0x3c) = 0;\n  *(undefined *)(param_1 + 0x40) = 0;\n  *(undefined *)(param_1 + 0x41) = 0;\n  pcVar1 = getenv(\"POSIXLY_CORRECT\");\n  *(bool *)(param_1 + 0x44) = pcVar1 != (char *)0x0;\n  *(undefined8 *)(param_1 + 0x50) = 0;\n  *(undefined8 *)(param_1 + 0x58) = 0;\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "cp_option_init",
                        "cp_options_default",
                        "getenv"
                    ],
                    "calling_functions": [
                        "cp_option_init",
                        "main"
                    ],
                    "defined_in_file": "cp_decompiled.c"
                }
            },
            {
                "func_name": "decode_preserve_arg",
                "func_c_signature": "void decode_preserve_arg(undefined8 param_1,long param_2,char param_3)",
                "decompiled_code": "void decode_preserve_arg(undefined8 param_1,long param_2,char param_3) {\n  char *__ptr;\n  char *pcVar1;\n  long lVar2;\n  char *local_20;\n  char *local_18;\n  \n  __ptr = (char *)xstrdup(param_1);\n  local_20 = __ptr;\n  do {\n    pcVar1 = strchr(local_20,0x2c);\n    local_18 = pcVar1;\n    if (pcVar1 != (char *)0x0) {\n      local_18 = pcVar1 + 1;\n      *pcVar1 = '\\0';\n    }\n    if (param_3 == '\\0') {\n      pcVar1 = \"--no-preserve\";\n    }\n    else {\n      pcVar1 = \"--preserve\";\n    }\n    lVar2 = __xargmatch_internal(pcVar1,local_20,preserve_args_2,preserve_vals_1,4,_argmatch_die,1);\n    switch(*(undefined4 *)(preserve_vals_1 + lVar2 * 4)) {\n    case 0:\n      *(char *)(param_2 + 0x20) = param_3;\n      *(bool *)(param_2 + 0x22) = param_3 == '\\0';\n      break;\n    case 1:\n      *(char *)(param_2 + 0x21) = param_3;\n      break;\n    case 2:\n      *(char *)(param_2 + 0x1f) = param_3;\n      break;\n    case 3:\n      *(char *)(param_2 + 0x30) = param_3;\n      break;\n    case 4:\n      *(char *)(param_2 + 0x34) = param_3;\n      *(char *)(param_2 + 0x33) = param_3;\n      break;\n    case 5:\n      *(char *)(param_2 + 0x35) = param_3;\n      *(char *)(param_2 + 0x36) = param_3;\n      break;\n    case 6:\n      *(char *)(param_2 + 0x20) = param_3;\n      *(char *)(param_2 + 0x21) = param_3;\n      *(char *)(param_2 + 0x1f) = param_3;\n      *(char *)(param_2 + 0x30) = param_3;\n      *(bool *)(param_2 + 0x22) = param_3 == '\\0';\n      if (selinux_enabled != '\\0') {\n        *(char *)(param_2 + 0x33) = param_3;\n      }\n      *(char *)(param_2 + 0x35) = param_3;\n      break;\n    default:\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"0\",\n                    \"/workspace/home/aiclub1/B220032CS_Jaefar/fyp/repos/ansaf/coreutils/src/cp.c\",\n                    0x3c5,\"decode_preserve_arg\");\n    }\n    local_20 = local_18;\n  } while (local_18 != (char *)0x0);\n  free(__ptr);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "decode_preserve_arg",
                        "xstrdup",
                        "strchr",
                        "__xargmatch_internal",
                        "__assert_fail",
                        "free"
                    ],
                    "calling_functions": [
                        "decode_preserve_arg",
                        "main"
                    ],
                    "defined_in_file": "cp_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "void main(int param_1,undefined8 *param_2)",
                "decompiled_code": "void main(int param_1,undefined8 *param_2) {\n  bool bVar1;\n  byte bVar2;\n  int iVar3;\n  long lVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  undefined8 uVar7;\n  int *piVar8;\n  long in_FS_OFFSET;\n  undefined local_14f;\n  undefined local_14e;\n  long local_f8;\n  long local_f0;\n  long local_e8;\n  long local_e0;\n  undefined4 local_88;\n  int local_84;\n  int local_80;\n  int local_7c;\n  undefined local_74;\n  undefined local_73;\n  undefined local_72;\n  char local_71;\n  undefined local_6a;\n  undefined local_69;\n  undefined local_68;\n  undefined local_67;\n  long local_60;\n  undefined local_58;\n  undefined local_57;\n  undefined local_56;\n  char local_55;\n  char local_54;\n  undefined local_53;\n  char local_52;\n  undefined local_51;\n  char local_50;\n  char local_4e;\n  int local_4c;\n  undefined local_48;\n  undefined local_47;\n  undefined local_46;\n  int local_3c;\n  undefined8 local_20;\n  \n  local_20 = *(undefined8 *)(in_FS_OFFSET + 0x28);\n  bVar1 = false;\n  local_f8 = 0;\n  local_f0 = 0;\n  local_14f = 0;\n  local_e8 = 0;\n  local_14e = 0;\n  local_e0 = 0;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit((__func *)&close_stdin);\n  selinux_enabled = '\\0';\n  cp_option_init(&local_88);\nLAB_00102ac6:\n  do {\n    iVar3 = getopt_long(param_1,param_2,\"abdfHilLnprst:uvxPRS:TZ\",long_opts,0);\n    if (iVar3 == -1) {\n      if ((local_3c == 1) && (local_7c == 1)) {\n        local_3c = 0;\n      }\n      if ((local_71 != '\\0') && (local_4e != '\\0')) {\n        uVar6 = gettext(\"cannot make both hard and symbolic links\");\n        error(0,0,uVar6);\n        usage(1);\n      }\n      if (local_80 == 2) {\n        local_4c = 2;\n      }\n      if ((bVar1) && ((local_4c == 2 || (local_4c == 3)))) {\n        uVar6 = gettext(\"--backup is mutually exclusive with -n or --update=none-fail\");\n        error(0,0,uVar6);\n        usage(1);\n      }\n      if ((local_3c == 2) && (local_7c != 2)) {\n        uVar6 = gettext(\"--reflink can be used only with --sparse=auto\");\n        error(0,0,uVar6);\n        usage(1);\n      }\n      if (bVar1) {\n        uVar6 = gettext(\"backup type\");\n        local_88 = xget_version(uVar6,local_f0);\n      }\n      else {\n        local_88 = 0;\n      }\n      set_simple_backup_suffix(local_f8);\n      if (local_84 == 1) {\n        if ((local_50 == '\\0') || (local_71 == '\\x01')) {\n          local_84 = 4;\n        }\n        else {\n          local_84 = 2;\n        }\n      }\n      if (local_50 != '\\0') {\n        local_74 = local_14f;\n      }\n      if (((local_60 != 0) || (local_e0 != 0)) && (local_54 != '\\x01')) {\n        local_55 = '\\0';\n      }\n      if ((local_55 != '\\0') && ((local_60 != 0 || (local_e0 != 0)))) {\n        uVar6 = gettext(\"cannot set target context and preserve it\");\n        error(1,0,uVar6);\n      }\n      if ((local_54 != '\\0') && (selinux_enabled != '\\x01')) {\n        uVar6 = gettext(\"cannot preserve security context without an SELinux-enabled kernel\");\n        error(1,0,uVar6);\n      }\n      if ((local_e0 != 0) && (iVar3 = setfscreatecon(local_e0), iVar3 < 0)) {\n        uVar6 = quote(local_e0);\n        uVar7 = gettext(\"failed to set default file creation context to %s\");\n        piVar8 = __errno_location();\n        error(1,*piVar8,uVar7,uVar6);\n      }\n      if (local_52 != '\\0') {\n        uVar6 = gettext(\"cannot preserve extended attributes, cp is built without xattr support\");\n        error(1,0,uVar6);\n      }\n      hash_init();\n      bVar2 = do_copy(param_1 - _optind,param_2 + _optind,local_e8,local_14e,&local_88);\n                    /* WARNING: Subroutine does not return */\n      exit((uint)(bVar2 ^ 1));\n    }\n    switch(iVar3) {\n    case 0x48:\n      local_84 = 3;\n      break;\n    case 0x4c:\n      local_84 = 4;\n      break;\n    case 0x50:\n      local_84 = 2;\n      break;\n    case 0x52:\n    case 0x72:\n      local_50 = '\\x01';\n      break;\n    case 0x53:\n      bVar1 = true;\n      local_f8 = _optarg;\n      break;\n    case 0x54:\n      local_14e = 1;\n      break;\n    case 0x5a:\n      if (selinux_enabled == '\\0') {\n        if (_optarg != 0) {\n          uVar6 = gettext(\"warning: ignoring --context; it requires an SELinux-enabled kernel\");\n          error(0,0,uVar6);\n        }\n      }\n      else if (_optarg == 0) {\n        local_60 = selabel_open(0,0,0);\n        if (local_60 == 0) {\n          uVar6 = gettext(\"warning: ignoring --context\");\n          piVar8 = __errno_location();\n          error(0,*piVar8,uVar6);\n        }\n      }\n      else {\n        local_e0 = _optarg;\n      }\n      break;\n    case 0x61:\n      local_84 = 2;\n      local_58 = 1;\n      local_69 = 1;\n      local_68 = 1;\n      local_67 = 1;\n      local_56 = 1;\n      if (selinux_enabled != '\\0') {\n        local_55 = '\\x01';\n      }\n      local_53 = 1;\n      local_51 = 1;\n      local_50 = '\\x01';\n      break;\n    case 0x62:\n      bVar1 = true;\n      if (_optarg != 0) {\n        local_f0 = _optarg;\n      }\n      break;\n    case 100:\n      local_58 = 1;\n      local_84 = 2;\n      break;\n    case 0x66:\n      local_72 = 1;\n      break;\n    case 0x69:\n      local_80 = 3;\n      break;\n    case 0x6c:\n      local_71 = '\\x01';\n      break;\n    case 0x6e:\n      local_80 = 2;\n      break;\n    case 0x73:\n      local_4e = '\\x01';\n      break;\n    case 0x74:\n      if (local_e8 != 0) {\n        uVar6 = gettext(\"multiple target directories specified\");\n        error(1,0,uVar6);\n      }\n      local_e8 = _optarg;\n      break;\n    case 0x75:\n      local_4c = 1;\n      if (_optarg != 0) {\n        lVar4 = __xargmatch_internal\n                          (\"--update\",_optarg,update_type_string,update_type,4,_argmatch_die,1);\n        local_4c = *(int *)(update_type + lVar4 * 4);\n      }\n      break;\n    case 0x76:\n      local_48 = 1;\n      break;\n    case 0x78:\n      local_6a = 1;\n      break;\n    case 0x80:\n      local_57 = 0;\n      break;\n    case 0x81:\n      local_14f = 1;\n      break;\n    case 0x82:\n      local_48 = 1;\n      local_46 = 1;\n      break;\n    case 0x83:\n      decode_preserve_arg(_optarg,&local_88,0);\n      break;\n    case 0x84:\n      parents_option = 1;\n      break;\n    case 0x85:\n      if (_optarg != 0) {\n        decode_preserve_arg(_optarg,&local_88,1);\n        local_56 = 1;\n        break;\n      }\n    case 0x70:\n      local_69 = 1;\n      local_68 = 1;\n      local_67 = 1;\n      local_56 = 1;\n      break;\n    case 0x86:\n      if (_optarg == 0) {\n        local_3c = 2;\n      }\n      else {\n        lVar4 = __xargmatch_internal\n                          (\"--reflink\",_optarg,reflink_type_string,reflink_type,4,_argmatch_die,1);\n        local_3c = *(int *)(reflink_type + lVar4 * 4);\n      }\n      break;\n    case 0x87:\n      lVar4 = __xargmatch_internal\n                        (\"--sparse\",_optarg,sparse_type_string,sparse_type,4,_argmatch_die,1);\n      local_7c = *(int *)(sparse_type + lVar4 * 4);\n      break;\n    case 0x88:\n      remove_trailing_slashes = 1;\n      break;\n    case 0x89:\n      local_73 = 1;\n      break;\n    case 0x8a:\n      goto switchD_00102597_caseD_8a;\n    case -0x82:\n      usage(0);\n    case -0x83:\n      uVar6 = proper_name_lite(\"Jim Meyering\",\"Jim Meyering\");\n      uVar7 = proper_name_lite(\"David MacKenzie\",\"David MacKenzie\");\n      uVar5 = proper_name_lite(\"Torbjorn Granlund\",&DAT_00104c58);\n      version_etc(_stdout,&DAT_001048f2,\"GNU coreutils\",_Version,uVar5,uVar7,uVar6,0);\n                    /* WARNING: Subroutine does not return */\n      exit(0);\n    default:\n      usage(1);\n    }\n  } while( true );\nswitchD_00102597_caseD_8a:\n  local_47 = 1;\n  goto LAB_00102ac6;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "cp_option_init",
                        "getopt_long",
                        "gettext",
                        "error",
                        "usage",
                        "xget_version",
                        "set_simple_backup_suffix",
                        "setfscreatecon",
                        "quote",
                        "__errno_location",
                        "hash_init",
                        "do_copy",
                        "exit",
                        "selabel_open",
                        "__xargmatch_internal",
                        "decode_preserve_arg",
                        "proper_name_lite",
                        "version_etc"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "cp_decompiled.c"
                }
            }
        ]
    }
}