{
    "file": "od",
    "decompiled_code": {
        "od.c": [
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\n                            \"Usage: %s [OPTION]... [FILE]...\\n  or:  %s [-abcdfilosx]... [FILE] [[+]OFFSET[.][b]]\\n  or:  %s --traditional [OPTION]... [FILE] [[+]OFFSET[.][b] [+][LABEL][.][b]]\\n\"\n                            );\n    printf(pcVar3,uVar2,uVar2,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nWrite an unambiguous representation, octal bytes by default,\\nof FILE to standard output.  With more than one FILE argument,\\nconcatenate them in the listed order to form the input.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_stdin_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nIf first and second call formats both apply, the second format is assumed\\nif the last operand begins with + or (if there are 2 operands) a digit.\\nAn OFFSET operand means -j OFFSET.  LABEL is the pseudo-address\\nat first byte printed, incremented when dump is progressing.\\nFor OFFSET and LABEL, a 0x or 0X prefix indicates hexadecimal;\\nsuffixes may be . for octal and b for multiply by 512.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_mandatory_arg_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -A, --address-radix=RADIX   output format for file offsets; RADIX is one\\n                                of [doxn], for Decimal, Octal, Hex or None\\n      --endian={big|little}   swap input bytes according the specified order\\n  -j, --skip-bytes=BYTES      skip BYTES input bytes first\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -N, --read-bytes=BYTES      limit dump to BYTES input bytes\\n  -S BYTES, --strings[=BYTES]  show only NUL terminated strings\\n                                of at least BYTES (3) printable characters\\n  -t, --format=TYPE           select output format or formats\\n  -v, --output-duplicates     do not use * to mark line suppression\\n  -w[BYTES], --width[=BYTES]  output BYTES bytes per output line;\\n                                32 is implied when BYTES is not specified\\n      --traditional           accept arguments in third form above\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\n\\nTraditional format specifications may be intermixed; they accumulate:\\n  -a   same as -t a,  select named characters, ignoring high-order bit\\n  -b   same as -t o1, select octal bytes\\n  -c   same as -t c,  select printable characters or backslash escapes\\n  -d   same as -t u2, select unsigned decimal 2-byte units\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -f   same as -t fF, select floats\\n  -i   same as -t dI, select decimal ints\\n  -l   same as -t dL, select decimal longs\\n  -o   same as -t o2, select octal 2-byte units\\n  -s   same as -t d2, select decimal 2-byte units\\n  -x   same as -t x2, select hexadecimal 2-byte units\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\n\\nTYPE is made up of one or more of these specifications:\\n  a          named character, ignoring high-order bit\\n  c          printable character or backslash escape\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  d[SIZE]    signed decimal, SIZE bytes per integer\\n  f[SIZE]    floating point, SIZE bytes per float\\n  o[SIZE]    octal, SIZE bytes per integer\\n  u[SIZE]    unsigned decimal, SIZE bytes per integer\\n  x[SIZE]    hexadecimal, SIZE bytes per integer\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nSIZE is a number.  For TYPE in [doux], SIZE may also be C for\\nsizeof(char), S for sizeof(short), I for sizeof(int) or L for\\nsizeof(long).  If TYPE is f, SIZE may also be B for Brain 16 bit,\\nH for Half precision float, F for sizeof(float), D for sizeof(double),\\nor L for sizeof(long double).\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nAdding a z suffix to any type displays printable characters at the end of\\neach output line.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\n\\nBYTES is hex with 0x or 0X prefix, and may have a multiplier suffix:\\n  b    512\\n  KB   1000\\n  K    1024\\n  MB   1000*1000\\n  M    1024*1024\\nand so on for G, T, P, E, Z, Y, R, Q.\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_ancillary_info(&DAT_001061de);\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "or",
                    "BYTES",
                    "nsizeof",
                    "sizeof"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "fputs_unlocked",
                        "emit_stdin_note",
                        "or",
                        "emit_mandatory_arg_note",
                        "BYTES",
                        "nsizeof",
                        "sizeof",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "print_n_spaces",
                "func_c_signature": "void print_n_spaces(long param_1)",
                "decompiled_code": "void print_n_spaces(long param_1) {\n  long local_10;\n  \n  for (local_10 = param_1; 0 < local_10; local_10 = local_10 + -1) {\n    putchar_unlocked(0x20);\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "print_n_spaces",
                        "putchar_unlocked"
                    ],
                    "calling_functions": [
                        "print_n_spaces",
                        "write_block"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "pad_at",
                "func_c_signature": "long pad_at(long param_1,long param_2,long param_3)",
                "decompiled_code": "long pad_at(long param_1,long param_2,long param_3) {\n  return ((param_3 % param_1) * param_2) / param_1 + (param_3 / param_1) * param_2;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "pad_at"
                    ],
                    "calling_functions": [
                        "pad_at",
                        "print_s_char",
                        "print_char",
                        "print_s_short",
                        "print_short",
                        "print_int",
                        "print_long",
                        "print_long_long",
                        "print_intmax",
                        "print_bfloat",
                        "print_halffloat",
                        "print_float",
                        "print_double",
                        "print_long_double",
                        "print_named_ascii",
                        "print_ascii",
                        "write_block"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "pad_at_overflow",
                "func_c_signature": "bool pad_at_overflow(long param_1)",
                "decompiled_code": "bool pad_at_overflow(long param_1) {\n  long in_FS_OFFSET;\n  \n  if (*(long *)(in_FS_OFFSET + 0x28) != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return SEXT816((param_1 + -1) * (param_1 + -1)) != SEXT816(param_1 + -1) * SEXT816(param_1 + -1);\n}",
                "globals": [],
                "externs": [
                    "SEXT816"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "pad_at_overflow",
                        "__stack_chk_fail",
                        "SEXT816"
                    ],
                    "calling_functions": [
                        "pad_at_overflow",
                        "main"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "dump_hexl_mode_trailer",
                "func_c_signature": "void dump_hexl_mode_trailer(long param_1,byte *param_2)",
                "decompiled_code": "void dump_hexl_mode_trailer(long param_1,byte *param_2) {\n  byte bVar1;\n  ushort **ppuVar2;\n  byte *local_28;\n  long local_10;\n  \n  fwrite_unlocked(&DAT_001061e5,1,3,_stdout);\n  local_28 = param_2;\n  for (local_10 = param_1; 0 < local_10; local_10 = local_10 + -1) {\n    bVar1 = *local_28;\n    ppuVar2 = __ctype_b_loc();\n    if (((*ppuVar2)[bVar1] & 0x4000) == 0) {\n      bVar1 = 0x2e;\n    }\n    putchar_unlocked((uint)bVar1);\n    local_28 = local_28 + 1;\n  }\n  putchar_unlocked(0x3c);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "dump_hexl_mode_trailer",
                        "fwrite_unlocked",
                        "__ctype_b_loc",
                        "putchar_unlocked"
                    ],
                    "calling_functions": [
                        "dump_hexl_mode_trailer",
                        "write_block"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "print_named_ascii",
                "func_c_signature": "void print_named_ascii(long param_1,long param_2,byte *param_3,undefined8 param_4,int param_5,\n                      undefined8 param_6)",
                "decompiled_code": "void print_named_ascii(long param_1,long param_2,byte *param_3,undefined8 param_4,int param_5,\n                      undefined8 param_6) {\n  uint uVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  byte *local_40;\n  undefined8 local_38;\n  long local_30;\n  undefined *local_28;\n  undefined local_12;\n  undefined local_11;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_40 = param_3;\n  local_38 = param_6;\n  for (local_30 = param_1; param_2 < local_30; local_30 = local_30 + -1) {\n    uVar1 = *local_40 & 0x7f;\n    if (uVar1 == 0x7f) {\n      local_28 = &DAT_001061e9;\n    }\n    else if (uVar1 < 0x21) {\n      local_28 = charname + (long)(int)uVar1 * 4;\n    }\n    else {\n      local_12 = (undefined)uVar1;\n      local_11 = 0;\n      local_28 = &local_12;\n    }\n    uVar2 = pad_at(param_1,local_30 + -1,param_6);\n    xprintf(&DAT_001061e1,param_5 + ((int)local_38 - (int)uVar2),local_28);\n    local_40 = local_40 + 1;\n    local_38 = uVar2;\n  }\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "print_named_ascii",
                        "pad_at",
                        "xprintf",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "print_named_ascii"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "print_ascii",
                "func_c_signature": "void print_ascii(long param_1,long param_2,byte *param_3,undefined8 param_4,int param_5,\n                undefined8 param_6)",
                "decompiled_code": "void print_ascii(long param_1,long param_2,byte *param_3,undefined8 param_4,int param_5,\n                undefined8 param_6) {\n  byte bVar1;\n  ushort **ppuVar2;\n  char *__format;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  byte *local_50;\n  undefined8 local_48;\n  long local_40;\n  char *local_38;\n  char local_24 [4];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_50 = param_3;\n  local_48 = param_6;\n  for (local_40 = param_1; param_2 < local_40; local_40 = local_40 + -1) {\n    bVar1 = *local_50;\n    switch(bVar1) {\n    case 0:\n      local_38 = \"\\\\0\";\n      break;\n    default:\n      ppuVar2 = __ctype_b_loc();\n      if (((*ppuVar2)[bVar1] & 0x4000) == 0) {\n        __format = \"%03o\";\n      }\n      else {\n        __format = \"%c\";\n      }\n      sprintf(local_24,__format,(ulong)bVar1);\n      local_38 = local_24;\n      break;\n    case 7:\n      local_38 = \"\\\\a\";\n      break;\n    case 8:\n      local_38 = \"\\\\b\";\n      break;\n    case 9:\n      local_38 = \"\\\\t\";\n      break;\n    case 10:\n      local_38 = \"\\\\n\";\n      break;\n    case 0xb:\n      local_38 = \"\\\\v\";\n      break;\n    case 0xc:\n      local_38 = \"\\\\f\";\n      break;\n    case 0xd:\n      local_38 = \"\\\\r\";\n    }\n    uVar3 = pad_at(param_1,local_40 + -1,param_6);\n    xprintf(&DAT_001061e1,param_5 + ((int)local_48 - (int)uVar3),local_38);\n    local_50 = local_50 + 1;\n    local_48 = uVar3;\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "print_ascii",
                        "__ctype_b_loc",
                        "sprintf",
                        "pad_at",
                        "xprintf",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "print_ascii"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "simple_strtoi",
                "func_c_signature": "undefined8 simple_strtoi(char *param_1,char **param_2,int *param_3)",
                "decompiled_code": "undefined8 simple_strtoi(char *param_1,char **param_2,int *param_3) {\n  long lVar1;\n  char cVar2;\n  int iVar3;\n  undefined8 uVar4;\n  long in_FS_OFFSET;\n  char *local_20;\n  int local_14;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  local_14 = 0;\n  local_20 = param_1;\n  do {\n    cVar2 = c_isdigit((int)*local_20);\n    if (cVar2 == '\\0') {\n      *param_2 = local_20;\n      *param_3 = local_14;\n      uVar4 = 1;\nLAB_00101b0f:\n      if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return uVar4;\n    }\n    iVar3 = (int)((long)local_14 * 10);\n    if (((long)iVar3 != (long)local_14 * 10) ||\n       (local_14 = *local_20 + -0x30 + iVar3, SCARRY4(*local_20 + -0x30,iVar3))) {\n      uVar4 = 0;\n      goto LAB_00101b0f;\n    }\n    local_20 = local_20 + 1;\n  } while( true );\n}",
                "globals": [],
                "externs": [
                    "SCARRY4"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "simple_strtoi",
                        "c_isdigit",
                        "__stack_chk_fail",
                        "SCARRY4"
                    ],
                    "calling_functions": [
                        "simple_strtoi",
                        "decode_one_format"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "ispec_to_format",
                "func_c_signature": "undefined8 ispec_to_format(int param_1,undefined8 param_2,undefined8 param_3)",
                "decompiled_code": "undefined8 ispec_to_format(int param_1,undefined8 param_2,undefined8 param_3) {\n  if (param_1 == 4) {\n    param_2 = param_3;\n  }\n  return param_2;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "ispec_to_format"
                    ],
                    "calling_functions": [
                        "ispec_to_format",
                        "decode_one_format"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "open_next_file",
                "func_c_signature": "undefined open_next_file(void)",
                "decompiled_code": "undefined open_next_file(void) {\n  char cVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  undefined local_29;\n  \n  local_29 = 1;\n  do {\n    input_filename = *file_list;\n    if (input_filename == 0) {\n      return local_29;\n    }\n    file_list = file_list + 1;\n    cVar1 = streq(input_filename,&DAT_00105344);\n    if (cVar1 == '\\0') {\n      in_stream = (FILE *)rpl_fopen(input_filename,&DAT_001063ff);\n      if (in_stream == (FILE *)0x0) {\n        uVar2 = quotearg_n_style_colon(0,3,input_filename);\n        piVar3 = __errno_location();\n        error(0,*piVar3,&DAT_00106401,uVar2);\n        local_29 = 0;\n      }\n    }\n    else {\n      input_filename = gettext(\"standard input\");\n      in_stream = _stdin;\n      have_read_stdin = 1;\n      xset_binary_mode(0,0);\n    }\n  } while (in_stream == (FILE *)0x0);\n  if ((-1 < end_offset) && (flag_dump_strings != '\\x01')) {\n    setvbuf(in_stream,(char *)0x0,2,0);\n  }\n  return local_29;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "open_next_file",
                        "streq",
                        "rpl_fopen",
                        "quotearg_n_style_colon",
                        "__errno_location",
                        "error",
                        "gettext",
                        "xset_binary_mode",
                        "setvbuf"
                    ],
                    "calling_functions": [
                        "open_next_file",
                        "skip",
                        "read_char",
                        "read_block",
                        "main"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "check_and_close",
                "func_c_signature": "bool check_and_close(int param_1)",
                "decompiled_code": "bool check_and_close(int param_1) {\n  char cVar1;\n  int iVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  int local_3c;\n  bool local_29;\n  \n  local_29 = true;\n  if (in_stream != (FILE *)0x0) {\n    iVar2 = ferror_unlocked(in_stream);\n    local_3c = param_1;\n    if (iVar2 == 0) {\n      local_3c = 0;\n    }\n    cVar1 = streq(*(undefined8 *)(file_list + -8),&DAT_00105344);\n    if (cVar1 == '\\0') {\n      iVar2 = rpl_fclose(in_stream);\n      if ((iVar2 != 0) && (local_3c == 0)) {\n        piVar3 = __errno_location();\n        local_3c = *piVar3;\n      }\n    }\n    else {\n      clearerr_unlocked(in_stream);\n    }\n    if (local_3c != 0) {\n      uVar4 = quotearg_n_style_colon(0,3,input_filename);\n      error(0,local_3c,&DAT_00106401,uVar4);\n    }\n    local_29 = local_3c == 0;\n    in_stream = (FILE *)0x0;\n  }\n  iVar2 = ferror_unlocked(_stdout);\n  if (iVar2 != 0) {\n    uVar4 = gettext(\"write error\");\n    error(0,0,uVar4);\n    local_29 = false;\n  }\n  return local_29;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "check_and_close",
                        "ferror_unlocked",
                        "streq",
                        "rpl_fclose",
                        "__errno_location",
                        "clearerr_unlocked",
                        "quotearg_n_style_colon",
                        "error",
                        "gettext"
                    ],
                    "calling_functions": [
                        "check_and_close",
                        "skip",
                        "read_char",
                        "read_block",
                        "dump",
                        "dump_strings"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "skip",
                "func_c_signature": "bool skip(size_t param_1)",
                "decompiled_code": "bool skip(size_t param_1) {\n  byte bVar1;\n  byte bVar2;\n  int iVar3;\n  int *piVar4;\n  size_t sVar5;\n  undefined8 uVar6;\n  ulong uVar7;\n  long in_FS_OFFSET;\n  size_t local_2100;\n  bool local_20ed;\n  int local_20ec;\n  size_t local_20d8;\n  stat local_20b8;\n  undefined local_2028 [8200];\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20ed = true;\n  local_20ec = 0;\n  local_2100 = param_1;\n  if (param_1 == 0) {\n    local_20ed = true;\n  }\n  else {\n    while (in_stream != (FILE *)0x0) {\n      iVar3 = fileno_unlocked(in_stream);\n      iVar3 = fstat(iVar3,&local_20b8);\n      if (iVar3 == 0) {\n        if ((local_20b8.st_mode & 0xf000) == 0x8000) {\n          if ((local_20b8.st_blksize < 1) ||\n             (uVar7 = local_20b8.st_blksize, 0x2000000000000000 < (ulong)local_20b8.st_blksize)) {\n            uVar7 = 0x200;\n          }\n          if (local_20b8.st_size <= (long)uVar7) goto LAB_00102af3;\n          if (local_20b8.st_size < (long)local_2100) {\n            local_2100 = local_2100 - local_20b8.st_size;\n          }\n          else {\n            iVar3 = rpl_fseeko(in_stream,local_2100,1);\n            if (iVar3 != 0) {\n              piVar4 = __errno_location();\n              local_20ec = *piVar4;\n              local_20ed = false;\n            }\n            local_2100 = 0;\n          }\n        }\n        else {\nLAB_00102af3:\n          if (((local_20b8.st_mode & 0xf000) == 0x8000) ||\n             (iVar3 = rpl_fseeko(in_stream,local_2100,1), iVar3 != 0)) {\n            local_20d8 = 0x2000;\n            do {\n              do {\n                if ((long)local_2100 < 1) goto LAB_00102c04;\n                if ((long)local_2100 < (long)local_20d8) {\n                  local_20d8 = local_2100;\n                }\n                sVar5 = fread_unlocked(local_2028,1,local_20d8,in_stream);\n                local_2100 = local_2100 - sVar5;\n              } while (sVar5 == local_20d8);\n              iVar3 = ferror_unlocked(in_stream);\n              if (iVar3 != 0) {\n                piVar4 = __errno_location();\n                local_20ec = *piVar4;\n                local_20ed = false;\n                local_2100 = 0;\n                break;\n              }\n              iVar3 = feof_unlocked(in_stream);\n            } while (iVar3 == 0);\n          }\n          else {\n            local_2100 = 0;\n          }\n        }\nLAB_00102c04:\n        if (local_2100 == 0) break;\n      }\n      else {\n        uVar6 = quotearg_n_style_colon(0,3,input_filename);\n        piVar4 = __errno_location();\n        error(0,*piVar4,&DAT_00106401,uVar6);\n        local_20ed = false;\n      }\n      bVar1 = check_and_close(local_20ec);\n      bVar2 = open_next_file();\n      local_20ed = (bVar2 & (bVar1 & local_20ed) != 0) != 0;\n    }\n    if (local_2100 != 0) {\n      uVar6 = gettext(\"cannot skip past end of combined input\");\n      error(1,0,uVar6);\n    }\n  }\n  if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return local_20ed;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "skip",
                        "fileno_unlocked",
                        "fstat",
                        "rpl_fseeko",
                        "__errno_location",
                        "fread_unlocked",
                        "ferror_unlocked",
                        "feof_unlocked",
                        "quotearg_n_style_colon",
                        "error",
                        "check_and_close",
                        "open_next_file",
                        "gettext",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "skip",
                        "main"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "format_address_none",
                "func_c_signature": "void format_address_none(void)",
                "decompiled_code": "void format_address_none(void) {\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "format_address_none"
                    ],
                    "calling_functions": [
                        "format_address_none"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "format_address_paren",
                "func_c_signature": "void format_address_paren(undefined8 param_1,char param_2)",
                "decompiled_code": "void format_address_paren(undefined8 param_1,char param_2) {\n  putchar_unlocked(0x28);\n  format_address_std(param_1,0x29);\n  if (param_2 != '\\0') {\n    putchar_unlocked((int)param_2);\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "format_address_paren",
                        "putchar_unlocked",
                        "format_address_std"
                    ],
                    "calling_functions": [
                        "format_address_paren",
                        "format_address_label"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "format_address_label",
                "func_c_signature": "void format_address_label(long param_1,char param_2)",
                "decompiled_code": "void format_address_label(long param_1,char param_2) {\n  long lVar1;\n  long lVar2;\n  undefined8 uVar3;\n  long in_FS_OFFSET;\n  \n  lVar1 = *(long *)(in_FS_OFFSET + 0x28);\n  format_address_std(param_1,0x20);\n  lVar2 = param_1 + pseudo_offset;\n  if (SCARRY8(param_1,pseudo_offset)) {\n    uVar3 = gettext(\"pseudo address too large for input\");\n    error(1,0,uVar3);\n  }\n  format_address_paren(lVar2,(int)param_2);\n  if (lVar1 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [
                    "SCARRY8"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "format_address_label",
                        "format_address_std",
                        "SCARRY8",
                        "gettext",
                        "error",
                        "format_address_paren",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "format_address_label"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "write_block",
                "func_c_signature": "void write_block(undefined8 param_1,long param_2,undefined8 param_3,undefined8 param_4)",
                "decompiled_code": "void write_block(undefined8 param_1,long param_2,undefined8 param_3,undefined8 param_4) {\n  int iVar1;\n  char cVar2;\n  long lVar3;\n  long lVar4;\n  undefined8 uVar5;\n  long lVar6;\n  long local_30;\n  long local_28;\n  \n  if ((((abbreviate_duplicate_blocks != '\\0') && (first_4 != '\\x01')) &&\n      (param_2 == bytes_per_block)) &&\n     (cVar2 = memeq(param_3,param_4,bytes_per_block), cVar2 != '\\0')) {\n    if (prev_pair_equal_3 != '\\0') {\n      first_4 = 0;\n      return;\n    }\n    puts(\"*\");\n    first_4 = 0;\n    prev_pair_equal_3 = 1;\n    return;\n  }\n  prev_pair_equal_3 = 0;\n  for (local_30 = 0; local_30 < n_specs; local_30 = local_30 + 1) {\n    lVar3 = bytes_per_block /\n            (long)*(int *)(width_bytes + (ulong)*(uint *)(local_30 * 0x30 + spec + 4) * 4);\n    lVar6 = (long)*(int *)(width_bytes + (ulong)*(uint *)(local_30 * 0x30 + spec + 4) * 4);\n    lVar4 = (bytes_per_block - param_2) / lVar6;\n    if (local_30 == 0) {\n      (*(code *)format_address)(param_1,0);\n    }\n    else {\n      print_n_spaces((long)address_pad_len,lVar6,(bytes_per_block - param_2) % lVar6);\n    }\n    (**(code **)(local_30 * 0x30 + spec + 8))\n              (lVar3,lVar4,param_4,local_30 * 0x30 + spec + 0x10,\n               *(undefined4 *)(local_30 * 0x30 + spec + 0x24),\n               *(undefined8 *)(local_30 * 0x30 + spec + 0x28));\n    if (*(char *)(local_30 * 0x30 + spec + 0x22) != '\\0') {\n      iVar1 = *(int *)(local_30 * 0x30 + spec + 0x24);\n      for (local_28 = 0; local_28 < lVar4; local_28 = local_28 + 1) {\n        print_n_spaces((long)iVar1);\n      }\n      uVar5 = pad_at(lVar3,lVar4,*(undefined8 *)(local_30 * 0x30 + spec + 0x28));\n      print_n_spaces(uVar5);\n      dump_hexl_mode_trailer(param_2,param_4);\n    }\n    putchar_unlocked(10);\n  }\n  first_4 = 0;\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "write_block",
                        "memeq",
                        "puts",
                        "print_n_spaces",
                        "pad_at",
                        "dump_hexl_mode_trailer",
                        "putchar_unlocked"
                    ],
                    "calling_functions": [
                        "write_block",
                        "dump"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "read_char",
                "func_c_signature": "bool read_char(int *param_1)",
                "decompiled_code": "bool read_char(int *param_1) {\n  byte bVar1;\n  byte bVar2;\n  int iVar3;\n  int *piVar4;\n  bool local_9;\n  \n  local_9 = true;\n  *param_1 = -1;\n  while( true ) {\n    if (in_stream == (FILE *)0x0) {\n      return local_9;\n    }\n    iVar3 = getc_unlocked(in_stream);\n    *param_1 = iVar3;\n    if (-1 < *param_1) break;\n    piVar4 = __errno_location();\n    bVar1 = check_and_close(*piVar4);\n    bVar2 = open_next_file();\n    local_9 = (bVar2 & (bVar1 & local_9) != 0) != 0;\n  }\n  return local_9;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "read_char",
                        "getc_unlocked",
                        "__errno_location",
                        "check_and_close",
                        "open_next_file"
                    ],
                    "calling_functions": [
                        "read_char",
                        "dump_strings"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "read_block",
                "func_c_signature": "bool read_block(long param_1,long param_2,long *param_3)",
                "decompiled_code": "bool read_block(long param_1,long param_2,long *param_3) {\n  long lVar1;\n  byte bVar2;\n  byte bVar3;\n  size_t sVar4;\n  int *piVar5;\n  bool local_19;\n  \n  local_19 = true;\n  if ((0 < param_1) && (param_1 <= bytes_per_block)) {\n    *param_3 = 0;\n    while( true ) {\n      if (in_stream == (FILE *)0x0) {\n        return local_19;\n      }\n      lVar1 = *param_3;\n      sVar4 = fread_unlocked((void *)(*param_3 + param_2),1,param_1 - lVar1,in_stream);\n      *param_3 = *param_3 + sVar4;\n      if (sVar4 == param_1 - lVar1) break;\n      piVar5 = __errno_location();\n      bVar2 = check_and_close(*piVar5);\n      bVar3 = open_next_file();\n      local_19 = (bVar3 & (bVar2 & local_19) != 0) != 0;\n    }\n    return local_19;\n  }\n                    /* WARNING: Subroutine does not return */\n  __assert_fail(\"0 < n && n <= bytes_per_block\",\n                \"/workspace/home/aiclub1/B220032CS_Jaefar/fyp/repos/ansaf/coreutils/src/od.c\",0x559,\n                \"read_block\");\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "read_block",
                        "fread_unlocked",
                        "__errno_location",
                        "check_and_close",
                        "open_next_file",
                        "__assert_fail"
                    ],
                    "calling_functions": [
                        "read_block",
                        "dump"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "get_lcm",
                "func_c_signature": "int get_lcm(void)",
                "decompiled_code": "int get_lcm(void) {\n  int local_14;\n  long local_10;\n  \n  local_14 = 1;\n  for (local_10 = 0; local_10 < n_specs; local_10 = local_10 + 1) {\n    local_14 = lcm((long)local_14,\n                   (long)*(int *)(width_bytes + (ulong)*(uint *)(local_10 * 0x30 + spec + 4) * 4));\n  }\n  return local_14;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "get_lcm",
                        "lcm"
                    ],
                    "calling_functions": [
                        "get_lcm",
                        "dump",
                        "main"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "xstr2nonneg",
                "func_c_signature": "int xstr2nonneg(undefined8 param_1,undefined4 param_2,long *param_3,undefined8 param_4)",
                "decompiled_code": "int xstr2nonneg(undefined8 param_1,undefined4 param_2,long *param_3,undefined8 param_4) {\n  int iVar1;\n  \n  iVar1 = xstrtoimax(param_1,0,param_2,param_3,param_4);\n  if ((iVar1 != 4) && (*param_3 < 0)) {\n    iVar1 = 4;\n  }\n  return iVar1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "xstr2nonneg",
                        "xstrtoimax"
                    ],
                    "calling_functions": [
                        "xstr2nonneg",
                        "parse_old_offset",
                        "main"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "parse_old_offset",
                "func_c_signature": "bool parse_old_offset(char *param_1,undefined8 param_2)",
                "decompiled_code": "bool parse_old_offset(char *param_1,undefined8 param_2) {\n  char cVar1;\n  undefined4 uVar2;\n  int iVar3;\n  char *__s;\n  undefined8 uVar4;\n  bool bVar5;\n  char *local_20;\n  \n  __s = param_1 + (*param_1 == '+');\n  cVar1 = c_isdigit((int)*__s);\n  if (cVar1 == '\\x01') {\n    local_20 = strchr(__s,0x2e);\n    if (local_20 != (char *)0x0) {\n      if ((local_20[1] == 'b') || (local_20[1] == 'B')) {\n        iVar3 = 1;\n      }\n      else {\n        iVar3 = 0;\n      }\n      if (local_20[(long)iVar3 + 1] != '\\0') {\n        local_20 = (char *)0x0;\n      }\n    }\n    if (local_20 == (char *)0x0) {\n      if ((*__s == '0') && ((__s[1] == 'x' || (__s[1] == 'X')))) {\n        uVar2 = 0x10;\n      }\n      else {\n        uVar2 = 8;\n      }\n    }\n    else {\n      uVar2 = 10;\n    }\n    if (local_20 != (char *)0x0) {\n      *local_20 = local_20[1];\n      local_20[1] = '\\0';\n    }\n    iVar3 = xstr2nonneg(__s,uVar2,param_2,&DAT_0010649b);\n    if (local_20 != (char *)0x0) {\n      local_20[1] = *local_20;\n      *local_20 = '.';\n    }\n    if (iVar3 == 1) {\n      uVar4 = quotearg_n_style_colon(0,3,param_1);\n      error(1,0x22,&DAT_00106401,uVar4);\n    }\n    bVar5 = iVar3 == 0;\n  }\n  else {\n    bVar5 = false;\n  }\n  return bVar5;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "parse_old_offset",
                        "c_isdigit",
                        "strchr",
                        "xstr2nonneg",
                        "quotearg_n_style_colon",
                        "error"
                    ],
                    "calling_functions": [
                        "parse_old_offset",
                        "main"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "dump",
                "func_c_signature": "bool dump(void)",
                "decompiled_code": "bool dump(void) {\n  byte bVar1;\n  int iVar2;\n  long in_FS_OFFSET;\n  bool local_56;\n  bool local_55;\n  long local_50;\n  long local_48;\n  long local_40;\n  long local_38;\n  long local_30;\n  void *local_28;\n  long local_20;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_56 = false;\n  local_55 = true;\n  local_28 = (void *)xinmalloc(2,bytes_per_block);\n  local_20 = (long)local_28 + bytes_per_block;\n  local_48 = n_bytes_to_skip;\n  do {\n    if (end_offset < 0) {\n      local_40 = 0x7fffffffffffffff;\n    }\n    else {\n      local_40 = end_offset - local_48;\n    }\n    if (local_40 < 1) {\n      local_50 = 0;\n      break;\n    }\n    local_38 = bytes_per_block;\n    if (local_40 <= bytes_per_block) {\n      local_38 = local_40;\n    }\n    bVar1 = read_block(local_38,(&local_28)[(int)(uint)local_56],&local_50);\n    local_55 = (bVar1 & local_55) != 0;\n    if (local_50 < bytes_per_block) break;\n    if (local_50 != bytes_per_block) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"n_bytes_read == bytes_per_block\",\n                    \"/workspace/home/aiclub1/B220032CS_Jaefar/fyp/repos/ansaf/coreutils/src/od.c\",\n                    0x5dc,(char *)&__PRETTY_FUNCTION___1);\n    }\n    write_block(local_48,local_50,(&local_28)[(int)(uint)(local_56 ^ 1)],\n                (&local_28)[(int)(uint)local_56]);\n    iVar2 = ferror_unlocked(_stdout);\n    local_55 = iVar2 == 0 && local_55;\n    local_48 = local_48 + local_50;\n    local_56 = local_56 == false;\n  } while (local_55);\n  if (0 < local_50) {\n    iVar2 = get_lcm();\n    local_30 = (local_50 + iVar2 + -1) - (local_50 + iVar2 + -1) % (long)iVar2;\n    memset((void *)((long)(&local_28)[(int)(uint)local_56] + local_50),0,local_30 - local_50);\n    write_block(local_48,local_50,(&local_28)[(int)(uint)(local_56 ^ 1)],\n                (&local_28)[(int)(uint)local_56]);\n    local_48 = local_48 + local_50;\n  }\n  (*(code *)format_address)(local_48,10);\n  if ((-1 < end_offset) && (end_offset <= local_48)) {\n    bVar1 = check_and_close(0);\n    local_55 = (bVar1 & local_55) != 0;\n  }\n  free(local_28);\n  if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_55;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "dump",
                        "xinmalloc",
                        "read_block",
                        "__assert_fail",
                        "write_block",
                        "ferror_unlocked",
                        "get_lcm",
                        "memset",
                        "check_and_close",
                        "free",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "dump",
                        "main"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "dump_strings",
                "func_c_signature": "bool dump_strings(void)",
                "decompiled_code": "bool dump_strings(void) {\n  long lVar1;\n  byte bVar2;\n  ushort **ppuVar3;\n  long in_FS_OFFSET;\n  bool local_35;\n  int local_34;\n  long local_30;\n  void *local_28;\n  long local_20;\n  long local_18;\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_30 = string_min;\n  if (string_min < 99) {\n    local_30 = 99;\n  }\n  local_30 = local_30 + 1;\n  local_28 = (void *)ximalloc(local_30);\n  local_20 = n_bytes_to_skip;\n  local_35 = true;\n  do {\n    local_18 = 0;\n    local_34 = 1;\n    if ((-1 < end_offset) && ((end_offset < string_min || (end_offset - string_min < local_20)))) {\n      free(local_28);\n      bVar2 = check_and_close(0);\n      local_35 = (bVar2 & local_35) != 0;\nLAB_00103d40:\n      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return local_35;\n    }\n    do {\n      if ((-1 < end_offset) && (end_offset <= local_20)) goto LAB_00103b24;\n      if (local_18 == local_30 + -1) {\n        local_28 = (void *)xpalloc(local_28,&local_30,1,0xffffffffffffffff,1);\n      }\n      bVar2 = read_char(&local_34);\n      local_35 = (bVar2 & local_35) != 0;\n      if (local_34 < 0) {\n        free(local_28);\n        goto LAB_00103d40;\n      }\n      local_20 = local_20 + 1;\n      lVar1 = local_18 + 1;\n      *(char *)((long)local_28 + local_18) = (char)local_34;\n      local_18 = lVar1;\n      if (local_34 == 0) goto LAB_00103b24;\n      ppuVar3 = __ctype_b_loc();\n    } while (((*ppuVar3)[local_34] & 0x4000) != 0);\n    local_34 = -1;\nLAB_00103b24:\n    if ((-1 < local_34) && (string_min <= (long)(local_18 - (ulong)(local_34 == 0)))) {\n      *(undefined *)((long)local_28 + local_18) = 0;\n      (*(code *)format_address)(local_20 - local_18,0x20);\n      for (local_18 = 0; local_34 = (int)*(char *)((long)local_28 + local_18), local_34 != 0;\n          local_18 = local_18 + 1) {\n        switch(local_34) {\n        case 7:\n          fwrite_unlocked(&DAT_001061f0,1,2,_stdout);\n          break;\n        case 8:\n          fwrite_unlocked(&DAT_001061f3,1,2,_stdout);\n          break;\n        case 9:\n          fwrite_unlocked(&DAT_001061ff,1,2,_stdout);\n          break;\n        case 10:\n          fwrite_unlocked(&DAT_001061f9,1,2,_stdout);\n          break;\n        case 0xb:\n          fwrite_unlocked(&DAT_00106202,1,2,_stdout);\n          break;\n        case 0xc:\n          fwrite_unlocked(&DAT_001061f6,1,2,_stdout);\n          break;\n        case 0xd:\n          fwrite_unlocked(&DAT_001061fc,1,2,_stdout);\n          break;\n        default:\n          putc_unlocked(local_34,_stdout);\n        }\n      }\n      putchar_unlocked(10);\n    }\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "dump_strings",
                        "ximalloc",
                        "free",
                        "check_and_close",
                        "__stack_chk_fail",
                        "xpalloc",
                        "read_char",
                        "__ctype_b_loc",
                        "fwrite_unlocked",
                        "putc_unlocked",
                        "putchar_unlocked"
                    ],
                    "calling_functions": [
                        "dump_strings",
                        "main"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "byte main(int param_1,undefined8 *param_2)",
                "decompiled_code": "byte main(int param_1,undefined8 *param_2) {\n  bool bVar1;\n  byte bVar2;\n  char cVar3;\n  int iVar4;\n  long lVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  long in_FS_OFFSET;\n  undefined8 *local_128;\n  byte local_115;\n  undefined4 local_114;\n  int local_110;\n  int local_10c;\n  int local_108;\n  int local_104;\n  undefined4 local_100;\n  undefined4 local_fc;\n  undefined4 local_f8;\n  undefined4 local_f4;\n  undefined4 local_f0;\n  undefined4 local_ec;\n  undefined4 local_e8;\n  undefined4 local_e4;\n  undefined4 local_e0;\n  undefined4 local_dc;\n  undefined4 local_d8;\n  undefined4 local_d4;\n  undefined4 local_d0;\n  undefined4 local_cc;\n  undefined4 local_c8;\n  int local_c4;\n  long local_c0;\n  long local_b8;\n  long local_b0;\n  long local_a8;\n  long local_a0;\n  long local_98;\n  long local_90;\n  long local_88;\n  long local_80;\n  long local_78;\n  long local_70;\n  long local_68;\n  undefined8 local_60;\n  undefined8 local_58;\n  undefined *local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_c0 = 0;\n  bVar1 = false;\n  local_115 = true;\n  local_a0 = 0;\n  local_b8 = -1;\n  local_98 = 0;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit((__func *)&close_stdout);\nLAB_00103e19:\n  do {\n    while( true ) {\n      local_114 = 0xffffffff;\n      local_108 = getopt_long(param_1,param_2,\"A:aBbcDdeFfHhIij:LlN:OoS:st:vw::Xx\",long_options,\n                              &local_114);\n      if (local_108 == -1) {\n        if ((bool)local_115 == true) {\n          if ((flag_dump_strings != '\\0') && (0 < n_specs)) {\n            local_58 = gettext(\"no type may be specified when dumping strings\");\n            local_f8 = 1;\n            local_f4 = 0;\n            error(1,0,local_58);\n          }\n          local_110 = param_1 - _optind;\n          local_128 = param_2;\n          if ((!bVar1) || (traditional != '\\0')) {\n            if (local_110 == 3) {\n              if (((traditional != '\\0') &&\n                  (cVar3 = parse_old_offset(param_2[(long)_optind + 1],&local_b0), cVar3 != '\\0'))\n                 && (cVar3 = parse_old_offset(param_2[(long)_optind + 2],&local_a8), cVar3 != '\\0'))\n              {\n                n_bytes_to_skip = local_b0;\n                flag_pseudo_start = '\\x01';\n                local_98 = local_a8;\n                param_2[(long)_optind + 2] = param_2[_optind];\n                local_128 = param_2 + 2;\n                local_110 = local_110 + -2;\n              }\n            }\n            else if (local_110 < 4) {\n              if (local_110 == 1) {\n                if (((traditional != '\\0') || (*(char *)param_2[_optind] == '+')) &&\n                   (cVar3 = parse_old_offset(param_2[_optind],&local_b0), cVar3 != '\\0')) {\n                  n_bytes_to_skip = local_b0;\n                  local_110 = local_110 + -1;\n                  local_128 = param_2 + 1;\n                }\n              }\n              else if ((local_110 == 2) &&\n                      ((((traditional != '\\0' || (*(char *)param_2[(long)_optind + 1] == '+')) ||\n                        (cVar3 = c_isdigit((int)*(char *)param_2[(long)_optind + 1]), cVar3 != '\\0')\n                        ) && (cVar3 = parse_old_offset(param_2[(long)_optind + 1],&local_a8),\n                             cVar3 != '\\0')))) {\n                if ((traditional == '\\0') ||\n                   (cVar3 = parse_old_offset(param_2[_optind],&local_b0), cVar3 == '\\0')) {\n                  n_bytes_to_skip = local_a8;\n                  local_110 = local_110 + -1;\n                  param_2[(long)_optind + 1] = param_2[_optind];\n                  local_128 = param_2 + 1;\n                }\n                else {\n                  n_bytes_to_skip = local_b0;\n                  flag_pseudo_start = '\\x01';\n                  local_98 = local_a8;\n                  local_128 = param_2 + 2;\n                  local_110 = local_110 + -2;\n                }\n              }\n            }\n            if ((traditional != '\\0') && (1 < local_110)) {\n              uVar6 = quote(local_128[(long)_optind + 1]);\n              local_48 = gettext(\"extra operand %s\");\n              local_e8 = 0;\n              local_e4 = 0;\n              error(0,0,local_48,uVar6);\n              uVar6 = gettext(\"compatibility mode supports at most one file\");\n              local_f0 = 0;\n              local_ec = 0;\n              local_50 = &DAT_00106401;\n              error(0,0,&DAT_00106401,uVar6);\n              usage(1);\n            }\n          }\n          if (flag_pseudo_start != '\\0') {\n            if ((code *)format_address == format_address_none) {\n              address_base = 8;\n              address_pad_len = 7;\n              format_address = format_address_paren;\n            }\n            else {\n              format_address = format_address_label;\n            }\n          }\n          if ((-1 < local_b8) &&\n             (end_offset = local_b8 + n_bytes_to_skip, SCARRY8(local_b8,n_bytes_to_skip))) {\n            local_40 = gettext(\"skip-bytes + read-bytes is too large\");\n            local_e0 = 1;\n            local_dc = 0;\n            error(1,0,local_40);\n          }\n          if (n_specs == 0) {\n            decode_format_string(&DAT_00106625);\n          }\n          if (local_110 < 1) {\n            file_list = default_file_list;\n          }\n          else {\n            file_list = (undefined1 *)(local_128 + _optind);\n          }\n          local_115 = open_next_file();\n          if (in_stream != 0) {\n            bVar2 = skip(n_bytes_to_skip);\n            local_115 = (bVar2 & local_115) != 0;\n            if (in_stream != 0) {\n              if (flag_pseudo_start == '\\0') {\n                pseudo_offset = 0;\n              }\n              else {\n                pseudo_offset = local_98 - n_bytes_to_skip;\n              }\n              local_104 = get_lcm();\n              lVar5 = local_c0;\n              if (local_c0 == 0) {\n                if (local_104 < 0x10) {\n                  bytes_per_block = (long)(0x10 - (int)(0x10 % (long)local_104));\n                }\n                else {\n                  bytes_per_block = (long)local_104;\n                }\n              }\n              else if (local_c0 % (long)local_104 == 0) {\n                bytes_per_block = local_c0;\n              }\n              else {\n                local_38 = gettext(\"warning: invalid width %td; using %d instead\");\n                local_d8 = 0;\n                local_d4 = 0;\n                error(0,0,local_38,lVar5,local_104);\n                bytes_per_block = (long)local_104;\n              }\n              for (local_90 = 0; local_90 < n_specs; local_90 = local_90 + 1) {\n                local_70 = bytes_per_block /\n                           (long)*(int *)(width_bytes +\n                                         (ulong)*(uint *)(local_90 * 0x30 + spec + 4) * 4);\n                cVar3 = pad_at_overflow(local_70,spec,\n                                        bytes_per_block %\n                                        (long)*(int *)(width_bytes +\n                                                      (ulong)*(uint *)(local_90 * 0x30 + spec + 4) *\n                                                      4));\n                lVar5 = local_c0;\n                if (cVar3 != '\\0') {\n                  local_30 = gettext(\"%td is too large\");\n                  local_d0 = 1;\n                  local_cc = 0;\n                  error(1,0,local_30,lVar5);\n                }\n                local_68 = (*(int *)(local_90 * 0x30 + spec + 0x24) + 1) * local_70;\n                if (local_a0 < local_68) {\n                  local_a0 = local_68;\n                }\n              }\n              for (local_88 = 0; local_88 < n_specs; local_88 = local_88 + 1) {\n                local_80 = bytes_per_block /\n                           (long)*(int *)(width_bytes +\n                                         (ulong)*(uint *)(local_88 * 0x30 + spec + 4) * 4);\n                local_78 = *(int *)(local_88 * 0x30 + spec + 0x24) * local_80;\n                *(long *)(spec + local_88 * 0x30 + 0x28) = local_a0 - local_78;\n              }\n              if (flag_dump_strings == '\\0') {\n                bVar2 = dump();\n              }\n              else {\n                bVar2 = dump_strings();\n              }\n              local_115 = (bVar2 & local_115) != 0;\n            }\n          }\n          if ((have_read_stdin != '\\0') && (iVar4 = rpl_fclose(_stdin), iVar4 < 0)) {\n            uVar6 = gettext(\"standard input\");\n            piVar7 = __errno_location();\n            local_c4 = *piVar7;\n            local_c8 = 1;\n            local_28 = uVar6;\n            error(1,local_c4,uVar6);\n          }\n          local_115 = local_115 ^ 1;\n        }\n        else {\n          local_115 = 1;\n        }\n        if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n          __stack_chk_fail();\n        }\n        return local_115;\n      }\n      if (local_108 < 0x82) break;\nswitchD_00103ee8_caseD_43:\n      usage(1);\n    }\n    if (local_108 < 0x41) {\n      if (local_108 != -0x83) {\n        if (local_108 != -0x82) goto switchD_00103ee8_caseD_43;\n        goto LAB_001045a6;\n      }\n      goto LAB_001045b0;\n    }\n    switch(local_108) {\n    case 0x41:\n      bVar1 = true;\n      cVar3 = *_optarg;\n      if (cVar3 == 'x') {\n        format_address = format_address_std;\n        address_base = 0x10;\n        address_pad_len = 6;\n        break;\n      }\n      if (cVar3 < 'y') {\n        if (cVar3 == 'o') {\n          format_address = format_address_std;\n          address_base = 8;\n          address_pad_len = 7;\n          break;\n        }\n        if (cVar3 < 'p') {\n          if (cVar3 == 'd') {\n            format_address = format_address_std;\n            address_base = 10;\n            address_pad_len = 7;\n            break;\n          }\n          if (cVar3 == 'n') {\n            format_address = format_address_none;\n            address_pad_len = 0;\n            break;\n          }\n        }\n      }\n      cVar3 = *_optarg;\n      local_60 = gettext(\"invalid output address radix \\'%c\\'; it must be one character from [doxn]\"\n                        );\n      local_100 = 1;\n      local_fc = 0;\n      error(1,0,local_60,(int)cVar3);\n      break;\n    case 0x42:\n    case 0x6f:\n      bVar2 = decode_format_string(&DAT_00106568);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    default:\n      goto switchD_00103ee8_caseD_43;\n    case 0x44:\n      bVar2 = decode_format_string(&DAT_00106550);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 0x46:\n    case 0x65:\n      bVar2 = decode_format_string(&DAT_00106556);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 0x48:\n    case 0x58:\n      bVar2 = decode_format_string(&DAT_0010655c);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 0x49:\n    case 0x4c:\n    case 0x6c:\n      bVar2 = decode_format_string(&DAT_00106562);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 0x4f:\n      bVar2 = decode_format_string(&DAT_00106565);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 0x53:\n      goto switchD_00103ee8_caseD_53;\n    case 0x61:\n      bVar2 = decode_format_string(&DAT_00106549);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 0x62:\n      bVar2 = decode_format_string(&DAT_0010654b);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 99:\n      bVar2 = decode_format_string(&DAT_0010654e);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 100:\n      bVar2 = decode_format_string(&DAT_00106553);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 0x66:\n      bVar2 = decode_format_string(&DAT_00106559);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 0x68:\n    case 0x78:\n      bVar2 = decode_format_string(&DAT_0010656e);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 0x69:\n      bVar2 = decode_format_string(&DAT_0010655f);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 0x6a:\n      bVar1 = true;\n      local_10c = xstr2nonneg(_optarg,0,&n_bytes_to_skip,multipliers_0);\n      if (local_10c == 0) break;\n      xstrtol_fatal(local_10c,local_114,(int)(char)local_108,long_options,_optarg);\n    case 0x4e:\n      bVar1 = true;\n      local_10c = xstr2nonneg(_optarg,0,&local_b8,multipliers_0);\n      if (local_10c != 0) {\n        xstrtol_fatal(local_10c,local_114,(int)(char)local_108,long_options,_optarg);\nswitchD_00103ee8_caseD_53:\n        bVar1 = true;\n        if (_optarg == (char *)0x0) {\n          string_min = 3;\n        }\n        else {\n          local_10c = xstr2nonneg(_optarg,0,&local_b0,multipliers_0);\n          if ((local_10c == 0) && (local_a8 = local_b0 + 1, SCARRY8(local_b0,1))) {\n            local_10c = 1;\n          }\n          if (local_10c != 0) {\n            xstrtol_fatal(local_10c,local_114,(int)(char)local_108,long_options,_optarg);\n          }\n          string_min = local_b0;\n        }\n        flag_dump_strings = '\\x01';\n      }\n      break;\n    case 0x73:\n      bVar2 = decode_format_string(&DAT_0010656b);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 0x74:\n      bVar1 = true;\n      bVar2 = decode_format_string(_optarg);\n      local_115 = (bVar2 & local_115) != 0;\n      break;\n    case 0x76:\n      bVar1 = true;\n      abbreviate_duplicate_blocks = 0;\n      break;\n    case 0x77:\n      bVar1 = true;\n      if (_optarg != (char *)0x0) goto LAB_001044ff;\n      local_c0 = 0x20;\n      break;\n    case 0x80:\n      traditional = '\\x01';\n      break;\n    case 0x81:\n      lVar5 = __xargmatch_internal(\"--endian\",_optarg,endian_args,&endian_types,4,_argmatch_die,1);\n      iVar4 = *(int *)((long)&endian_types + lVar5 * 4);\n      if (iVar4 == 0) {\n        input_swap = 0;\n      }\n      else if (iVar4 == 1) {\n        input_swap = 1;\n      }\n    }\n  } while( true );\nLAB_001044ff:\n  local_10c = xstr2nonneg(_optarg,10,&local_a8,&DAT_0010522c);\n  if ((local_10c == 0) && (local_c0 = local_a8, local_a8 == 0)) {\n    local_10c = 4;\n  }\n  if (local_10c != 0) {\n    xstrtol_fatal(local_10c,local_114,(int)(char)local_108,long_options,_optarg);\nLAB_001045a6:\n    usage(0);\nLAB_001045b0:\n    uVar6 = proper_name_lite(\"Jim Meyering\",\"Jim Meyering\");\n    version_etc(_stdout,&DAT_001061de,\"GNU coreutils\",_Version,uVar6,0);\n                    /* WARNING: Subroutine does not return */\n    exit(0);\n  }\n  goto LAB_00103e19;\n}",
                "globals": [],
                "externs": [
                    "SCARRY8"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "getopt_long",
                        "gettext",
                        "error",
                        "parse_old_offset",
                        "c_isdigit",
                        "quote",
                        "usage",
                        "SCARRY8",
                        "decode_format_string",
                        "open_next_file",
                        "skip",
                        "get_lcm",
                        "pad_at_overflow",
                        "dump",
                        "dump_strings",
                        "rpl_fclose",
                        "__errno_location",
                        "__stack_chk_fail",
                        "xstr2nonneg",
                        "xstrtol_fatal",
                        "__xargmatch_internal",
                        "proper_name_lite",
                        "version_etc",
                        "exit"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "od_decompiled.c"
                }
            }
        ]
    }
}