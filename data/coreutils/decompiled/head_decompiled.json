{
    "file": "head",
    "decompiled_code": {
        "head.c": [
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\"Usage: %s [OPTION]... [FILE]...\\n\");\n    printf(pcVar3,uVar2);\n    pcVar3 = (char *)gettext(\n                            \"Print the first %d lines of each FILE to standard output.\\nWith more than one FILE, precede each with a header giving the file name.\\n\"\n                            );\n    printf(pcVar3,10);\n    emit_stdin_note();\n    emit_mandatory_arg_note();\n    pcVar3 = (char *)gettext(\n                            \"  -c, --bytes=[-]NUM       print the first NUM bytes of each file;\\n                             with the leading \\'-\\', print all but the last\\n                             NUM bytes of each file\\n  -n, --lines=[-]NUM       print the first NUM lines instead of the first %d;\\n                             with the leading \\'-\\', print all but the last\\n                             NUM lines of each file\\n\"\n                            );\n    printf(pcVar3,10);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -q, --quiet, --silent    never print headers giving file names\\n  -v, --verbose            always print headers giving file names\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"  -z, --zero-terminated    line delimiter is NUL, not newline\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"\\nNUM may have a multiplier suffix:\\nb 512, kB 1000, K 1024, MB 1000*1000, M 1024*1024,\\nGB 1000*1000*1000, G 1024*1024*1024, and so on for T, P, E, Z, Y, R, Q.\\nBinary prefixes can be used, too: KiB=K, MiB=M, and so on.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_ancillary_info(&DAT_00102bd2);\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "emit_stdin_note",
                        "emit_mandatory_arg_note",
                        "fputs_unlocked",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "diagnose_read_failure",
                "func_c_signature": "void diagnose_read_failure(undefined8 param_1)",
                "decompiled_code": "void diagnose_read_failure(undefined8 param_1) {\n  undefined8 uVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  \n  uVar1 = quotearg_style(4,param_1);\n  uVar2 = gettext(\"error reading %s\");\n  piVar3 = __errno_location();\n  error(0,*piVar3,uVar2,uVar1);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "diagnose_read_failure",
                        "quotearg_style",
                        "gettext",
                        "__errno_location",
                        "error"
                    ],
                    "calling_functions": [
                        "diagnose_read_failure",
                        "diagnose_copy_fd_failure",
                        "elide_tail_bytes_pipe",
                        "elide_tail_lines_pipe",
                        "elide_tail_lines_seekable",
                        "head_bytes",
                        "head_lines"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "diagnose_copy_fd_failure",
                "func_c_signature": "void diagnose_copy_fd_failure(int param_1,undefined8 param_2)",
                "decompiled_code": "void diagnose_copy_fd_failure(int param_1,undefined8 param_2) {\n  undefined8 uVar1;\n  undefined8 uVar2;\n  int *piVar3;\n  \n  if (param_1 == 1) {\n    diagnose_read_failure(param_2);\n  }\n  else {\n    if (param_1 != 2) {\n                    /* WARNING: Subroutine does not return */\n      __assert_fail(\"0\",\n                    \"/workspace/home/aiclub1/B220032CS_Jaefar/fyp/repos/ansaf/coreutils/src/head.c\",\n                    0xa7,\"diagnose_copy_fd_failure\");\n    }\n    uVar1 = quotearg_n_style_colon(0,3,param_2);\n    uVar2 = gettext(\"%s: file has shrunk too much\");\n    piVar3 = __errno_location();\n    error(0,*piVar3,uVar2,uVar1);\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "diagnose_copy_fd_failure",
                        "diagnose_read_failure",
                        "__assert_fail",
                        "quotearg_n_style_colon",
                        "gettext",
                        "__errno_location",
                        "error"
                    ],
                    "calling_functions": [
                        "diagnose_copy_fd_failure",
                        "elide_tail_bytes_file",
                        "elide_tail_lines_seekable"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "write_header",
                "func_c_signature": "void write_header(undefined8 param_1)",
                "decompiled_code": "void write_header(undefined8 param_1) {\n  undefined *puVar1;\n  \n  if (first_file_1 == '\\0') {\n    puVar1 = &DAT_00102c58;\n  }\n  else {\n    puVar1 = &DAT_001026cc;\n  }\n  printf(\"%s==> %s <==\\n\",puVar1,param_1);\n  first_file_1 = 0;\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "write_header",
                        "printf"
                    ],
                    "calling_functions": [
                        "write_header",
                        "head"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "xwrite_stdout",
                "func_c_signature": "void xwrite_stdout(void *param_1,ulong param_2)",
                "decompiled_code": "void xwrite_stdout(void *param_1,ulong param_2) {\n  size_t sVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  \n  if (param_2 != 0) {\n    sVar1 = fwrite_unlocked(param_1,1,param_2,_stdout);\n    if (sVar1 < param_2) {\n      clearerr_unlocked(_stdout);\n      fpurge(_stdout);\n      uVar2 = quotearg_style(4,\"standard output\");\n      uVar3 = gettext(\"error writing %s\");\n      piVar4 = __errno_location();\n      error(1,*piVar4,uVar3,uVar2);\n    }\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "xwrite_stdout",
                        "fwrite_unlocked",
                        "clearerr_unlocked",
                        "fpurge",
                        "quotearg_style",
                        "gettext",
                        "__errno_location",
                        "error"
                    ],
                    "calling_functions": [
                        "xwrite_stdout",
                        "copy_fd",
                        "elide_tail_bytes_pipe",
                        "elide_tail_lines_pipe",
                        "elide_tail_lines_seekable",
                        "head_lines"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "copy_fd",
                "func_c_signature": "undefined8 copy_fd(int param_1,ulong param_2)",
                "decompiled_code": "undefined8 copy_fd(int param_1,ulong param_2) {\n  ulong __nbytes;\n  ssize_t sVar1;\n  undefined8 uVar2;\n  long in_FS_OFFSET;\n  ulong local_2038;\n  undefined local_2018 [8200];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_2038 = param_2;\n  do {\n    if (local_2038 == 0) {\n      uVar2 = 0;\nLAB_0010077f:\n      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n        __stack_chk_fail();\n      }\n      return uVar2;\n    }\n    __nbytes = local_2038;\n    if (0x2000 < local_2038) {\n      __nbytes = 0x2000;\n    }\n    sVar1 = read(param_1,local_2018,__nbytes);\n    if (sVar1 < 0) {\n      uVar2 = 1;\n      goto LAB_0010077f;\n    }\n    local_2038 = local_2038 - sVar1;\n    if ((sVar1 == 0) && (local_2038 != 0)) {\n      uVar2 = 2;\n      goto LAB_0010077f;\n    }\n    xwrite_stdout(local_2018,sVar1);\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "copy_fd",
                        "__stack_chk_fail",
                        "read",
                        "xwrite_stdout"
                    ],
                    "calling_functions": [
                        "copy_fd",
                        "elide_tail_bytes_file",
                        "elide_tail_lines_seekable",
                        "head_bytes"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "elseek_diagnostic",
                "func_c_signature": "void elseek_diagnostic(undefined8 param_1,int param_2,undefined8 param_3)",
                "decompiled_code": "void elseek_diagnostic(undefined8 param_1,int param_2,undefined8 param_3) {\n  undefined8 uVar1;\n  char *pcVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  \n  uVar1 = quotearg_n_style_colon(0,3,param_3);\n  if (param_2 == 0) {\n    pcVar2 = \"%s: cannot seek to offset %jd\";\n  }\n  else {\n    pcVar2 = \"%s: cannot seek to relative offset %jd\";\n  }\n  uVar3 = gettext(pcVar2);\n  piVar4 = __errno_location();\n  error(0,*piVar4,uVar3,uVar1,param_1);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "elseek_diagnostic",
                        "quotearg_n_style_colon",
                        "gettext",
                        "__errno_location",
                        "error"
                    ],
                    "calling_functions": [
                        "elseek_diagnostic",
                        "elseek",
                        "head_lines"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "elseek",
                "func_c_signature": "__off_t elseek(int param_1,__off_t param_2,int param_3,undefined8 param_4)",
                "decompiled_code": "__off_t elseek(int param_1,__off_t param_2,int param_3,undefined8 param_4) {\n  __off_t _Var1;\n  \n  _Var1 = lseek(param_1,param_2,param_3);\n  if (_Var1 < 0) {\n    elseek_diagnostic(param_2,param_3,param_4);\n  }\n  return _Var1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "elseek",
                        "lseek",
                        "elseek_diagnostic"
                    ],
                    "calling_functions": [
                        "elseek",
                        "elide_tail_bytes_pipe",
                        "elide_tail_lines_pipe",
                        "elide_tail_lines_seekable",
                        "head"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "elide_tail_bytes_pipe",
                "func_c_signature": "undefined elide_tail_bytes_pipe(undefined8 param_1,undefined4 param_2,ulong param_3,long param_4)",
                "decompiled_code": "undefined elide_tail_bytes_pipe(undefined8 param_1,undefined4 param_2,ulong param_3,long param_4) {\n  undefined8 *puVar1;\n  bool bVar2;\n  bool bVar3;\n  int *piVar4;\n  ulong uVar5;\n  undefined8 uVar6;\n  long lVar7;\n  long in_FS_OFFSET;\n  undefined local_c6;\n  bool local_c3;\n  ulong local_c0;\n  long local_b8;\n  long local_b0;\n  long local_a8;\n  void *local_a0;\n  long local_98;\n  ulong local_90;\n  ulong local_88;\n  ulong local_80;\n  ulong local_78;\n  long local_70;\n  long local_68;\n  long local_60;\n  long local_58;\n  ulong local_50;\n  long local_48;\n  long local_40;\n  void *local_38;\n  long local_30;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_c6 = 1;\n  local_b8 = param_4;\n  if (param_3 < 0x100001) {\n    bVar2 = true;\n    bVar3 = false;\n    local_48 = param_3 + 0x2000;\n    local_50 = param_3;\n    local_38 = (void *)xnmalloc(2,local_48);\n    local_30 = local_48 + (long)local_38;\n    local_c3 = false;\n    while (!bVar3) {\n      local_40 = full_read(param_2,(&local_38)[(int)(uint)local_c3],local_48);\n      local_b0 = 0;\n      if (local_40 < local_48) {\n        piVar4 = __errno_location();\n        if (*piVar4 != 0) {\n          diagnose_read_failure(param_1);\n          local_c6 = 0;\n          break;\n        }\n        if ((local_40 <= (long)local_50) && (!bVar2)) {\n          local_b0 = local_50 - local_40;\n        }\n        bVar3 = true;\n      }\n      if (!bVar2) {\n        local_b8 = local_b8 + (local_50 - local_b0);\n        xwrite_stdout((long)(&local_38)[(int)(uint)(local_c3 ^ 1)] + 0x2000,local_50 - local_b0);\n      }\n      bVar2 = false;\n      if ((long)local_50 < local_40) {\n        local_b8 = local_b8 + (local_40 - local_50);\n        xwrite_stdout((&local_38)[(int)(uint)local_c3],local_40 - local_50);\n      }\n      local_c3 = local_c3 == false;\n    }\n    free(local_38);\n  }\n  else {\n    bVar3 = false;\n    local_a0 = (void *)0x0;\n    local_80 = (ulong)((uint)param_3 & 0x1fff);\n    local_78 = (ulong)(local_80 != 0) + (param_3 >> 0xd) + 1;\n    local_98 = 0;\n    local_c0 = 0;\n    bVar2 = false;\n    local_90 = 0;\n    local_88 = 1;\n    while (!bVar3) {\n      if (local_90 == local_c0) {\n        uVar5 = 0x7fffffffffffffff;\n        if (local_78 < 0x8000000000000000) {\n          uVar5 = local_78;\n        }\n        local_a0 = (void *)xpalloc(local_a0,&local_c0,1,uVar5,8);\n      }\n      if (!bVar2) {\n        puVar1 = (undefined8 *)(local_90 * 8 + (long)local_a0);\n        uVar6 = xmalloc(0x2000);\n        *puVar1 = uVar6;\n        local_98 = local_90 + 1;\n      }\n      local_a8 = full_read(param_2,*(undefined8 *)((long)local_a0 + local_90 * 8),0x2000);\n      if (local_a8 < 0x2000) {\n        piVar4 = __errno_location();\n        if (*piVar4 != 0) {\n          diagnose_read_failure(param_1);\n          local_c6 = 0;\n          goto LAB_00100e00;\n        }\n        bVar3 = true;\n      }\n      if (local_90 + 1 == local_78) {\n        bVar2 = true;\n      }\n      if (bVar2) {\n        local_b8 = local_b8 + local_a8;\n        xwrite_stdout(*(undefined8 *)((long)local_a0 + local_88 * 8),local_a8);\n      }\n      local_90 = local_88;\n      local_88 = (local_88 + 1) % local_78;\n    }\n    local_70 = 0x2000 - local_80;\n    if (bVar2) {\n      local_58 = 0x2000 - local_a8;\n      local_b8 = local_b8 + local_70;\n      if (local_70 < local_58) {\n        xwrite_stdout(local_a8 + *(long *)((long)local_a0 + local_90 * 8),local_70);\n      }\n      else {\n        xwrite_stdout(local_a8 + *(long *)((long)local_a0 + local_90 * 8),local_58);\n        xwrite_stdout(*(undefined8 *)((long)local_a0 + local_88 * 8),local_70 - local_58);\n      }\n    }\n    else if (local_90 + 1 == local_78) {\n      local_68 = 0x2000 - local_70;\n      local_60 = local_a8 - local_68;\n      local_b8 = local_b8 + local_60;\n      xwrite_stdout(*(undefined8 *)((long)local_a0 + local_88 * 8),local_60);\n    }\nLAB_00100e00:\n    for (local_90 = 0; (long)local_90 < local_98; local_90 = local_90 + 1) {\n      free(*(void **)((long)local_a0 + local_90 * 8));\n    }\n    free(local_a0);\n  }\n  if (-1 < param_4) {\n    lVar7 = elseek(param_2,local_b8,0,param_1);\n    if (lVar7 < 0) {\n      local_c6 = 0;\n    }\n  }\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return local_c6;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "elide_tail_bytes_pipe",
                        "xnmalloc",
                        "full_read",
                        "__errno_location",
                        "diagnose_read_failure",
                        "xwrite_stdout",
                        "free",
                        "xpalloc",
                        "xmalloc",
                        "elseek",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "elide_tail_bytes_pipe",
                        "elide_tail_bytes_file"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "elide_tail_bytes_file",
                "func_c_signature": "undefined8\nelide_tail_bytes_file(undefined8 param_1,undefined4 param_2,ulong param_3,long param_4,long param_5)",
                "decompiled_code": "undefined8\nelide_tail_bytes_file(undefined8 param_1,undefined4 param_2,ulong param_3,long param_4,long param_5) {\n  int iVar1;\n  long lVar2;\n  undefined8 uVar3;\n  ulong uVar4;\n  \n  if (-1 < param_5) {\n    if ((*(long *)(param_4 + 0x38) < 1) || (0x2000000000000000 < *(ulong *)(param_4 + 0x38))) {\n      lVar2 = 0x200;\n    }\n    else {\n      lVar2 = *(long *)(param_4 + 0x38);\n    }\n    if (lVar2 < *(long *)(param_4 + 0x30)) {\n      uVar4 = *(long *)(param_4 + 0x30) - param_5;\n      if ((long)uVar4 < 0) {\n        uVar4 = 0;\n      }\n      if (uVar4 <= param_3) {\n        return 1;\n      }\n      iVar1 = copy_fd(param_2,uVar4 - param_3);\n      if (iVar1 == 0) {\n        return 1;\n      }\n      diagnose_copy_fd_failure(iVar1,param_1);\n      return 0;\n    }\n  }\n  uVar3 = elide_tail_bytes_pipe(param_1,param_2,param_3,param_5);\n  return uVar3;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "elide_tail_bytes_file",
                        "copy_fd",
                        "diagnose_copy_fd_failure",
                        "elide_tail_bytes_pipe"
                    ],
                    "calling_functions": [
                        "elide_tail_bytes_file",
                        "head"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "elide_tail_lines_pipe",
                "func_c_signature": "undefined elide_tail_lines_pipe(undefined8 param_1,int param_2,ulong param_3,char *param_4)",
                "decompiled_code": "undefined elide_tail_lines_pipe(undefined8 param_1,int param_2,ulong param_3,char *param_4) {\n  long *plVar1;\n  char *pcVar2;\n  ssize_t sVar3;\n  long lVar4;\n  undefined local_61;\n  char *local_60;\n  char *local_58;\n  char *local_50;\n  char *local_48;\n  ulong local_40;\n  char *local_38;\n  long local_30;\n  char *local_28;\n  \n  local_40 = 0;\n  local_61 = 1;\n  local_58 = (char *)xmalloc(0x2020);\n  *(undefined8 *)(local_58 + 0x2010) = 0;\n  *(undefined8 *)(local_58 + 0x2008) = *(undefined8 *)(local_58 + 0x2010);\n  *(undefined8 *)(local_58 + 0x2018) = 0;\n  local_48 = (char *)xmalloc(0x2020);\n  local_60 = param_4;\n  local_50 = local_58;\n  while (sVar3 = read(param_2,local_48,0x2000), 0 < sVar3) {\n    if (param_3 == 0) {\n      local_60 = local_60 + sVar3;\n      xwrite_stdout(local_48,sVar3);\n    }\n    else {\n      *(ssize_t *)(local_48 + 0x2008) = sVar3;\n      *(undefined8 *)(local_48 + 0x2010) = 0;\n      *(undefined8 *)(local_48 + 0x2018) = 0;\n      local_48[sVar3] = line_end;\n      local_38 = local_48;\n      while (local_38 = (char *)rawmemchr(local_38,(int)line_end), local_38 < local_48 + sVar3) {\n        local_38 = local_38 + 1;\n        *(long *)(local_48 + 0x2010) = *(long *)(local_48 + 0x2010) + 1;\n      }\n      local_40 = local_40 + *(long *)(local_48 + 0x2010);\n      if ((ulong)(*(long *)(local_50 + 0x2008) + *(long *)(local_48 + 0x2008)) < 0x2000) {\n        memcpy(local_50 + *(long *)(local_50 + 0x2008),local_48,*(size_t *)(local_48 + 0x2008));\n        *(long *)(local_50 + 0x2008) = *(long *)(local_50 + 0x2008) + *(long *)(local_48 + 0x2008);\n        *(long *)(local_50 + 0x2010) = *(long *)(local_50 + 0x2010) + *(long *)(local_48 + 0x2010);\n      }\n      else {\n        *(char **)(local_50 + 0x2018) = local_48;\n        local_50 = *(char **)(local_50 + 0x2018);\n        if (param_3 < local_40 - *(long *)(local_58 + 0x2010)) {\n          local_60 = local_60 + *(long *)(local_58 + 0x2008);\n          xwrite_stdout(local_58,*(undefined8 *)(local_58 + 0x2008));\n          local_48 = local_58;\n          local_40 = local_40 - *(long *)(local_58 + 0x2010);\n          local_58 = *(char **)(local_58 + 0x2018);\n        }\n        else {\n          local_48 = (char *)xmalloc(0x2020);\n        }\n      }\n    }\n  }\n  free(local_48);\n  if (sVar3 < 0) {\n    diagnose_read_failure(param_1);\n    local_61 = 0;\n  }\n  else {\n    if ((*(long *)(local_50 + 0x2008) != 0) &&\n       (local_50[*(long *)(local_50 + 0x2008) + -1] != line_end)) {\n      *(long *)(local_50 + 0x2010) = *(long *)(local_50 + 0x2010) + 1;\n      local_40 = local_40 + 1;\n    }\n    local_48 = local_58;\n    for (; param_3 < local_40 - *(long *)(local_48 + 0x2010); local_40 = local_40 - *plVar1) {\n      local_60 = local_60 + *(long *)(local_48 + 0x2008);\n      xwrite_stdout(local_48,*(undefined8 *)(local_48 + 0x2008));\n      plVar1 = (long *)(local_48 + 0x2010);\n      local_48 = *(char **)(local_48 + 0x2018);\n    }\n    if (param_3 < local_40) {\n      local_30 = local_40 - param_3;\n      lVar4 = *(long *)(local_48 + 0x2008);\n      local_28 = local_48;\n      while ((local_30 != 0 &&\n             (local_28 = (char *)memchr(local_28,(int)line_end,\n                                        (size_t)(local_48 + (lVar4 - (long)local_28))),\n             local_28 != (char *)0x0))) {\n        local_28 = local_28 + 1;\n        *(long *)(local_48 + 0x2010) = *(long *)(local_48 + 0x2010) + 1;\n        local_30 = local_30 + -1;\n      }\n      local_60 = local_28 + ((long)local_60 - (long)local_48);\n      xwrite_stdout(local_48,(long)local_28 - (long)local_48);\n    }\n  }\n  while (local_58 != (char *)0x0) {\n    pcVar2 = *(char **)(local_58 + 0x2018);\n    free(local_58);\n    local_58 = pcVar2;\n  }\n  if ((-1 < (long)param_4) && (lVar4 = elseek(param_2,local_60,0,param_1), lVar4 < 0)) {\n    local_61 = 0;\n  }\n  return local_61;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "elide_tail_lines_pipe",
                        "xmalloc",
                        "read",
                        "xwrite_stdout",
                        "rawmemchr",
                        "memcpy",
                        "free",
                        "diagnose_read_failure",
                        "memchr",
                        "elseek"
                    ],
                    "calling_functions": [
                        "elide_tail_lines_pipe",
                        "elide_tail_lines_file"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "elide_tail_lines_seekable",
                "func_c_signature": "ulong elide_tail_lines_seekable\n                (undefined8 param_1,int param_2,long param_3,long param_4,long param_5)",
                "decompiled_code": "ulong elide_tail_lines_seekable\n                (undefined8 param_1,int param_2,long param_3,long param_4,long param_5) {\n  int iVar1;\n  long lVar2;\n  ulong uVar3;\n  long in_FS_OFFSET;\n  bool bVar4;\n  long local_2060;\n  size_t local_2038;\n  long local_2030;\n  size_t local_2028;\n  undefined8 local_2020;\n  undefined local_2018 [8200];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_2038 = (param_5 - param_4) % 0x2000;\n  if (local_2038 == 0) {\n    local_2038 = 0x2000;\n  }\n  local_2030 = param_5 - local_2038;\n  lVar2 = elseek(param_2,local_2030,0,param_1);\n  if (lVar2 < 0) {\n    uVar3 = 0;\n  }\n  else {\n    local_2038 = read(param_2,local_2018,local_2038);\n    if ((long)local_2038 < 0) {\n      diagnose_read_failure(param_1);\n      uVar3 = 0;\n    }\n    else {\n      local_2060 = param_3;\n      if (((param_3 != 0) && (local_2038 != 0)) && (local_2018[local_2038 - 1] != line_end)) {\n        local_2060 = param_3 + -1;\n      }\n      do {\n        local_2028 = local_2038;\n        while (local_2028 != 0) {\n          if (param_3 == 0) {\n            local_2028 = local_2028 - 1;\n          }\n          else {\n            local_2020 = memrchr(local_2018,(int)line_end,local_2028);\n            if (local_2020 == (void *)0x0) break;\n            local_2028 = (long)local_2020 - (long)local_2018;\n          }\n          bVar4 = local_2060 == 0;\n          local_2060 = local_2060 + -1;\n          if (bVar4) {\n            if (param_4 < local_2030) {\n              lVar2 = elseek(param_2,param_4,0,param_1);\n              if (lVar2 < 0) {\n                uVar3 = 0;\n                goto LAB_00101820;\n              }\n              iVar1 = copy_fd(param_2,local_2030 - param_4);\n              if (iVar1 != 0) {\n                diagnose_copy_fd_failure(iVar1,param_1);\n                uVar3 = 0;\n                goto LAB_00101820;\n              }\n            }\n            xwrite_stdout(local_2018,local_2028 + 1);\n            uVar3 = elseek(param_2,local_2028 + local_2030 + 1,0,param_1);\n            uVar3 = ~uVar3 >> 0x3f;\n            goto LAB_00101820;\n          }\n        }\n        if (local_2030 == param_4) {\n          uVar3 = 1;\n          goto LAB_00101820;\n        }\n        local_2030 = local_2030 + -0x2000;\n        lVar2 = elseek(param_2,local_2030,0,param_1);\n        if (lVar2 < 0) {\n          uVar3 = 0;\n          goto LAB_00101820;\n        }\n        local_2038 = read(param_2,local_2018,0x2000);\n        if ((long)local_2038 < 0) {\n          diagnose_read_failure(param_1);\n          uVar3 = 0;\n          goto LAB_00101820;\n        }\n      } while (local_2038 != 0);\n      uVar3 = 1;\n    }\n  }\nLAB_00101820:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar3;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "elide_tail_lines_seekable",
                        "elseek",
                        "read",
                        "diagnose_read_failure",
                        "memrchr",
                        "copy_fd",
                        "diagnose_copy_fd_failure",
                        "xwrite_stdout",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "elide_tail_lines_seekable",
                        "elide_tail_lines_file"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "elide_tail_lines_file",
                "func_c_signature": "ulong elide_tail_lines_file\n                (undefined8 param_1,undefined4 param_2,undefined8 param_3,long param_4,long param_5)",
                "decompiled_code": "ulong elide_tail_lines_file\n                (undefined8 param_1,undefined4 param_2,undefined8 param_3,long param_4,long param_5) {\n  long lVar1;\n  char cVar2;\n  uint uVar3;\n  long lVar4;\n  ulong uVar5;\n  \n  lVar1 = *(long *)(param_4 + 0x30);\n  if (-1 < param_5) {\n    if ((*(long *)(param_4 + 0x38) < 1) || (0x2000000000000000 < *(ulong *)(param_4 + 0x38))) {\n      lVar4 = 0x200;\n    }\n    else {\n      lVar4 = *(long *)(param_4 + 0x38);\n    }\n    if (lVar4 < lVar1) {\n      if ((param_5 < lVar1) &&\n         (cVar2 = elide_tail_lines_seekable(param_1,param_2,param_3,param_5,lVar1), cVar2 == '\\0'))\n      {\n        uVar3 = 0;\n      }\n      else {\n        uVar3 = 1;\n      }\n      return (ulong)uVar3;\n    }\n  }\n  uVar5 = elide_tail_lines_pipe(param_1,param_2,param_3,param_5);\n  return uVar5;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "elide_tail_lines_file",
                        "elide_tail_lines_seekable",
                        "elide_tail_lines_pipe"
                    ],
                    "calling_functions": [
                        "elide_tail_lines_file",
                        "head"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "head_bytes",
                "func_c_signature": "bool head_bytes(undefined8 param_1,undefined4 param_2,undefined8 param_3)",
                "decompiled_code": "bool head_bytes(undefined8 param_1,undefined4 param_2,undefined8 param_3) {\n  int iVar1;\n  \n  iVar1 = copy_fd(param_2,param_3);\n  if (iVar1 == 1) {\n    diagnose_read_failure(param_1);\n  }\n  return iVar1 != 1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "head_bytes",
                        "copy_fd",
                        "diagnose_read_failure"
                    ],
                    "calling_functions": [
                        "head_bytes",
                        "head"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "head_lines",
                "func_c_signature": "undefined8 head_lines(undefined8 param_1,int param_2,long param_3)",
                "decompiled_code": "undefined8 head_lines(undefined8 param_1,int param_2,long param_3) {\n  long lVar1;\n  char *pcVar2;\n  int iVar3;\n  ssize_t sVar4;\n  __off_t _Var5;\n  undefined8 uVar6;\n  long in_FS_OFFSET;\n  long local_20e0;\n  long local_20c0;\n  stat local_20a8;\n  char local_2018 [8200];\n  long local_10;\n  \n  local_10 = *(long *)(in_FS_OFFSET + 0x28);\n  local_20e0 = param_3;\n  while (local_20e0 != 0) {\n    sVar4 = read(param_2,local_2018,0x2000);\n    local_20c0 = 0;\n    if (sVar4 < 0) {\n      diagnose_read_failure(param_1);\n      uVar6 = 0;\n      goto LAB_00101b08;\n    }\n    if (sVar4 == 0) break;\n    do {\n      if (sVar4 <= local_20c0) goto LAB_00101ad9;\n      lVar1 = local_20c0 + 1;\n      pcVar2 = local_2018 + local_20c0;\n      local_20c0 = lVar1;\n    } while ((*pcVar2 != line_end) || (local_20e0 = local_20e0 + -1, local_20e0 != 0));\n    _Var5 = lseek(param_2,-(sVar4 - lVar1),1);\n    if ((_Var5 < 0) &&\n       ((iVar3 = fstat(param_2,&local_20a8), iVar3 != 0 || ((local_20a8.st_mode & 0xf000) == 0x8000)\n        ))) {\n      elseek_diagnostic(-(sVar4 - lVar1),1,param_1);\n    }\nLAB_00101ad9:\n    xwrite_stdout(local_2018,local_20c0);\n  }\n  uVar6 = 1;\nLAB_00101b08:\n  if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) {\n    return uVar6;\n  }\n                    /* WARNING: Subroutine does not return */\n  __stack_chk_fail();\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "head_lines",
                        "read",
                        "diagnose_read_failure",
                        "lseek",
                        "fstat",
                        "elseek_diagnostic",
                        "xwrite_stdout",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "head_lines",
                        "head"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "head",
                "func_c_signature": "undefined8 head(undefined8 param_1,int param_2,long param_3,char param_4,char param_5)",
                "decompiled_code": "undefined8 head(undefined8 param_1,int param_2,long param_3,char param_4,char param_5) {\n  int iVar1;\n  undefined8 uVar2;\n  undefined8 uVar3;\n  int *piVar4;\n  long in_FS_OFFSET;\n  long local_c8;\n  stat local_b8;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  if (print_headers != '\\0') {\n    write_header(param_1);\n  }\n  if (param_5 == '\\0') {\n    if (param_4 == '\\0') {\n      uVar2 = head_bytes(param_1,param_2,param_3);\n    }\n    else {\n      uVar2 = head_lines(param_1,param_2,param_3);\n    }\n  }\n  else if (param_3 == -1) {\n    uVar2 = 1;\n  }\n  else {\n    local_c8 = -1;\n    iVar1 = fstat(param_2,&local_b8);\n    if (iVar1 == 0) {\n      if ((presume_input_pipe != '\\x01') && ((local_b8.st_mode & 0xf000) == 0x8000)) {\n        local_c8 = elseek(param_2,0,1,param_1);\n        if (local_c8 < 0) {\n          uVar2 = 0;\n          goto LAB_00101d45;\n        }\n      }\n      if (param_4 == '\\0') {\n        uVar2 = elide_tail_bytes_file(param_1,param_2,param_3,&local_b8,local_c8);\n      }\n      else {\n        uVar2 = elide_tail_lines_file(param_1,param_2,param_3,&local_b8,local_c8);\n      }\n    }\n    else {\n      uVar2 = quotearg_style(4,param_1);\n      uVar3 = gettext(\"cannot fstat %s\");\n      piVar4 = __errno_location();\n      error(0,*piVar4,uVar3,uVar2);\n      uVar2 = 0;\n    }\n  }\nLAB_00101d45:\n  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {\n                    /* WARNING: Subroutine does not return */\n    __stack_chk_fail();\n  }\n  return uVar2;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "head",
                        "write_header",
                        "head_bytes",
                        "head_lines",
                        "fstat",
                        "elseek",
                        "elide_tail_bytes_file",
                        "elide_tail_lines_file",
                        "quotearg_style",
                        "gettext",
                        "__errno_location",
                        "error",
                        "__stack_chk_fail"
                    ],
                    "calling_functions": [
                        "head",
                        "head_file"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "head_file",
                "func_c_signature": "undefined head_file(char *param_1,undefined8 param_2,undefined param_3,undefined param_4)",
                "decompiled_code": "undefined head_file(char *param_1,undefined8 param_2,undefined param_3,undefined param_4) {\n  char cVar1;\n  undefined uVar2;\n  int iVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  char *local_50;\n  int local_3c;\n  \n  cVar1 = streq(param_1,&DAT_00102cdf);\n  if (cVar1 == '\\0') {\n    local_3c = open(param_1,0);\n    local_50 = param_1;\n    if (local_3c < 0) {\n      uVar4 = quotearg_style(4,param_1);\n      uVar5 = gettext(\"cannot open %s for reading\");\n      piVar6 = __errno_location();\n      error(0,*piVar6,uVar5,uVar4);\n      return 0;\n    }\n  }\n  else {\n    have_read_stdin = 1;\n    local_3c = 0;\n    local_50 = (char *)gettext(\"standard input\");\n    xset_binary_mode(0,0);\n  }\n  uVar2 = head(local_50,local_3c,param_2,param_3,param_4);\n  if ((cVar1 != '\\x01') && (iVar3 = close(local_3c), iVar3 != 0)) {\n    uVar4 = quotearg_style(4,local_50);\n    uVar5 = gettext(\"failed to close %s\");\n    piVar6 = __errno_location();\n    error(0,*piVar6,uVar5,uVar4);\n    uVar2 = 0;\n  }\n  return uVar2;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "head_file",
                        "streq",
                        "open",
                        "quotearg_style",
                        "gettext",
                        "__errno_location",
                        "error",
                        "xset_binary_mode",
                        "head",
                        "close"
                    ],
                    "calling_functions": [
                        "head_file",
                        "main"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "string_to_integer",
                "func_c_signature": "void string_to_integer(char param_1,undefined8 param_2)",
                "decompiled_code": "void string_to_integer(char param_1,undefined8 param_2) {\n  undefined8 uVar1;\n  \n  if (param_1 == '\\0') {\n    uVar1 = gettext(\"invalid number of bytes\");\n  }\n  else {\n    uVar1 = gettext(\"invalid number of lines\");\n  }\n  xnumtoumax(param_2,10,0,0xffffffffffffffff,\"bkKmMGTPEZYRQ0\",uVar1,0,2);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "string_to_integer",
                        "gettext",
                        "xnumtoumax"
                    ],
                    "calling_functions": [
                        "string_to_integer",
                        "main"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "byte main(int param_1,undefined8 *param_2)",
                "decompiled_code": "byte main(int param_1,undefined8 *param_2) {\n  char *pcVar1;\n  long lVar2;\n  char *pcVar3;\n  char cVar4;\n  byte bVar5;\n  int iVar6;\n  undefined8 uVar7;\n  undefined8 uVar8;\n  undefined1 *puVar9;\n  int *piVar10;\n  undefined8 *local_98;\n  int local_8c;\n  bool local_84;\n  undefined local_83;\n  bool local_82;\n  char local_81;\n  int local_80;\n  long local_60;\n  undefined8 local_58;\n  char *local_50;\n  \n  local_80 = 0;\n  local_84 = true;\n  local_58 = 10;\n  local_83 = 1;\n  local_82 = false;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit((__func *)&close_stdout);\n  have_read_stdin = '\\0';\n  print_headers = 0;\n  line_end = 10;\n  local_98 = param_2;\n  local_8c = param_1;\n  if (((1 < param_1) && (*(char *)param_2[1] == '-')) &&\n     (cVar4 = c_isdigit((int)*(char *)(param_2[1] + 1)), cVar4 != '\\0')) {\n    lVar2 = param_2[1];\n    local_81 = '\\0';\n    local_50 = (char *)(lVar2 + 1);\n    do {\n      pcVar3 = local_50;\n      pcVar1 = local_50 + 1;\n      cVar4 = c_isdigit((int)*pcVar1);\n      local_50 = pcVar1;\n    } while (cVar4 != '\\0');\n    for (; *local_50 != '\\0'; local_50 = local_50 + 1) {\n      switch(*local_50) {\n      case 'b':\n      case 'k':\n      case 'm':\n        local_83 = 0;\n        local_81 = *local_50;\n        break;\n      case 'c':\n        local_83 = 0;\n        local_81 = '\\0';\n        break;\n      default:\n        cVar4 = *local_50;\n        uVar8 = gettext(\"invalid trailing option -- %c\");\n        error(0,0,uVar8,(int)cVar4);\n        usage(1);\n        break;\n      case 'l':\n        local_83 = 1;\n        break;\n      case 'q':\n        local_80 = 2;\n        break;\n      case 'v':\n        local_80 = 1;\n        break;\n      case 'z':\n        line_end = 0;\n      }\n    }\n    *pcVar1 = local_81;\n    if (local_81 != '\\0') {\n      pcVar3[2] = '\\0';\n    }\n    local_58 = string_to_integer(local_83,(char *)(lVar2 + 1));\n    param_2[1] = *param_2;\n    local_98 = param_2 + 1;\n    local_8c = param_1 + -1;\n  }\n  do {\n    while( true ) {\n      iVar6 = getopt_long(local_8c,local_98,\"c:n:qvz0123456789\",long_options,0);\n      if (iVar6 == -1) {\n        if ((local_80 == 1) || ((local_80 == 0 && (_optind < local_8c + -1)))) {\n          print_headers = 1;\n        }\n        if (_optind < local_8c) {\n          puVar9 = (undefined1 *)(local_98 + _optind);\n        }\n        else {\n          puVar9 = default_file_list_0;\n        }\n        xset_binary_mode(1,0);\n        for (local_60 = 0; *(long *)((long)puVar9 + local_60 * 8) != 0; local_60 = local_60 + 1) {\n          bVar5 = head_file(*(undefined8 *)((long)puVar9 + local_60 * 8),local_58,local_83,local_82)\n          ;\n          local_84 = (bVar5 & local_84) != 0;\n        }\n        if ((have_read_stdin != '\\0') && (iVar6 = close(0), iVar6 < 0)) {\n          piVar10 = __errno_location();\n          error(1,*piVar10,&DAT_00102cdf);\n        }\n        return local_84 ^ 1;\n      }\n      if (iVar6 < 0x81) break;\nswitchD_0010222e_caseD_64:\n      cVar4 = c_isdigit(iVar6);\n      if (cVar4 != '\\0') {\n        uVar8 = gettext(\"invalid trailing option -- %c\");\n        error(0,0,uVar8,iVar6);\n      }\n      usage(1);\n    }\n    if (iVar6 < 99) {\n      if (iVar6 == -0x83) {\nLAB_00102303:\n        uVar8 = proper_name_lite(\"Jim Meyering\",\"Jim Meyering\");\n        uVar7 = proper_name_lite(\"David MacKenzie\",\"David MacKenzie\");\n        version_etc(_stdout,&DAT_00102bd2,\"GNU coreutils\",_Version,uVar7,uVar8,0);\n                    /* WARNING: Subroutine does not return */\n        exit(0);\n      }\n      if (iVar6 == -0x82) {\n        usage(0);\n        goto LAB_00102303;\n      }\n      goto switchD_0010222e_caseD_64;\n    }\n    switch(iVar6) {\n    case 99:\n      local_83 = 0;\n      local_82 = *_optarg == '-';\n      if (local_82) {\n        _optarg = _optarg + 1;\n      }\n      local_58 = string_to_integer(0,_optarg);\n      break;\n    default:\n      goto switchD_0010222e_caseD_64;\n    case 0x6e:\n      local_83 = 1;\n      local_82 = *_optarg == '-';\n      if (local_82) {\n        _optarg = _optarg + 1;\n      }\n      local_58 = string_to_integer(1,_optarg);\n      break;\n    case 0x71:\n      local_80 = 2;\n      break;\n    case 0x76:\n      local_80 = 1;\n      break;\n    case 0x7a:\n      line_end = 0;\n      break;\n    case 0x80:\n      presume_input_pipe = 1;\n    }\n  } while( true );\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "c_isdigit",
                        "gettext",
                        "error",
                        "usage",
                        "string_to_integer",
                        "getopt_long",
                        "xset_binary_mode",
                        "head_file",
                        "close",
                        "__errno_location",
                        "proper_name_lite",
                        "version_etc",
                        "exit"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "head_decompiled.c"
                }
            }
        ]
    }
}