{
    "file": "nohup",
    "decompiled_code": {
        "nohup.c": [
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\"Usage: %s COMMAND [ARG]...\\n  or:  %s OPTION\\n\");\n    printf(pcVar3,uVar2,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"Run COMMAND, ignoring hangup signals.\\n\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    uVar2 = _program_name;\n    pcVar3 = (char *)gettext(\n                            \"\\nIf standard input is a terminal, redirect it from an unreadable file.\\nIf standard output is a terminal, append output to \\'nohup.out\\' if possible,\\n\\'$HOME/nohup.out\\' otherwise.\\nIf standard error is a terminal, redirect it to standard output.\\nTo save output to FILE, use \\'%s COMMAND > FILE\\'.\\n\"\n                            );\n    printf(pcVar3,uVar2);\n    pcVar3 = (char *)gettext(\n                            \"\\nYour shell may have its own version of %s, which usually supersedes\\nthe version described here.  Please refer to your shell\\'s documentation\\nfor details about the options it supports.\\n\"\n                            );\n    printf(pcVar3,\"nohup\");\n    emit_exec_status(\"nohup\");\n    emit_ancillary_info(\"nohup\");\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "fputs_unlocked",
                        "emit_exec_status",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "nohup_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "undefined4 main(int param_1,undefined8 *param_2)",
                "decompiled_code": "undefined4 main(int param_1,undefined8 *param_2) {\n  bool bVar1;\n  undefined4 uVar2;\n  int iVar3;\n  __mode_t __mask;\n  int iVar4;\n  char *pcVar5;\n  undefined8 uVar6;\n  int *piVar7;\n  undefined8 uVar8;\n  char **__argv;\n  bool bVar9;\n  bool bVar10;\n  bool bVar11;\n  int local_f8;\n  int local_f4;\n  char *local_80;\n  char *local_78;\n  \n  local_f8 = 1;\n  local_f4 = 2;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  pcVar5 = getenv(\"POSIXLY_CORRECT\");\n  if (pcVar5 == (char *)0x0) {\n    uVar2 = 0x7d;\n  }\n  else {\n    uVar2 = 0x7f;\n  }\n  initialize_exit_failure(uVar2);\n  atexit((__func *)&close_stdout);\n  uVar6 = proper_name_lite(\"Jim Meyering\",\"Jim Meyering\");\n  parse_gnu_standard_options_only(param_1,param_2,\"nohup\",\"GNU coreutils\",_Version,0,usage,uVar6,0);\n  if (param_1 <= _optind) {\n    uVar6 = gettext(\"missing operand\");\n    error(0,0,uVar6);\n    usage(uVar2);\n  }\n  iVar3 = isatty(0);\n  bVar9 = iVar3 != 0;\n  iVar3 = isatty(1);\n  bVar10 = iVar3 != 0;\n  if ((bVar10) || (piVar7 = __errno_location(), *piVar7 != 9)) {\n    bVar1 = false;\n  }\n  else {\n    bVar1 = true;\n  }\n  iVar3 = isatty(2);\n  bVar11 = iVar3 != 0;\n  if (bVar9) {\n    iVar3 = fd_reopen(0,\"/dev/null\",1,0);\n    if (iVar3 < 0) {\n      uVar6 = gettext(\"failed to render standard input unusable\");\n      piVar7 = __errno_location();\n      error(uVar2,*piVar7,uVar6);\n    }\n    if ((!bVar10) && (!bVar11)) {\n      uVar6 = gettext(\"ignoring input\");\n      error(0,0,uVar6);\n    }\n  }\n  if ((bVar10) || ((bVar11 && (bVar1)))) {\n    local_80 = (char *)0x0;\n    local_78 = \"nohup.out\";\n    __mask = umask(0);\n    if (bVar10) {\n      local_f8 = fd_reopen(1,\"nohup.out\",0x441,0x180);\n    }\n    else {\n      local_f8 = open(\"nohup.out\",0x441,0x180);\n    }\n    if (local_f8 < 0) {\n      piVar7 = __errno_location();\n      iVar3 = *piVar7;\n      pcVar5 = getenv(\"HOME\");\n      if (pcVar5 != (char *)0x0) {\n        local_80 = (char *)file_name_concat(pcVar5,\"nohup.out\",0);\n        if (bVar10) {\n          local_f8 = fd_reopen(1,local_80,0x441,0x180);\n        }\n        else {\n          local_f8 = open(local_80,0x441,0x180);\n        }\n      }\n      if (local_f8 < 0) {\n        piVar7 = __errno_location();\n        iVar4 = *piVar7;\n        uVar6 = quotearg_style(4,\"nohup.out\");\n        uVar8 = gettext(\"failed to open %s\");\n        error(0,iVar3,uVar8,uVar6);\n        if (local_80 == (char *)0x0) {\n          return uVar2;\n        }\n        uVar6 = quotearg_style(4,local_80);\n        uVar8 = gettext(\"failed to open %s\");\n        error(0,iVar4,uVar8,uVar6);\n        return uVar2;\n      }\n      local_78 = local_80;\n    }\n    umask(__mask);\n    uVar6 = quotearg_style(4,local_78);\n    if (bVar9) {\n      pcVar5 = \"ignoring input and appending output to %s\";\n    }\n    else {\n      pcVar5 = \"appending output to %s\";\n    }\n    uVar8 = gettext(pcVar5);\n    error(0,0,uVar8,uVar6);\n    free(local_80);\n  }\n  if (bVar11) {\n    local_f4 = rpl_fcntl(2,0x406,3);\n    if (!bVar10) {\n      if (bVar9) {\n        pcVar5 = \"ignoring input and redirecting standard error to standard output\";\n      }\n      else {\n        pcVar5 = \"redirecting standard error to standard output\";\n      }\n      uVar6 = gettext(pcVar5);\n      error(0,0,uVar6);\n    }\n    iVar3 = dup2(local_f8,2);\n    if (iVar3 < 0) {\n      uVar6 = gettext(\"failed to redirect standard error\");\n      piVar7 = __errno_location();\n      error(uVar2,*piVar7,uVar6);\n    }\n    if (bVar1) {\n      close(local_f8);\n    }\n  }\n  iVar3 = ferror_unlocked(_stderr);\n  if (iVar3 == 0) {\n    signal(1,(__sighandler_t)0x1);\n    __argv = (char **)(param_2 + _optind);\n    execvp(*__argv,__argv);\n    piVar7 = __errno_location();\n    if (*piVar7 == 2) {\n      uVar2 = 0x7f;\n    }\n    else {\n      uVar2 = 0x7e;\n    }\n    piVar7 = __errno_location();\n    iVar3 = *piVar7;\n    iVar4 = dup2(local_f4,2);\n    if (iVar4 == 2) {\n      uVar6 = quotearg_style(4,*__argv);\n      uVar8 = gettext(\"failed to run command %s\");\n      error(0,iVar3,uVar8,uVar6);\n    }\n  }\n  return uVar2;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "getenv",
                        "initialize_exit_failure",
                        "atexit",
                        "proper_name_lite",
                        "parse_gnu_standard_options_only",
                        "gettext",
                        "error",
                        "usage",
                        "isatty",
                        "__errno_location",
                        "fd_reopen",
                        "umask",
                        "open",
                        "file_name_concat",
                        "quotearg_style",
                        "free",
                        "rpl_fcntl",
                        "dup2",
                        "close",
                        "ferror_unlocked",
                        "signal",
                        "execvp"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "nohup_decompiled.c"
                }
            }
        ]
    }
}