{
    "file": "mkdir",
    "decompiled_code": {
        "mkdir.c": [
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\"Usage: %s [OPTION]... DIRECTORY...\\n\");\n    printf(pcVar3,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"Create the DIRECTORY(ies), if they do not already exist.\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_mandatory_arg_note();\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -m, --mode=MODE   set file mode (as in chmod), not a=rwx - umask\\n  -p, --parents     no error if existing, make parent directories as needed,\\n                    with their file modes unaffected by any -m option\\n  -v, --verbose     print a message for each created directory\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -Z                   set SELinux security context of each created directory\\n                         to the default type\\n      --context[=CTX]  like -Z, or if CTX is specified then set the SELinux\\n                         or SMACK security context to CTX\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_ancillary_info(\"mkdir\");\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "DIRECTORY",
                    "mode"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "DIRECTORY",
                        "fputs_unlocked",
                        "emit_mandatory_arg_note",
                        "mode",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "mkdir_decompiled.c"
                }
            },
            {
                "func_name": "announce_mkdir",
                "func_c_signature": "void announce_mkdir(undefined8 param_1,long param_2)",
                "decompiled_code": "void announce_mkdir(undefined8 param_1,long param_2) {\n  undefined8 uVar1;\n  \n  if (*(long *)(param_2 + 0x20) != 0) {\n    uVar1 = quotearg_style(4,param_1);\n    prog_fprintf(_stdout,*(undefined8 *)(param_2 + 0x20),uVar1);\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "announce_mkdir",
                        "quotearg_style",
                        "prog_fprintf"
                    ],
                    "calling_functions": [
                        "announce_mkdir",
                        "make_ancestor"
                    ],
                    "defined_in_file": "mkdir_decompiled.c"
                }
            },
            {
                "func_name": "make_ancestor",
                "func_c_signature": "uint make_ancestor(undefined8 param_1,char *param_2,long param_3)",
                "decompiled_code": "uint make_ancestor(undefined8 param_1,char *param_2,long param_3) {\n  char cVar1;\n  int iVar2;\n  int *piVar3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  uint local_38;\n  \n  if (*(long *)(param_3 + 0x18) != 0) {\n    iVar2 = defaultcon(*(undefined8 *)(param_3 + 0x18),param_2,0x4000);\n    if (iVar2 < 0) {\n      piVar3 = __errno_location();\n      cVar1 = ignorable_ctx_err(*piVar3);\n      if (cVar1 != '\\x01') {\n        uVar4 = quotearg_style(4,param_1);\n        uVar5 = gettext(\"failed to set default creation context for %s\");\n        piVar3 = __errno_location();\n        error(0,*piVar3,uVar5,uVar4);\n      }\n    }\n  }\n  if (*(int *)(param_3 + 8) != *(int *)(param_3 + 0xc)) {\n    umask(*(__mode_t *)(param_3 + 8));\n  }\n  local_38 = mkdir(param_2,0x1ff);\n  if (*(int *)(param_3 + 8) != *(int *)(param_3 + 0xc)) {\n    piVar3 = __errno_location();\n    iVar2 = *piVar3;\n    umask(*(__mode_t *)(param_3 + 0xc));\n    piVar3 = __errno_location();\n    *piVar3 = iVar2;\n  }\n  if (local_38 == 0) {\n    local_38 = (uint)((*(uint *)(param_3 + 8) & 0x100) != 0);\n    announce_mkdir(param_1,param_3);\n  }\n  return local_38;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "make_ancestor",
                        "defaultcon",
                        "__errno_location",
                        "ignorable_ctx_err",
                        "quotearg_style",
                        "gettext",
                        "error",
                        "umask",
                        "mkdir",
                        "announce_mkdir"
                    ],
                    "calling_functions": [
                        "make_ancestor"
                    ],
                    "defined_in_file": "mkdir_decompiled.c"
                }
            },
            {
                "func_name": "process_dir",
                "func_c_signature": "byte process_dir(undefined8 param_1,undefined8 param_2,long *param_3)",
                "decompiled_code": "byte process_dir(undefined8 param_1,undefined8 param_2,long *param_3) {\n  char cVar1;\n  byte bVar2;\n  int iVar3;\n  int *piVar4;\n  undefined8 uVar5;\n  undefined8 uVar6;\n  \n  if ((param_3[3] != 0) && (*param_3 == 0)) {\n    iVar3 = defaultcon(param_3[3],param_1,0x4000);\n    if (iVar3 < 0) {\n      piVar4 = __errno_location();\n      cVar1 = ignorable_ctx_err(*piVar4);\n      if (cVar1 != '\\x01') {\n        uVar5 = quotearg_style(4,param_1);\n        uVar6 = gettext(\"failed to set default creation context for %s\");\n        piVar4 = __errno_location();\n        error(0,*piVar4,uVar6,uVar5);\n      }\n    }\n  }\n  bVar2 = make_dir_parents(param_1,param_2,*param_3,param_3,*(undefined4 *)(param_3 + 2),\n                           announce_mkdir,*(undefined4 *)((long)param_3 + 0x14),0xffffffffffffffff,\n                           0xffffffffffffffff,1);\n  if ((((bVar2 ^ 1) == 0) && (param_3[3] != 0)) && (*param_3 != 0)) {\n    uVar5 = last_component(param_1);\n    cVar1 = restorecon(param_3[3],uVar5,0);\n    if (cVar1 != '\\x01') {\n      piVar4 = __errno_location();\n      cVar1 = ignorable_ctx_err(*piVar4);\n      if (cVar1 != '\\x01') {\n        uVar5 = quotearg_style(4,param_1);\n        uVar6 = gettext(\"failed to restore context for %s\");\n        piVar4 = __errno_location();\n        error(0,*piVar4,uVar6,uVar5);\n      }\n    }\n  }\n  return bVar2 ^ 1;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "process_dir",
                        "defaultcon",
                        "__errno_location",
                        "ignorable_ctx_err",
                        "quotearg_style",
                        "gettext",
                        "error",
                        "make_dir_parents",
                        "last_component",
                        "restorecon"
                    ],
                    "calling_functions": [
                        "process_dir"
                    ],
                    "defined_in_file": "mkdir_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "void main(int param_1,undefined8 *param_2)",
                "decompiled_code": "void main(int param_1,undefined8 *param_2) {\n  char cVar1;\n  int iVar2;\n  __mode_t _Var3;\n  undefined8 uVar4;\n  undefined8 uVar5;\n  int *piVar6;\n  void *__ptr;\n  long in_FS_OFFSET;\n  int local_ac;\n  long local_80;\n  long local_78;\n  code *local_48;\n  uint local_40;\n  uint local_3c;\n  uint local_38;\n  undefined4 local_34;\n  undefined8 local_30;\n  undefined8 local_28;\n  long local_20;\n  \n  local_20 = *(long *)(in_FS_OFFSET + 0x28);\n  local_80 = 0;\n  local_78 = 0;\n  local_48 = (code *)0x0;\n  local_38 = 0x1ff;\n  local_34 = 0;\n  local_28 = 0;\n  local_30 = 0;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit((__func *)&close_stdout);\nLAB_00100a61:\n  while( true ) {\n    iVar2 = getopt_long(param_1,param_2,\"pm:vZ\",longopts,0);\n    if (iVar2 == -1) {\n      if (param_1 == _optind) {\n        uVar4 = gettext(\"missing operand\");\n        error(0,0,uVar4);\n        usage(1);\n      }\n      if (local_78 != 0) {\n        cVar1 = is_smack_enabled();\n        if (cVar1 == '\\0') {\n          local_ac = setfscreatecon(local_78);\n        }\n        else {\n          local_ac = smack_set_label_for_self(local_78);\n        }\n        if (local_ac < 0) {\n          uVar4 = quote(local_78);\n          uVar5 = gettext(\"failed to set default file creation context to %s\");\n          piVar6 = __errno_location();\n          error(1,*piVar6,uVar5,uVar4);\n        }\n      }\n      if ((local_48 != (code *)0x0) || (local_80 != 0)) {\n        _Var3 = umask(0);\n        local_40 = _Var3 & 0xffffff3f;\n        if (local_80 == 0) {\n          local_38 = 0x1ff;\n          local_3c = _Var3;\n        }\n        else {\n          __ptr = (void *)mode_compile(local_80);\n          if (__ptr == (void *)0x0) {\n            uVar4 = quote(local_80);\n            uVar5 = gettext(\"invalid mode %s\");\n            error(1,0,uVar5,uVar4);\n          }\n          local_38 = mode_adjust(0x1ff,1,_Var3,__ptr,&local_34);\n          local_3c = ~local_38 & _Var3;\n          free(__ptr);\n        }\n        umask(local_3c);\n      }\n      savewd_process_files(param_1 - _optind,param_2 + _optind,process_dir,&local_48);\n      if (local_20 == *(long *)(in_FS_OFFSET + 0x28)) {\n        return;\n      }\n                    /* WARNING: Subroutine does not return */\n      __stack_chk_fail();\n    }\n    if (iVar2 != 0x76) break;\n    local_28 = gettext(\"created directory %s\");\n  }\n  if (iVar2 < 0x77) {\n    if (iVar2 == 0x70) {\n      local_48 = make_ancestor;\n      goto LAB_00100a61;\n    }\n    if (0x70 < iVar2) goto LAB_00100a56;\n    if (iVar2 == 0x6d) {\n      local_80 = _optarg;\n      goto LAB_00100a61;\n    }\n    if (iVar2 < 0x6e) {\n      if (iVar2 == 0x5a) {\n        cVar1 = is_smack_enabled();\n        if (cVar1 == '\\0') {\n          if (_optarg != 0) {\n            uVar4 = gettext(\n                           \"warning: ignoring --context; it requires an SELinux/SMACK-enabled kernel\"\n                           );\n            error(0,0,uVar4);\n          }\n        }\n        else {\n          local_78 = _optarg;\n        }\n        goto LAB_00100a61;\n      }\n      if (iVar2 < 0x5b) {\n        if (iVar2 == -0x83) {\nLAB_001009fb:\n          uVar4 = proper_name_lite(\"David MacKenzie\",\"David MacKenzie\");\n          version_etc(_stdout,\"mkdir\",\"GNU coreutils\",_Version,uVar4,0);\n                    /* WARNING: Subroutine does not return */\n          exit(0);\n        }\n        if (iVar2 == -0x82) {\n          usage(0);\n          goto LAB_001009fb;\n        }\n      }\n    }\n  }\nLAB_00100a56:\n  usage(1);\n  goto LAB_00100a61;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "getopt_long",
                        "gettext",
                        "error",
                        "usage",
                        "is_smack_enabled",
                        "setfscreatecon",
                        "smack_set_label_for_self",
                        "quote",
                        "__errno_location",
                        "umask",
                        "mode_compile",
                        "mode_adjust",
                        "free",
                        "savewd_process_files",
                        "__stack_chk_fail",
                        "proper_name_lite",
                        "version_etc",
                        "exit"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "mkdir_decompiled.c"
                }
            }
        ]
    }
}