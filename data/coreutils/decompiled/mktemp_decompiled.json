{
    "file": "mktemp",
    "decompiled_code": {
        "mktemp.c": [
            {
                "func_name": "usage",
                "func_c_signature": "void usage(int param_1)",
                "decompiled_code": "void usage(int param_1) {\n  FILE *pFVar1;\n  undefined8 uVar2;\n  char *pcVar3;\n  \n  uVar2 = _program_name;\n  if (param_1 == 0) {\n    pcVar3 = (char *)gettext(\"Usage: %s [OPTION]... [TEMPLATE]\\n\");\n    printf(pcVar3,uVar2);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"Create a temporary file or directory, safely, and print its name.\\nTEMPLATE must contain at least 3 consecutive \\'X\\'s in last component.\\nIf TEMPLATE is not specified, use tmp.XXXXXXXXXX, and --tmpdir is implied.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"Files are created u+rw, and directories u+rwx, minus umask restrictions.\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    fputc_unlocked(10,_stdout);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -d, --directory     create a directory, not a file\\n  -u, --dry-run       do not create anything; merely print a name (unsafe)\\n  -q, --quiet         suppress diagnostics about file/dir-creation failure\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"      --suffix=SUFF   append SUFF to TEMPLATE; SUFF must not contain a slash.\\n                        This option is implied if TEMPLATE does not end in X\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -p DIR, --tmpdir[=DIR]  interpret TEMPLATE relative to DIR; if DIR is not\\n                        specified, use $TMPDIR if set, else /tmp.  With\\n                        this option, TEMPLATE must not be an absolute name;\\n                        unlike with -t, TEMPLATE may contain slashes, but\\n                        mktemp creates only the final component\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\n                            \"  -t                  interpret TEMPLATE as a single file name component,\\n                        relative to a directory: $TMPDIR, if set; else the\\n                        directory specified via -p; else /tmp [deprecated]\\n\"\n                            );\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --help        display this help and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    pFVar1 = _stdout;\n    pcVar3 = (char *)gettext(\"      --version     output version information and exit\\n\");\n    fputs_unlocked(pcVar3,pFVar1);\n    emit_ancillary_info(\"mktemp\");\n  }\n  else {\n    pcVar3 = (char *)gettext(\"Try \\'%s --help\\' for more information.\\n\");\n    fprintf(_stderr,pcVar3,uVar2);\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(param_1);\n}",
                "globals": [],
                "externs": [
                    "name"
                ],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "usage",
                        "gettext",
                        "printf",
                        "fputs_unlocked",
                        "fputc_unlocked",
                        "name",
                        "emit_ancillary_info",
                        "fprintf",
                        "exit"
                    ],
                    "calling_functions": [
                        "usage",
                        "main"
                    ],
                    "defined_in_file": "mktemp_decompiled.c"
                }
            },
            {
                "func_name": "count_consecutive_X_s",
                "func_c_signature": "long count_consecutive_X_s(long param_1,long param_2)",
                "decompiled_code": "long count_consecutive_X_s(long param_1,long param_2) {\n  long local_28;\n  long local_10;\n  \n  local_10 = 0;\n  for (local_28 = param_2; (local_28 != 0 && (*(char *)(param_1 + local_28 + -1) == 'X'));\n      local_28 = local_28 + -1) {\n    local_10 = local_10 + 1;\n  }\n  return local_10;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "count_consecutive_X_s"
                    ],
                    "calling_functions": [
                        "count_consecutive_X_s",
                        "main"
                    ],
                    "defined_in_file": "mktemp_decompiled.c"
                }
            },
            {
                "func_name": "mkstemp_len",
                "func_c_signature": "void mkstemp_len(undefined8 param_1,undefined4 param_2,undefined8 param_3,char param_4)",
                "decompiled_code": "void mkstemp_len(undefined8 param_1,undefined4 param_2,undefined8 param_3,char param_4) {\n  undefined8 uVar1;\n  \n  if (param_4 == '\\0') {\n    uVar1 = 0;\n  }\n  else {\n    uVar1 = 2;\n  }\n  gen_tempname_len(param_1,param_2,0,uVar1,param_3);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "mkstemp_len",
                        "gen_tempname_len"
                    ],
                    "calling_functions": [
                        "mkstemp_len",
                        "main"
                    ],
                    "defined_in_file": "mktemp_decompiled.c"
                }
            },
            {
                "func_name": "mkdtemp_len",
                "func_c_signature": "void mkdtemp_len(undefined8 param_1,undefined4 param_2,undefined8 param_3,char param_4)",
                "decompiled_code": "void mkdtemp_len(undefined8 param_1,undefined4 param_2,undefined8 param_3,char param_4) {\n  undefined8 uVar1;\n  \n  if (param_4 == '\\0') {\n    uVar1 = 1;\n  }\n  else {\n    uVar1 = 2;\n  }\n  gen_tempname_len(param_1,param_2,0,uVar1,param_3);\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "mkdtemp_len",
                        "gen_tempname_len"
                    ],
                    "calling_functions": [
                        "mkdtemp_len",
                        "main"
                    ],
                    "defined_in_file": "mktemp_decompiled.c"
                }
            },
            {
                "func_name": "maybe_close_stdout",
                "func_c_signature": "void maybe_close_stdout(void)",
                "decompiled_code": "void maybe_close_stdout(void) {\n  int iVar1;\n  \n  if (stdout_closed == '\\x01') {\n    iVar1 = close_stream(_stderr);\n    if (iVar1 != 0) {\n                    /* WARNING: Subroutine does not return */\n      _exit(1);\n    }\n  }\n  else {\n    close_stdout();\n  }\n  return;\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "maybe_close_stdout",
                        "close_stream",
                        "_exit",
                        "close_stdout"
                    ],
                    "calling_functions": [
                        "maybe_close_stdout"
                    ],
                    "defined_in_file": "mktemp_decompiled.c"
                }
            },
            {
                "func_name": "main",
                "func_c_signature": "void main(int param_1,undefined8 *param_2)",
                "decompiled_code": "void main(int param_1,undefined8 *param_2) {\n  bool bVar1;\n  bool bVar2;\n  bool bVar3;\n  bool bVar4;\n  int iVar5;\n  int iVar6;\n  undefined8 uVar7;\n  size_t sVar8;\n  undefined8 uVar9;\n  char *pcVar10;\n  ulong uVar11;\n  int *piVar12;\n  char local_111;\n  int local_110;\n  char *local_b0;\n  char *local_a8;\n  char *local_a0;\n  char *local_98;\n  size_t local_90;\n  char *local_88;\n  \n  local_a8 = (char *)0x0;\n  bVar4 = false;\n  local_98 = (char *)0x0;\n  bVar1 = false;\n  bVar2 = false;\n  bVar3 = false;\n  local_111 = '\\0';\n  local_110 = 0;\n  local_88 = (char *)0x0;\n  set_program_name(*param_2);\n  setlocale(6,\"\");\n  bindtextdomain(\"coreutils\",\"/usr/local/share/locale\");\n  textdomain(\"coreutils\");\n  atexit(maybe_close_stdout);\n  while (iVar5 = getopt_long(param_1,param_2,\"dp:qtuV\",longopts,0), iVar6 = _optind, iVar5 != -1) {\n    if (iVar5 < 0x81) {\n      if (iVar5 < 0x56) {\n        if (iVar5 == -0x83) {\nswitchD_00100673_caseD_56:\n          uVar7 = proper_name_lite(\"Eric Blake\",\"Eric Blake\");\n          uVar9 = proper_name_lite(\"Jim Meyering\",\"Jim Meyering\");\n          version_etc(_stdout,\"mktemp\",\"GNU coreutils\",_Version,uVar9,uVar7,0);\n                    /* WARNING: Subroutine does not return */\n          exit(0);\n        }\n        if (iVar5 == -0x82) {\n          usage(0);\n          goto switchD_00100673_caseD_56;\n        }\n        goto switchD_00100673_caseD_57;\n      }\n      switch(iVar5) {\n      case 0x56:\n        goto switchD_00100673_caseD_56;\n      default:\n        goto switchD_00100673_caseD_57;\n      case 100:\n        bVar3 = true;\n        break;\n      case 0x70:\n        local_a8 = _optarg;\n        bVar1 = true;\n        break;\n      case 0x71:\n        bVar4 = true;\n        break;\n      case 0x74:\n        bVar1 = true;\n        bVar2 = true;\n        break;\n      case 0x75:\n        local_111 = '\\x01';\n        break;\n      case 0x80:\n        local_98 = _optarg;\n      }\n    }\n    else {\nswitchD_00100673_caseD_57:\n      usage(1);\n    }\n  }\n  if (1 < param_1 - _optind) {\n    uVar7 = gettext(\"too many templates\");\n    error(0,0,uVar7);\n    usage(1);\n  }\n  if (param_1 == iVar6) {\n    bVar1 = true;\n    local_a0 = default_template;\n  }\n  else {\n    local_a0 = (char *)param_2[_optind];\n  }\n  if (local_98 == (char *)0x0) {\n    local_a0 = (char *)xstrdup(local_a0);\n    local_98 = strrchr(local_a0,0x58);\n    if (local_98 == (char *)0x0) {\n      sVar8 = strlen(local_a0);\n      local_98 = local_a0 + sVar8;\n    }\n    else {\n      local_98 = local_98 + 1;\n    }\n    local_90 = strlen(local_98);\n  }\n  else {\n    sVar8 = strlen(local_a0);\n    if ((sVar8 == 0) || (local_a0[sVar8 - 1] != 'X')) {\n      uVar7 = quote(local_a0);\n      uVar9 = gettext(\"with --suffix, template %s must end in X\");\n      error(1,0,uVar9,uVar7);\n    }\n    local_90 = strlen(local_98);\n    local_88 = (char *)xcharalloc(local_90 + sVar8 + 1);\n    memcpy(local_88,local_a0,sVar8);\n    memcpy(local_88 + sVar8,local_98,local_90 + 1);\n    local_98 = local_88 + sVar8;\n    local_a0 = local_88;\n  }\n  if ((local_90 != 0) && (pcVar10 = (char *)last_component(local_98), local_98 != pcVar10)) {\n    uVar7 = quote(local_98);\n    uVar9 = gettext(\"invalid suffix %s, contains directory separator\");\n    error(1,0,uVar9,uVar7);\n  }\n  uVar11 = count_consecutive_X_s(local_a0,(long)local_98 - (long)local_a0);\n  if (uVar11 < 3) {\n    if (local_a0 == local_88) {\n      *local_98 = '\\0';\n    }\n    uVar7 = quote(local_a0);\n    uVar9 = gettext(\"too few X\\'s in template %s\");\n    error(1,0,uVar9,uVar7);\n  }\n  if (!bVar1) goto LAB_00100d1c;\n  if (bVar2) {\n    local_b0 = getenv(\"TMPDIR\");\n    if ((local_b0 == (char *)0x0) || (*local_b0 == '\\0')) {\n      if ((local_a8 == (char *)0x0) || (*local_a8 == '\\0')) {\n        local_b0 = \"/tmp\";\n      }\n      else {\n        local_b0 = local_a8;\n      }\n    }\n    pcVar10 = (char *)last_component(local_a0);\n    if (local_a0 != pcVar10) {\n      uVar7 = quote(local_a0);\n      uVar9 = gettext(\"invalid template, %s, contains directory separator\");\n      error(1,0,uVar9,uVar7);\n      goto LAB_00100c18;\n    }\n  }\n  else {\nLAB_00100c18:\n    if ((local_a8 == (char *)0x0) || (*local_a8 == '\\0')) {\n      local_b0 = getenv(\"TMPDIR\");\n      if ((local_b0 == (char *)0x0) || (*local_b0 == '\\0')) {\n        local_b0 = \"/tmp\";\n      }\n    }\n    else {\n      local_b0 = local_a8;\n    }\n    if (*local_a0 == '/') {\n      uVar7 = quote(local_a0);\n      uVar9 = gettext(\"invalid template, %s; with --tmpdir, it may not be absolute\");\n      error(1,0,uVar9,uVar7);\n    }\n  }\n  pcVar10 = (char *)file_name_concat(local_b0,local_a0,0);\n  free(local_a0);\n  local_a0 = pcVar10;\nLAB_00100d1c:\n  pcVar10 = (char *)xstrdup(local_a0);\n  if (bVar3) {\n    iVar6 = mkdtemp_len(pcVar10,local_90,uVar11,local_111);\n    if (iVar6 != 0) {\n      if (!bVar4) {\n        uVar7 = quote(local_a0);\n        uVar9 = gettext(\"failed to create directory via template %s\");\n        piVar12 = __errno_location();\n        error(0,*piVar12,uVar9,uVar7);\n      }\n      local_110 = 1;\n    }\n  }\n  else {\n    iVar6 = mkstemp_len(pcVar10,local_90,uVar11,local_111);\n    if ((iVar6 < 0) || ((local_111 != '\\x01' && (iVar6 = close(iVar6), iVar6 != 0)))) {\n      if (!bVar4) {\n        uVar7 = quote(local_a0);\n        uVar9 = gettext(\"failed to create file via template %s\");\n        piVar12 = __errno_location();\n        error(0,*piVar12,uVar9,uVar7);\n      }\n      local_110 = 1;\n    }\n  }\n  if ((local_110 == 0) && (puts(pcVar10), local_111 != '\\x01')) {\n    stdout_closed = 1;\n    iVar6 = close_stream(_stdout);\n    if (iVar6 != 0) {\n      piVar12 = __errno_location();\n      iVar6 = *piVar12;\n      remove(pcVar10);\n      if (!bVar4) {\n        uVar7 = gettext(\"write error\");\n        error(0,iVar6,uVar7);\n      }\n      local_110 = 1;\n    }\n  }\n                    /* WARNING: Subroutine does not return */\n  exit(local_110);\n}",
                "globals": [],
                "externs": [],
                "types": [],
                "includes": [],
                "dependencies": {
                    "called_functions": [
                        "main",
                        "set_program_name",
                        "setlocale",
                        "bindtextdomain",
                        "textdomain",
                        "atexit",
                        "getopt_long",
                        "proper_name_lite",
                        "version_etc",
                        "exit",
                        "usage",
                        "gettext",
                        "error",
                        "xstrdup",
                        "strrchr",
                        "strlen",
                        "quote",
                        "xcharalloc",
                        "memcpy",
                        "last_component",
                        "count_consecutive_X_s",
                        "getenv",
                        "file_name_concat",
                        "free",
                        "mkdtemp_len",
                        "__errno_location",
                        "mkstemp_len",
                        "close",
                        "puts",
                        "close_stream",
                        "remove"
                    ],
                    "calling_functions": [
                        "main"
                    ],
                    "defined_in_file": "mktemp_decompiled.c"
                }
            }
        ]
    }
}